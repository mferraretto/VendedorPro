<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ZPL Import ‚Äì Sem Gemini</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css?v=20240826">
  <style>
    :root { --primary: #ff6a00; --bg:#0b0c10; --card:#111318; --muted:#9aa4b2; --ok:#18b57e; --err:#ff4d4d; }
    *{box-sizing:border-box} body{margin:0;font-family:Inter,system-ui,Arial,sans-serif;background:linear-gradient(180deg,#0b0c10,#0f1117);color:#e6e6e6}
    header{position:sticky;top:0;z-index:5;background:rgba(15,17,23,.7);backdrop-filter:saturate(1.2) blur(10px);border-bottom:1px solid #1e2330}
    .wrap{max-width:1120px;margin:0 auto;padding:20px}
    h1{font-size:22px;display:flex;gap:10px;align-items:center;margin:0}
    .badge{font-size:12px;padding:4px 8px;border-radius:999px;background:#18202f;color:#a8b3c7;border:1px solid #223049}
    main{padding:28px 0}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:18px}
    .card{background:linear-gradient(180deg,#0f1420,#0d121a);border:1px solid #1e2330;border-radius:16px;box-shadow:0 8px 30px rgba(0,0,0,.25)}
    .card h2{font-size:16px;margin:0 0 12px;color:#d9e1ee}
    .card .body{padding:18px}
    .muted{color:#9aa4b2;font-size:13px}
    label{font-size:13px;color:#cfd7e6;margin-bottom:6px;display:block}
    input[type=file],input[type=text],input[type=email],input[type=password],select{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #2a3142;background:#0e1320;color:#e6eefc;outline:none}
    input::placeholder{color:#667084}
    .row{display:flex;gap:12px;align-items:center}
    .btn{cursor:pointer;user-select:none;display:inline-flex;align-items:center;gap:8px;border:none;border-radius:12px;padding:12px 16px;font-weight:600;background:linear-gradient(180deg,#ff7a1a,#ff6a00);color:#111;box-shadow:0 6px 16px rgba(255,106,0,.25)}
    .btn.secondary{background:#121826;color:#e6e6e6;border:1px solid #263248}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .progress{height:10px;background:#161b27;border-radius:999px;overflow:hidden;border:1px solid #20283a}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#67e8f9,#22d3ee,#60a5fa);transition:width .25s ease}
    .stat{display:flex;justify-content:space-between;font-size:12px;color:#9aa4b2;margin-top:8px}
    .toast{padding:12px 14px;border-radius:12px;font-size:14px}
    .ok{background:#0f201b;border:1px solid #1c4d3f;color:#9af6d0}
    .err{background:#201012;border:1px solid #4d1c22;color:#ffb3b3}
    .hidden{display:none}

    /* Modal */
    .modal-backdrop{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(10,12,18,.6);backdrop-filter:blur(6px);z-index:50}
    /* Use a unique class to avoid conflict with global .modal styles */
    .modal-card{display:block;width:100%;max-width:520px;background:#0f1420;border:1px solid #223049;border-radius:16px;box-shadow:0 20px 50px rgba(0,0,0,.45)}
    .modal-card .hd{padding:16px 18px;border-bottom:1px solid #1f283c;font-weight:700}
    .modal-card .ct{padding:18px}
    .modal-card .ft{padding:16px 18px;border-top:1px solid #1f283c;display:flex;gap:10px;justify-content:flex-end}

    /* Auth */
    .auth{display:grid;gap:10px}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:#141b2b;color:#a2b0c6;border:1px solid #223049;font-size:12px}
  </style>
</head>
<body>
  <div class="app-container">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="main-content">
  <header>
    <div class="wrap row" style="justify-content:space-between">
      <h1>üì¶ ZPL Import <span class="badge">Sem Gemini</span></h1>
      <div id="userBox" class="pill">Desconectado</div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <section class="card">
        <div class="body">
          <h2>1) Arquivo de Etiquetas</h2>
          <p class="muted">Selecione um arquivo <b>.zpl</b> ou <b>.txt</b> contendo blocos ZPL (etiqueta + checklist).</p>
          <div class="row">
            <input id="zplFile" type="file" accept=".zpl,.txt" />
          </div>
          <div style="height:10px"></div>
          <h2>2) Gestores e Regras</h2>
          <label for="gestoresEmails">E-mails de gestores (separe por v√≠rgula)</label>
          <input id="gestoresEmails" type="text" placeholder="gestor1@dominio.com, gestor2@dominio.com" />
          <p class="muted">Respeita os hor√°rios configurados no Firestore (campo <code>horariosEtiquetas</code> em <code>uid/{uid}</code>).</p>
          <div style="height:14px"></div>
          <button id="btnProcessar" class="btn">üîß Extrair e Gerar</button>
        </div>
      </section>

      <aside class="card">
        <div class="body">
          <h2>Status</h2>
          <div id="toastOk" class="toast ok hidden">Tudo pronto.</div>
          <div id="toastErr" class="toast err hidden"></div>
          <div id="progressWrap" class="hidden">
            <div class="progress"><div id="progressBar" class="bar"></div></div>
            <div class="stat"><span id="progressStatus">Aguardando‚Ä¶</span><span id="elapsed">00:00</span></div>
          </div>
        </div>
      </aside>
    </div>
  </main>

  </div>

  <!-- Libs: PDF e Firebase (compat) -->
  <script src="https://unpkg.com/pdf-lib@1.4.0"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script type="module">
  import { firebaseConfig } from './firebase-config.js';
  import { createOcrWorker } from './createWorker.js';
  // ===== Utilit√°rios UI =====
  const $ = (sel) => document.querySelector(sel);
  const sleep = (ms) => new Promise(r=>setTimeout(r, ms));
  const fmtTime = (s)=>{
    const m = Math.floor(s/60).toString().padStart(2,'0');
    const r = Math.floor(s%60).toString().padStart(2,'0');
    return `${m}:${r}`;
  };

  const el = {
    userBox: '#userBox',
    zplFile: '#zplFile', gestoresEmails: '#gestoresEmails', btnProcessar: '#btnProcessar',
    toastOk:'#toastOk', toastErr:'#toastErr', progressWrap:'#progressWrap', progressBar:'#progressBar', progressStatus:'#progressStatus', elapsed:'#elapsed',
    gestorModal:'#gestorModal', gestorSelect:'#gestorSelect', gestorConfirm:'#gestorConfirm', gestorCancel:'#gestorCancel'
  };

  function ensureGestorModal(){
    if(document.getElementById('gestorModal')) return;
    const wrap = document.createElement('div');
    wrap.innerHTML = `
    <div id="gestorModal" class="modal-backdrop hidden">
      <div class="modal-card">
        <div class="hd">Selecionar Gestor</div>
        <div class="ct">
          <p class="muted">Selecione qual gestor receber√° o PDF gerado.</p>
          <select id="gestorSelect"></select>
        </div>
        <div class="ft">
          <button id="gestorCancel" type="button" class="btn secondary">Cancelar</button>
          <button id="gestorConfirm" type="button" class="btn">Confirmar</button>
        </div>
      </div>
    </div>`;
    document.body.appendChild(wrap.firstElementChild);
  }

  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
    console.log('[Firebase] App initialized', firebaseConfig.projectId);
  } else {
    console.log('[Firebase] App already initialized', firebaseConfig.projectId);
  }
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();
  function showOk(msg){ const n=$(el.toastOk); n.textContent=msg; n.classList.remove('hidden'); }
  function hideOk(){ $(el.toastOk).classList.add('hidden'); }
  function showErr(msg){ const n=$(el.toastErr); n.textContent=msg; n.classList.remove('hidden'); }
  function hideErr(){ $(el.toastErr).classList.add('hidden'); }
  function setProgress(p, status){ $(el.progressWrap).classList.remove('hidden'); $(el.progressBar).style.width = `${Math.max(0,Math.min(100,p))}%`; if(status) $(el.progressStatus).textContent = status; }
  function resetProgress(){ $(el.progressWrap).classList.add('hidden'); $(el.progressBar).style.width='0%'; $(el.progressStatus).textContent='Aguardando‚Ä¶'; $(el.elapsed).textContent='00:00'; }

  const WORKER_COUNT = Math.min(4, navigator.hardwareConcurrency || 2);
  const ocrWorkers = await Promise.all(
    Array.from({ length: WORKER_COUNT }, () => createOcrWorker())
  );

  // Controle simples de pool de workers (fila de espera)
  const availableWorkers = [...ocrWorkers];
  const workerQueue = [];
  async function acquireWorker(){
    if(availableWorkers.length) return availableWorkers.pop();
    return new Promise(resolve => workerQueue.push(resolve));
  }
  function releaseWorker(w){
    if(workerQueue.length) workerQueue.shift()(w);
    else availableWorkers.push(w);
  }

  // ===== Auth =====
  let currentUser = null;
  auth.onAuthStateChanged(async (u)=>{
    currentUser = u || null;
    if(u){
      $(el.userBox).textContent = `Conectado: ${u.email}`;
      try { await preloadUserSettings(); } catch(e){ console.warn('Falha ao carregar settings', e); }
    } else {
      $(el.userBox).textContent = 'Desconectado';
    }
  });

  // ===== Configura√ß√µes por usu√°rio (gestores/hor√°rios) =====
  let horariosEtiquetas = [];
  let responsavelExpedicaoUid = null;
  let responsavelExpedicaoEmail = null;

  async function preloadUserSettings(){
    if(!currentUser) return;
    try {
      const doc = await db.collection('uid').doc(currentUser.uid).get();
      const data = doc.data()||{};
      const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
      $(el.gestoresEmails).value = Array.isArray(emails) ? emails.join(', ') : emails;
      const respEmail = Array.isArray(data.gestoresExpedicaoEmails) ? data.gestoresExpedicaoEmails[0] : data.responsavelExpedicaoEmail;
      if(respEmail){
        responsavelExpedicaoEmail = respEmail;
        const snap = await db.collection('uid').where('email','==', respEmail).limit(1).get();
        if(!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
        await carregarHorarios();
      }
    } catch(e){
      console.error('Erro ao carregar gestor de expedi√ß√£o:', e);
    }
  }

  async function carregarHorarios(){
    if(!responsavelExpedicaoUid) return;
    try {
      const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
      const data = doc.data()||{};
      horariosEtiquetas = data.horariosEtiquetas || [];
    } catch(e){
      console.error('Erro ao carregar hor√°rios:', e);
    }
  }

  function isDentroHorario(){
    if(!horariosEtiquetas?.length) return true; // se n√£o configurado, permite
    const now = new Date();
    return horariosEtiquetas.some(intv => {
      let ini, fim;
      if (Array.isArray(intv)) {
        [ini, fim] = intv;
      } else if (typeof intv === 'string') {
        [ini, fim] = intv.split('-');
      } else if (intv && typeof intv === 'object') {
        ini = intv.inicio;
        fim = intv.fim;
      }
      if(!ini || !fim) return false;
      const [h1, m1] = String(ini).split(':').map(Number);
      const [h2, m2] = String(fim).split(':').map(Number);
      const a = new Date(); a.setHours(h1||0, m1||0, 0, 0);
      const b = new Date(); b.setHours(h2||23, m2||59, 59, 999);
      return now >= a && now <= b;
    });
  }

  // ===== Modal Gestor =====
  function escolherGestorEmail(possiveis){
    ensureGestorModal();
    return new Promise((resolve)=>{
      const modal = $(el.gestorModal);
      const sel = $(el.gestorSelect);
      const confirmBtn = $(el.gestorConfirm);
      const cancelBtn = $(el.gestorCancel);
      sel.innerHTML = '';
      possiveis.forEach(e=>{
        const o=document.createElement('option');
        o.value=e;
        o.textContent=e;
        sel.appendChild(o);
      });
      function close(v){
        modal.classList.add('hidden');
        confirmBtn.removeEventListener('click', onConfirm);
        cancelBtn.removeEventListener('click', onCancel);
        modal.removeEventListener('click', onBackdrop);
        resolve(v||possiveis[0]);
      }
      function onConfirm(){ close(sel.value); }
      function onCancel(){ close(possiveis[0]); }
      function onBackdrop(e){ if(e.target===modal) close(possiveis[0]); }
      confirmBtn.addEventListener('click', onConfirm);
      cancelBtn.addEventListener('click', onCancel);
      modal.addEventListener('click', onBackdrop);
      modal.classList.remove('hidden');
    });
  }

  // ===== Helpers ZPL / OCR =====
  function readFileAsText(file){
    return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onerror=()=>rej(fr.error); fr.onload=()=>res(fr.result); fr.readAsText(file); });
  }
  function splitZplBlocks(zpl){ // captura blocos ^XA ... ^XZ (ignora ~DGR isolados)
    const blocks = zpl.match(/\^XA[\s\S]*?\^XZ/g) || [];
    return blocks;
  }
  function buildPrefixWithDG(allZplText){
    const dgrs = allZplText.match(/~DGR[\s\S]*?\^XZ/g) || [];
    return dgrs.length ? dgrs.join('\n') + '\n' : '';
  }
  function decodeZplFieldText(s, wholeBlock){
    if(/\^FH/i.test(wholeBlock)){
      s = s.replace(/_([0-9A-F]{2})/gi, (_,hh)=>String.fromCharCode(parseInt(hh,16)));
    }
    s = s.replace(/\&/g,'^');
    s = s.replace(/[|=\[\]]+/g,' ').replace(/\s{2,}/g,' ').trim();
    return s;
  }
  function extractFdTextFromZpl(zpl){
    const out=[]; const re=/\^FD([\s\S]*?)\^FS/gm; let m; while((m=re.exec(zpl))!==null){ out.push(decodeZplFieldText(m[1], zpl)); }
    return out.join('\n').trim();
  }
  function hasFd(zpl){ return /\^FD[\s\S]*?\^FS/i.test(zpl); }
  function hasRaster(zpl){ return /\^(XG|GF|DG|DGR)\b|~DG/i.test(zpl); }
  function detectLojaFromZpl(labelZpl){
    // tenta ^FDRemetente: NOME^FS ou linhas com "REMENTE"/"REMETENTE"
    let m = labelZpl.match(/\^FD\s*Remetente:?\s*([^\^]+)\^FS/i);
    if(m) return m[1].trim();
    // fallback: tenta qualquer ^FD com palavra-chave
    const all = extractFdTextFromZpl(labelZpl).split(/\r?\n/);
    for(const line of all){
      const mm = line.match(/Remetente:?\s*(.+)/i);
      if(mm) return mm[1].trim();
    }
    return null;
  }
  async function renderZplToPngBlob(zpl, dpmm=8, widthIn=4.0, heightIn=6.0, index=0){
    if(!zpl || !zpl.trim()){
      throw new Error('ZPL vazio n√£o pode ser renderizado');
    }
    const url = `https://api.labelary.com/v1/printers/${dpmm}dpmm/labels/${widthIn}x${heightIn}/${index}/`;
    const res = await fetch(url, {
      method:'POST',
      headers:{'Accept':'image/png'},
      body: zpl
    });
    if(!res.ok){
      const txt = await res.text().catch(()=> '');
      if(res.status === 404 && txt.includes('no labels')){
        throw new Error('Labelary falhou: ZPL n√£o gerou nenhuma etiqueta. Verifique se o bloco est√° completo.');
      }
      console.warn('ZPL preview:', (zpl||'').slice(0,500));
      throw new Error(`Labelary falhou (${res.status}) ${txt}`);
    }
    return await res.blob();
  }
  function blobToImage(blob){
    return new Promise(res=>{
      const url=URL.createObjectURL(blob);
      const img=new Image();
      img.onload=()=>{ URL.revokeObjectURL(url); res(img); };
      img.src=url;
    });
  }
  async function rotateImageBlob(img, deg){
    const canvas=document.createElement('canvas');
    const ctx=canvas.getContext('2d');
    if(deg===90 || deg===270){ canvas.width=img.height; canvas.height=img.width; }
    else { canvas.width=img.width; canvas.height=img.height; }
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(deg*Math.PI/180);
    ctx.drawImage(img, -img.width/2, -img.height/2);
    return new Promise(res=>canvas.toBlob(res));
  }
  async function binarizeBlob(blob, threshold=170){
    const img=await blobToImage(blob);
    const canvas=document.createElement('canvas');
    const ctx=canvas.getContext('2d');
    canvas.width=img.width; canvas.height=img.height;
    ctx.drawImage(img,0,0);
    const imgData=ctx.getImageData(0,0,canvas.width,canvas.height);
    const data=imgData.data;
    for(let i=0;i<data.length;i+=4){
      const avg=(data[i]+data[i+1]+data[i+2])/3;
      const val=avg < threshold ? 0 : 255;
      data[i]=data[i+1]=data[i+2]=val;
    }
    ctx.putImageData(imgData,0,0);
    return new Promise(res=>canvas.toBlob(res));
  }
  async function ocrBestRotation(pngBlob, worker, threshold=170){
    const img=await blobToImage(pngBlob);
    const rotations=[0,90,270];
    let best={text:'',conf:-1};
    for(const deg of rotations){
      const rotated=await rotateImageBlob(img,deg);
      const bin=await binarizeBlob(rotated,threshold);
      const { data } = await worker.recognize(bin);
      if(data.confidence>best.conf){ best={text:data.text, conf:data.confidence}; }
    }
    return best.text;
  }
  async function ocrChecklistBlock(zpl, prefix, widthIn, heightIn, worker){
    const png = await renderZplToPngBlob(prefix + zpl, 12, widthIn, heightIn);
    const txt = await ocrBestRotation(png, worker, 170);
    return { text: (txt||'').trim(), blob: png };
  }
  function parseItemsFromText(text){
    console.log('[parseItemsFromText] raw text:', text);
    const lines=(text||'').split(/\r?\n/).map(l=>l.replace(/[\[\]\|=]/g,' ').replace(/\s+/g,' ').trim()).filter(Boolean);
    const items=[];
    for(const line of lines){
      let m;
      let sku='', q=0;
      if(m=line.match(/\b(SKU|REF|COD)[:\s-]*([A-Z0-9\-_]{3,})\b.*?\b(Qtde|Qtd|Qty|x)[:\s-]*([0-9]{1,3})/i)){
        sku=m[2]; q=parseInt(m[4],10);
      } else if(m=line.match(/([A-Z0-9][A-Z0-9\-]{4,})\s{1,3}([0-9]{1,3})\b/)){
        sku=m[1]; q=parseInt(m[2],10);
      } else if(m=line.match(/([A-Za-z0-9\-_]{2,})\s*[xX*]\s*([0-9]{1,3})/)){
        sku=m[1]; q=parseInt(m[2],10);
      } else if(m=line.match(/([A-Za-z0-9\-_]{2,})[^0-9]{0,10}\b(Qtd|Qde|Qtde)[:\s-]*([0-9]{1,3})/i)){
        sku=m[1]; q=parseInt(m[3],10);
      }
      if(sku && Number.isInteger(q)){ items.push({sku:sku.toUpperCase(), quantidade:q}); }
    }
    const map=new Map(); items.forEach(it=>map.set(it.sku,(map.get(it.sku)||0)+it.quantidade));
    return Array.from(map, ([sku, quantidade])=>({sku, quantidade}));
  }

  // ===== Firestore helpers =====
  async function getNextLabelNumber(total){
    console.log('[getNextLabelNumber] total:', total);
    const ref = db.collection('uid').doc(currentUser.uid).collection('config').doc('contadores');
    return await db.runTransaction(async (tx)=>{
      const snap = await tx.get(ref);
      const cur = (snap.exists && (snap.data().zplLastNumber|0)) || 0;
      const start = cur + 1; const next = cur + (total|0);
      tx.set(ref, { zplLastNumber: next }, { merge:true });
      console.log('[getNextLabelNumber] current:', cur, 'start:', start, 'next:', next);
      return start;
    });
  }
  async function findUidByEmail(email){
    if(!email) return null;
    console.log('[findUidByEmail] email:', email);
    const q = await db.collection('uid').where('email','==',email).limit(1).get();
    if(!q.empty){
      const id = q.docs[0].id;
      console.log('[findUidByEmail] found uid:', id);
      return id;
    }
    console.warn('[findUidByEmail] no UID for email', email);
    return null;
  }
  async function resolveExpedicaoDestinatarios(emails, responsavelUid){
    const destinatarios = new Set();
    if(responsavelUid){
      destinatarios.add(responsavelUid);
    }
    const lista = Array.isArray(emails) ? emails : [];
    const buscas = lista
      .map(email => (email || '').trim())
      .filter(Boolean)
      .map(async email => {
        try{
          const uid = await findUidByEmail(email);
          if(uid){
            destinatarios.add(uid);
          }
        }catch(err){
          console.error('Erro ao buscar UID do gestor de expedi√ß√£o:', email, err);
        }
      });
    await Promise.all(buscas);
    return Array.from(destinatarios);
  }
  async function notifyGestorNovaEtiqueta({ nomeArquivo, totalEtiquetas, foraHorario, destinatariosEmails, responsavelUid }){
    if(!currentUser) return;
    try{
      const destinatarios = await resolveExpedicaoDestinatarios(destinatariosEmails, responsavelUid);
      if(!destinatarios.length) return;
      const payload = {
        tipo: 'nova-etiqueta',
        arquivoNome: nomeArquivo || '',
        foraHorario: Boolean(foraHorario),
        autorUid: currentUser.uid,
        autorEmail: currentUser.email || '',
        autorNome: currentUser.displayName || '',
        gestorUid: currentUser.uid,
        gestorEmail: currentUser.email || '',
        destinatarios,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      if(Number.isFinite(totalEtiquetas)){
        payload.totalEtiquetas = Number(totalEtiquetas);
      }
      await db.collection('expedicaoMensagens').add(payload);
    }catch(err){
      console.error('Erro ao notificar gestor de expedi√ß√£o:', err);
    }
  }
  async function savePrintedItems(items, meta){
    console.log('[savePrintedItems] items:', items, 'meta:', meta);
    const batch = db.batch();
    const userDoc = db.collection('uid').doc(currentUser.uid);
    const respDoc = meta.responsavelUid ? db.collection('uid').doc(meta.responsavelUid) : null;
    items.forEach(it=>{
      const data = {
        sku: it.sku,
        quantidade: it.quantidade,
        loja: meta.loja || '',
        userUid: currentUser.uid,
        userEmail: currentUser.email,
        data: firebase.firestore.FieldValue.serverTimestamp()
      };
      batch.set(userDoc.collection('etiquetasimpressas').doc(), data);
      if (respDoc) batch.set(respDoc.collection('etiquetasimpressas').doc(), data);
    });
    await batch.commit();
    console.log('[savePrintedItems] saved for current user');
  }

  async function savePdfRecord(url, storagePath, name, responsavelUid, foraHorario, meta = {}){
    console.log('[savePdfRecord] saving record', {name, url, storagePath, responsavelUid, foraHorario});
    const record = {
      name,
      url,
      path: storagePath,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    };
    if(foraHorario) record.foraHorario = true;
    await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add(record);
    if(responsavelUid){
      await db.collection('users').doc(responsavelUid).collection('etiquetaenvio').add(record);
    }
    console.log('[savePdfRecord] record saved');
    try{
      const destinatariosEmails = Array.isArray(meta.destinatariosEmails)
        ? meta.destinatariosEmails
        : (meta.gestorEmail ? [meta.gestorEmail] : []);
      await notifyGestorNovaEtiqueta({
        nomeArquivo: name,
        totalEtiquetas: meta.totalEtiquetas,
        foraHorario,
        destinatariosEmails,
        responsavelUid
      });
    }catch(err){
      console.error('Erro ao enviar notifica√ß√£o de nova etiqueta:', err);
    }
  }

  // ===== Handler principal =====
  $(el.btnProcessar).onclick = async ()=>{
    console.log('[btnProcessar] clicked');
    hideErr(); hideOk(); resetProgress();
    if(!currentUser){ showErr('Fa√ßa login para continuar.'); return; }
    console.log('[btnProcessar] user', currentUser.uid);
    const dentroHorario = isDentroHorario();
    const foraHorario = !dentroHorario;
    const file = $(el.zplFile).files?.[0]; if(!file){ showErr('Selecione um arquivo .zpl/.txt.'); return; }
    console.log('[btnProcessar] file selected', file.name);

    // gestores
    let gestores = ($(el.gestoresEmails).value||'').split(/[;,\s]+/).map(s=>s.trim()).filter(Boolean);
    let gestorEmail = gestores[0]||null;
    if(gestores.length>1){ gestorEmail = await escolherGestorEmail(gestores); }
    let responsavelUid = gestorEmail ? await findUidByEmail(gestorEmail) : null;
    console.log('[btnProcessar] gestor', gestorEmail, 'responsavelUid', responsavelUid);

    const startTs = Date.now();
    let timer = setInterval(()=> $(el.elapsed).textContent = fmtTime((Date.now()-startTs)/1000), 1000);

    try{
      $(el.btnProcessar).disabled = true; setProgress(2,'Lendo arquivo‚Ä¶');
      const zplText = await readFileAsText(file);
      console.log('[btnProcessar] file read bytes', zplText.length);
      const zplPrefix = buildPrefixWithDG(zplText);
        const blocks = splitZplBlocks(zplText);
        console.log('[btnProcessar] blocks found', blocks.length);
        if(blocks.length % 2 !== 0){ console.warn('[process] n√∫mero √≠mpar de blocos ‚Äî pode faltar checklist'); }
        if(blocks.length < 2){ throw new Error('Arquivo n√£o cont√©m blocos suficientes.'); }

        const totalLabels = Math.floor(blocks.length/2);
        console.log('[btnProcessar] total labels', totalLabels);
        const startNumber = await getNextLabelNumber(totalLabels);
        const name = `etiquetas-${Date.now()}.pdf`;
        console.log('[btnProcessar] startNumber', startNumber, 'pdf name', name);

      // PDF
      const pdfDoc = await PDFLib.PDFDocument.create();
      const dpmm = 8, widthIn=4.0, heightIn=6.0;

      // Cria doc Firestore para metadados e reserva Storage path
      const metaRef = await db.collection('pdfDocs').add({
        ownerUid: currentUser.uid,
        ownerEmail: currentUser.email,
        gestorEmail: gestorEmail||null,
        created: firebase.firestore.FieldValue.serverTimestamp(),
        total: totalLabels,
        name,
        foraHorario
      });
      const pdfPath = `pdfs/${currentUser.uid}/${metaRef.id}.pdf`;
      console.log('[btnProcessar] pdfPath', pdfPath);

        let completed = 0;
        const tasks = [];
        for(let i=0;i+1<blocks.length;i+=2){
          const idx = (i/2)+1;
          const labelZpl = blocks[i];
          const checklistZpl = blocks[i+1];
          tasks.push((async ()=>{
            const worker = await acquireWorker();
            try{
              const loja = detectLojaFromZpl(labelZpl);
              let checklistBlob, checklistText='';
              if(hasFd(checklistZpl)){
                checklistText = extractFdTextFromZpl(checklistZpl);
                checklistBlob = await renderZplToPngBlob(zplPrefix + checklistZpl, 12, widthIn, heightIn);
              } else if(hasRaster(checklistZpl)){
                ({ text: checklistText, blob: checklistBlob } = await ocrChecklistBlock(checklistZpl, zplPrefix, widthIn, heightIn, worker));
              } else {
                console.warn(`[checklist] bloco sem ^FD e sem gr√°fico conhecido; tentando OCR mesmo assim`);
                ({ text: checklistText, blob: checklistBlob } = await ocrChecklistBlock(checklistZpl, zplPrefix, widthIn, heightIn, worker));
              }
              saveAs(checklistBlob, `debug-checklist-${idx}.png`);
              const items = parseItemsFromText(checklistText);
              const labelBlob = await renderZplToPngBlob(zplPrefix + labelZpl, dpmm, widthIn, heightIn);
              return { idx, loja, checklistBlob, items, labelBlob };
            } finally {
              releaseWorker(worker);
            }
          })().then(res=>{
            completed++;
            setProgress((completed/totalLabels)*90, `Processando ${completed}/${totalLabels}‚Ä¶`);
            return res;
          }));
        }

        const pages = await Promise.all(tasks);
        pages.sort((a,b)=>a.idx-b.idx);

      let labelCounter = startNumber;
      for(const { loja, checklistBlob, items, labelBlob } of pages){
        const labelBytes = new Uint8Array(await labelBlob.arrayBuffer());
        const labelPng = await pdfDoc.embedPng(labelBytes);
        const pageLabel = pdfDoc.addPage([widthIn*72, (labelPng.height/labelPng.width)*widthIn*72]);
        pageLabel.drawImage(labelPng, { x:0, y:0, width: widthIn*72, height: (labelPng.height/labelPng.width)*widthIn*72 });

        const checklistBytes = new Uint8Array(await checklistBlob.arrayBuffer());
        const checklistPng = await pdfDoc.embedPng(checklistBytes);
        const pageChecklist = pdfDoc.addPage([widthIn*72, (checklistPng.height/checklistPng.width)*widthIn*72]);
        pageChecklist.drawImage(checklistPng, { x:0, y:0, width: widthIn*72, height: (checklistPng.height/checklistPng.width)*widthIn*72 });

        if(items.length === 0){
          console.info(`Sem itens; gerando PDF sem SKUs para a etiqueta ${labelCounter}`);
        } else {
          await savePrintedItems(items, { loja, labelNumber: labelCounter, storagePath: pdfPath, responsavelUid });
        }
        labelCounter++;
      }

      setProgress(96,'Finalizando PDF‚Ä¶');
      const pdfBytes = await pdfDoc.save();
      const pdfBlob = new Blob([pdfBytes], { type:'application/pdf' });

      const ref = storage.ref().child(pdfPath);
      await ref.put(pdfBlob);
      const url = await ref.getDownloadURL();
      console.log('[btnProcessar] PDF uploaded', url);
      await metaRef.update({ url, storagePath: pdfPath, finishedAt: firebase.firestore.FieldValue.serverTimestamp() });
      await savePdfRecord(url, pdfPath, name, responsavelUid, foraHorario, {
        totalEtiquetas: totalLabels,
        destinatariosEmails: gestorEmail ? [gestorEmail] : []
      });

      setProgress(100,'Conclu√≠do');
      showOk('PDF salvo com sucesso.');
      const a=document.createElement('a'); a.href=url; a.target='_blank'; a.rel='noopener'; a.click();
  }catch(e){ console.error(e); showErr(e.message||String(e)); }
  finally{
    clearInterval(timer);
    $(el.btnProcessar).disabled=false;
  }
  };
  </script>
  <script src="shared.js"></script>
  </div>
</body>
</html>

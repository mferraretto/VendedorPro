<!DOCTYPE html> 
<html lang="pt-BR"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Combinador de Etiqueta ZPL</title> 
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css?v=20240826">
    <link rel="stylesheet" href="css/components.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- A biblioteca pdf-lib é carregada aqui -->
    <script src="https://unpkg.com/pdf-lib@1.4.0"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
    <script type="module" src="firebase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head> 
<body class="bg-gray-50">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="main-content flex items-center justify-center min-h-screen p-4">

<div class="card-container w-full max-w-2xl flex flex-col gap-6">
    <div class="card bg-white p-8 rounded-xl shadow-lg border border-gray-200"> 
        <h1 class="text-2xl font-semibold text-gray-900 text-center mb-2">Combinador de ZPL</h1> 
        <p class="text-gray-600 text-center mb-6"> 
            Selecione um ficheiro .zpl ou .txt para extrair os dados do checklist e combiná-los na etiqueta de envio. 
        </p> 
        <div class="flex flex-col items-center gap-4">
            <input
                type="file"
                id="zplFile"
                accept=".zpl, .txt"
                class="block w-full max-w-sm text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100 cursor-pointer"
            >
            <input
                type="text"
                id="gestoresEmails"
                placeholder="E-mails do gestor de expedição (separados por vírgula)"
                class="block w-full max-w-sm text-sm text-gray-500 border border-gray-300 rounded p-2"
            >
            <button
                id="converterButton"
                class="px-6 py-3 bg-blue-800 text-white font-bold text-lg rounded-full
                        shadow-lg hover:bg-blue-700 transition-all duration-300 transform
                        hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Extrair e Gerar 
            </button> 
        </div> 

        <!-- Progress bar and status -->
        <div id="progress-container" class="mt-6 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-status" class="text-center text-sm text-gray-600 mt-2"></p>
        </div>
        
        <div id="error-message" class="text-red-500 font-bold text-center mt-4"></div> 
    </div> 

    <div class="card bg-white p-6 rounded-xl shadow-lg border border-gray-200" id="results-card" style="display:none;"> 
        <h2 class="text-xl font-semibold text-gray-900 text-center mb-4">Pré-visualização da Etiqueta</h2> 
        <div id="preview-image-container" class="flex justify-center mb-4 p-4 border border-gray-300 rounded-lg"> 
            <img id="preview-image" src="" alt="Pré-visualização da etiqueta" class="max-w-full h-auto"> 
        </div> 
        <div id="pdf-links" class="flex flex-col items-center gap-2">
            <!-- O link para o PDF será inserido aqui -->
        </div>
    </div>
</div>
</div>

<div id="gestorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
  <div class="bg-white w-full max-w-md p-4 rounded shadow-lg">
    <h2 class="text-lg font-semibold mb-2">Enviar arquivo para qual gestor?</h2>
    <select id="gestorSelect" class="form-control mb-4"></select>
    <div class="flex justify-end gap-2">
      <button id="gestorCancel" class="btn btn-secondary">Cancelar</button>
      <button id="gestorConfirm" class="btn btn-primary">Confirmar</button>
    </div>
  </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
        const db = firebase.firestore();
        const storage = firebase.storage();
        let currentUser = null;
        let responsavelExpedicaoUid = null;
        let responsavelExpedicaoEmail = null;
        let horariosEtiquetas = [];

        function escolherGestorEmail(emails) {
            return new Promise(resolve => {
                if (!emails || !emails.length) return resolve([]);
                if (emails.length === 1) return resolve([emails[0]]);

                const modal = document.getElementById('gestorModal');
                const select = document.getElementById('gestorSelect');
                const confirmBtn = document.getElementById('gestorConfirm');
                const cancelBtn = document.getElementById('gestorCancel');

                select.innerHTML = '';
                emails.forEach(email => {
                    const opt = document.createElement('option');
                    opt.value = email;
                    opt.textContent = email;
                    select.appendChild(opt);
                });

                function close(value) {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    modal.removeEventListener('click', onBackdrop);
                    resolve([value]);
                }

                function onConfirm() { close(select.value || emails[0]); }
                function onCancel() { close(emails[0]); }
                function onBackdrop(e) { if (e.target === modal) close(emails[0]); }

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
                modal.addEventListener('click', onBackdrop);

                modal.classList.remove('hidden');
            });
        }
        firebase.auth().onAuthStateChanged(async u => {
            currentUser = u;
            if (!u) return;
            try {
                const doc = await db.collection('uid').doc(u.uid).get();
                const data = doc.data() || {};
                const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
                document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
                const respEmail = Array.isArray(data.gestoresExpedicaoEmails)
                    ? data.gestoresExpedicaoEmails[0]
                    : data.responsavelExpedicaoEmail;
                if (respEmail) {
                    responsavelExpedicaoEmail = respEmail;
                    const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
                    if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
                    await carregarHorarios();
                }
            } catch (e) {
                console.error('Erro ao carregar gestor de expedição:', e);
            }
        });
        async function savePdf(blob, name) {
            if (!currentUser) return;
            const gestoresRaw = document.getElementById('gestoresEmails').value || '';
            const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
            const selecionado = await escolherGestorEmail(gestoresEmails);
            const docRef = await db.collection('pdfDocs').add({
                ownerUid: currentUser.uid,
                ownerEmail: currentUser.email,
                gestoresExpedicaoEmails: selecionado,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                name: name,
                foraHorario: foraDoHorario()
            });
            const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
            await fileRef.put(blob);
            const url = await fileRef.getDownloadURL();
            await docRef.update({ url: url, storagePath: fileRef.fullPath });
            const record = {
                name: name,
                url: url,
                path: fileRef.fullPath,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
            if (responsavelExpedicaoUid) {
                const respRecord = {
                    name: name,
                    url: url,
                    path: fileRef.fullPath,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
            }
        }

        async function savePrintedSkuQuantities(items) {
            if (!currentUser || !items || items.length === 0) return;
            const batch = db.batch();
            const userDoc = db.collection('uid').doc(currentUser.uid);
            const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
            items.forEach(item => {
                const data = {
                    sku: item.sku,
                    quantidade: item.quantidade,
                    loja: item.loja || '',
                    pedido: item.pedido || '',
                    userUid: currentUser.uid,
                    userEmail: currentUser.email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                batch.set(userDoc.collection('skuimpressos').doc(), data);
                if (respDoc) {
                    batch.set(respDoc.collection('skuimpressos').doc(), data);
                }
            });
            await batch.commit();
        }

        async function carregarHorarios() {
            if (!responsavelExpedicaoUid) return;
            try {
                const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
                const data = doc.data() || {};
                horariosEtiquetas = data.horariosEtiquetas || [];
            } catch (e) {
                console.error('Erro ao carregar horários:', e);
            }
        }

        function foraDoHorario() {
            if (!horariosEtiquetas.length) return false;
            const now = new Date();
            return !horariosEtiquetas.some(h => {
                if (!h.inicio || !h.fim) return false;
                const [ih, im] = h.inicio.split(':').map(Number);
                const [fh, fm] = h.fim.split(':').map(Number);
                const start = new Date(now);
                start.setHours(ih, im, 0, 0);
                const end = new Date(now);
                end.setHours(fh, fm, 0, 0);
                return now >= start && now <= end;
            });
        }

        const fileInput = document.getElementById('zplFile');
        const converterButton = document.getElementById('converterButton');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const errorDiv = document.getElementById('error-message');
        const resultsCard = document.getElementById('results-card');
        const pdfLinksDiv = document.getElementById('pdf-links');
        const previewImage = document.getElementById('preview-image');

        // Initial state of the user interface
        converterButton.disabled = true; 

        fileInput.addEventListener('change', () => { 
            converterButton.disabled = !fileInput.files.length; 
            errorDiv.textContent = ''; 
            pdfLinksDiv.innerHTML = ''; 
            resultsCard.style.display = 'none'; 
            previewImage.src = ''; 
        }); 

        converterButton.addEventListener('click', processZPL); 

        async function processZPL() { 
            const file = fileInput.files && fileInput.files.length > 0 ? fileInput.files.item(0) : null; 
            errorDiv.textContent = ''; 
            pdfLinksDiv.innerHTML = ''; 
            resultsCard.style.display = 'none'; 
            previewImage.src = ''; 

            if (!file) { 
                errorDiv.textContent = 'Por favor, selecione um ficheiro ZPL para processar.'; 
                return; 
            } 

            // Show progress bar and disable button
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressStatus.textContent = 'A preparar...';
            converterButton.disabled = true; 

            try { 
                const zplCode = await readFileAsync(file);
                // Captura genericamente blocos ^XA...^XZ para suportar ficheiros sem ~DGR.
                const blocks = zplCode.match(/\^XA[\s\S]*?\^XZ/g);

                if (!blocks || blocks.length < 2 || blocks.length % 2 !== 0) {
                    throw new Error('Não foram encontrados blocos ZPL suficientes para a etiqueta e o checklist, ou o número de blocos é ímpar.');
                }
                
                const dpmm = 8;
                const originalWidthIn = 4.0;
                const originalHeightIn = 5.2;
                const { PDFDocument } = PDFLib;
                const pdfDoc = await PDFDocument.create();
                const totalLabels = blocks.length / 2;

                // Recupera o próximo número de etiqueta a partir do Firestore
                let startLabelNumber = 1;
                try {
                    const counterDocRef = db.collection('uid').doc(currentUser.uid);
                    await db.runTransaction(async tx => {
                        const doc = await tx.get(counterDocRef);
                        const current = doc.exists && doc.data().zplLastNumber ? doc.data().zplLastNumber : 0;
                        startLabelNumber = current + 1;
                        tx.set(counterDocRef, { zplLastNumber: current + totalLabels }, { merge: true });
                    });
                } catch (e) {
                    console.error('Erro ao atualizar o contador de etiquetas:', e);
                }

                const allExtractedItems = [];
                let labelCounter = startLabelNumber;

                // Loop to process each pair of ZPL blocks
                for (let i = 0; i < blocks.length; i += 2) {
                    const currentLabelIndex = (i / 2) + 1;
                    progressStatus.textContent = `A processar etiqueta ${currentLabelIndex} de ${totalLabels}...`;
                    progressBar.style.width = `${(currentLabelIndex / totalLabels) * 100}%`;

                    const labelBlock = blocks[i];
                    const checklistBlock = blocks[i + 1];

                    // Extração da loja a partir da etiqueta
                    const loja = await getStoreFromLabel(labelBlock, dpmm, originalWidthIn, originalHeightIn);

                    // 1. Extrai dados do checklist
                    const extractedData = await extractDataFromChecklist(checklistBlock, dpmm, originalWidthIn, originalHeightIn);
                    if (!extractedData.length) {
                        console.warn(`Checklist sem SKU encontrado para a etiqueta ${currentLabelIndex}.`);
                    }
                    if (loja) {
                        extractedData.forEach(item => item.loja = loja);
                    }
                    // keep track of all items for posterior saving
                    allExtractedItems.push(...extractedData);

                    // 3. Generate ZPL for the new combined label
                    const combinedZPL = generateCombinedZPL(labelBlock, extractedData, labelCounter);
                    
                    // 4. Calculate new total page height
                    const newTotalHeightInches = calculateNewTotalHeight(originalHeightIn, extractedData.length, dpmm); 
                    
                    // 5. Get PNG of the combined label from Labelary API
                    const combinedPngBlob = await generateImageFromZpl(combinedZPL, dpmm, originalWidthIn, newTotalHeightInches); 
                    const processedPngBlob = await applyBlackContrastFromBlob(combinedPngBlob); 

                    // 6. Create PDF from the processed PNG
                    const pngBytes = await processedPngBlob.arrayBuffer(); 
                    const pngImage = await pdfDoc.embedPng(pngBytes); 
                    const page = pdfDoc.addPage([originalWidthIn * 72, newTotalHeightInches * 72]); 
                    page.drawImage(pngImage, { x: 0, y: 0, width: originalWidthIn * 72, height: newTotalHeightInches * 72 });
                    labelCounter++;
                }

                // 7. Save the final PDF
                const pdfBytes = await pdfDoc.save();
                const pdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                const pdfUrl = URL.createObjectURL(pdfBlob);

                const fileName = `etiquetas-combinadas-${Date.now()}.pdf`;

                // Add the download link
                const link = document.createElement('a');
                link.href = pdfUrl;
                link.download = fileName;
                link.textContent = 'Transferir PDF Combinado';
                link.classList.add('px-6', 'py-3', 'bg-green-600', 'text-white', 'font-bold', 'rounded-full', 'shadow-lg', 'hover:bg-green-500', 'transition-all', 'duration-300');
                pdfLinksDiv.appendChild(link);

                await savePdf(pdfBlob, fileName);
                await savePrintedSkuQuantities(allExtractedItems);
                
                // 8. Display the preview of the first label
                const firstChecklistData = await extractDataFromChecklist(blocks[1], dpmm, originalWidthIn, originalHeightIn);
                const firstLabelImageBlob = await generateImageFromZpl(
                    generateCombinedZPL(blocks[0], firstChecklistData, startLabelNumber),
                    dpmm,
                    originalWidthIn,
                    calculateNewTotalHeight(originalHeightIn, firstChecklistData.length, dpmm)
                );
                const firstLabelImageUrl = URL.createObjectURL(firstLabelImageBlob);
                previewImage.src = firstLabelImageUrl;
                previewImage.onload = () => { if (firstLabelImageUrl) URL.revokeObjectURL(firstLabelImageUrl); };
                resultsCard.style.display = 'block';

            } catch (error) { 
                errorDiv.textContent = `Ocorreu um erro durante o processamento: ${error.message}`; 
                console.error('Erro na conversão:', error); 
            } finally { 
                // Hide progress bar and re-enable button
                progressContainer.classList.add('hidden');
                converterButton.disabled = false; 
                progressBar.style.width = '0%';
            } 
        } 
        
function calculateNewTotalHeight(originalHeightIn, numberOfItems, dpmm) {
            const fontH = 22;      // mesma fonte usada no desenho
            const lineStep = 30;   // respiro entre blocos
            const yPadding = 250;  // margem extra inferior (em dots)

            // Cada item ocupa: SKU (fontH) + Qtd (fontH) + pequeno gap (5) + respiro (lineStep)
            const perItemDots = (fontH + 5 + fontH) + lineStep;

            const addedContentHeightDots = (numberOfItems * perItemDots) + yPadding;

            const dotsPerInch = dpmm * 25.4; // 8 dpmm => ~203.2 dpi
            const addedContentHeightInches = addedContentHeightDots / dotsPerInch;

            return originalHeightIn + addedContentHeightInches;
        }

async function generateImageFromZpl(zplCode, dpmm, width, height) {
            const apiUrl = `https://api.labelary.com/v1/printers/${dpmm}dpmm/labels/${width}x${height}/0/`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Accept': 'image/png',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: zplCode
            });
            if (!response.ok) { 
                const errorText = await response.text(); 
                throw new Error(`Erro na API Labelary (imagem): ${response.status} ${response.statusText} - ${errorText}`); 
            } 

              return response.blob();
        }

        function extractStoreFromZpl(zplCode) {
            const remRegex = /Remetente\^FS[\s\S]*?\^FD([^\^]+)\^FS/i;
            const match = zplCode.match(remRegex);
            if (match) {
                return match[1].trim();
            }
            const sameLine = /Remetente:?\s*([^\^]+)\^FS/i;
            const matchSame = zplCode.match(sameLine);
            return matchSame ? matchSame[1].trim() : null;
        }

        async function getStoreFromLabel(zplCode, dpmm, width, height) {
            try {
                // 1) tenta direto do ZPL
                const lojaFromZpl = extractStoreFromZpl(zplCode);
                if (lojaFromZpl) return lojaFromZpl;

                // 2) fallback OCR
                const labelBlob = await generateImageFromZpl(zplCode, dpmm, width, height);
                const text = await ocrImageToText(labelBlob);
                const loja = parseLojaFromText(text);
                return loja || null;
            } catch (e) {
                console.error('Erro ao obter loja da etiqueta:', e);
                return null;
            }
        }

        
        async function ocrImageToText(imageBlob) {
            const { data } = await Tesseract.recognize(imageBlob, 'por+eng', {
                tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._:/()°%+ ,x×',
            });
            return (data && data.text ? data.text : '').replace(/\r/g, '');
        }

        function parseLojaFromText(text) {
            const m = text.match(/remetente[:\s-]*([^\n]+)/i);
            return m ? m[1].trim() : null;
        }

        function extractItemsFromChecklistZpl(zpl) {
            const items = [];
            const fdTexts = Array.from(zpl.matchAll(/\^FD([^\^]+)\^FS/g)).map(m => m[1]);

            let current = {};
            let currentPedido = null;
            for (const raw of fdTexts) {
                const line = raw.replace(/\s+/g, ' ').trim();

                const mPedido = line.match(/\b(Pedido|Order)[:\s-]*([0-9]+)/i);
                if (mPedido) {
                    currentPedido = mPedido[2];
                    continue;
                }

                const mSku = line.match(/\bSKU[:\s-]*([A-Z0-9._\-\/]+)\b/i);
                if (mSku) {
                    if (current.sku) {
                        if (typeof current.quantidade !== 'number') current.quantidade = 1;
                        if (currentPedido) current.pedido = currentPedido;
                        items.push(current);
                        current = {};
                    }
                    current.sku = mSku[1];
                    continue;
                }

                const mQtd = line.match(/\b(Qtd|Qtde|Quantidade)[:\s-]*([0-9]{1,4})\b/i);
                if (mQtd) {
                    current.quantidade = Number(mQtd[2]);
                    continue;
                }

                const mInline = line.match(/SKU[:\s-]*([A-Z0-9._\-\/]+).*?(x|×)?\s*([0-9]{1,4})/i);
                if (mInline) {
                    const item = { sku: mInline[1], quantidade: Number(mInline[3]) || 1 };
                    if (currentPedido) item.pedido = currentPedido;
                    items.push(item);
                    current = {};
                    continue;
                }
            }
            if (current.sku) {
                if (typeof current.quantidade !== 'number') current.quantidade = 1;
                if (currentPedido) current.pedido = currentPedido;
                items.push(current);
            }
            return items;
        }

        function parseItemsFromText(text) {
            const items = [];
            const lines = text.split('\n').map(l => l.replace(/\s+/g, ' ').trim()).filter(Boolean);

            let current = {};
            let currentPedido = null;
            for (const line of lines) {
                const mPedido = line.match(/\b(Pedido|Order)[:\s-]*([0-9]+)/i);
                if (mPedido) {
                    currentPedido = mPedido[2];
                    continue;
                }

                const mSku = line.match(/\bSKU[:\s-]*([A-Z0-9._\-\/]+)\b/i);
                if (mSku) {
                    if (current.sku) {
                        if (typeof current.quantidade !== 'number') current.quantidade = 1;
                        if (currentPedido) current.pedido = currentPedido;
                        items.push(current);
                        current = {};
                    }
                    current.sku = mSku[1];
                    continue;
                }
                const mQtd = line.match(/\b(Qtd|Qtde|Quantidade)[:\s-]*([0-9]{1,4})\b/i);
                if (mQtd) {
                    current.quantidade = Number(mQtd[2]);
                    continue;
                }
                const mInline = line.match(/SKU[:\s-]*([A-Z0-9._\-\/]+).*?(x|×)?\s*([0-9]{1,4})/i);
                if (mInline) {
                    const item = { sku: mInline[1], quantidade: Number(mInline[3]) || 1 };
                    if (currentPedido) item.pedido = currentPedido;
                    items.push(item);
                    current = {};
                    continue;
                }
            }
            if (current.sku) {
                if (typeof current.quantidade !== 'number') current.quantidade = 1;
                if (currentPedido) current.pedido = currentPedido;
                items.push(current);
            }
            return items;
        }

async function extractDataFromChecklist(checklistZpl, dpmm, widthIn, heightIn) {
            const fromZpl = extractItemsFromChecklistZpl(checklistZpl);
            if (fromZpl.length) return fromZpl;

            const checklistBlob = await generateImageFromZpl(checklistZpl, dpmm, widthIn, heightIn);
            const text = await ocrImageToText(checklistBlob);
            return parseItemsFromText(text);
        }

        function generateCombinedZPL(labelBlock, data, labelNumber) {
            let originalContent = labelBlock.replace(/\^XA|\^XZ/g, '');
   originalContent = originalContent.replace(/\^A0N,20,20/g, '^ABN,22,22');

            const dpmm = 8;
            const originalWidthIn = 4.0;
            const originalHeightIn = 5.2;
            const dotsPerInch = dpmm * 25.4;
            const originalHeightDots = Math.round(originalHeightIn * dotsPerInch);

            const fontH = 22;
            const fontW = 22;
            const lineStep = 30;

            // 👉 começa logo após o final da etiqueta original (+ um pequeno respiro)
            const newContentStartX = 50;
            const newContentStartY = originalHeightDots + 30;

            let newContentZPL = '';
            if (data && data.length > 0) {
                // bloco por item = 2 linhas (SKU e Qtd) + respiro
                const perItemStep = (fontH + 5 + fontH) + lineStep;

                data.forEach((item, index) => {
                    const y = newContentStartY + (index * perItemStep);
                    const skuText = `^FO${newContentStartX},${y}^ABN,${fontH},${fontW}^FD SKU: ${item.sku} ^FS`;
                    const qtdText = `^FO${newContentStartX},${y + fontH + 5}^ABN,${fontH},${fontW}^FD Qtd: ${item.quantidade} ^FS`;
                    newContentZPL += `${skuText}${qtdText}`;
                });
            }

            // Altura total recalculada com a função corrigida
            const totalPageHeightInches = calculateNewTotalHeight(originalHeightIn, data.length, dpmm);
            const totalPageHeightDots = Math.round(totalPageHeightInches * dotsPerInch);

            // Número da etiqueta: deixe com margem do rodapé
            const numberY = totalPageHeightDots - (fontH * 2 + 40);
            const numberZpl = `^FO50,${numberY}^ABN,22,22^FD${labelNumber}^FS`;

            return `^XA^LL${totalPageHeightDots}^LH0,0${originalContent}${newContentZPL}${numberZpl}^XZ`;
        }

        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function applyBlackContrastFromBlob(imageBlob, { contrast = 40, gamma = 0.9, threshold = 200 } = {}) { 
            return new Promise((resolve, reject) => { 
                const imgElement = new Image(); 
                imgElement.onload = () => { 
                    const canvas = document.createElement('canvas'); 
                    canvas.width = imgElement.naturalWidth; 
                    canvas.height = imgElement.naturalHeight; 
                    const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
                    ctx.drawImage(imgElement, 0, 0); 

                    const img = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                    const data = img.data; 

                    const factor = (359 * (contrast + 255)) / (255 * (259 - contrast)); 

                    for (let i = 0; i < data.length; i += 4) { 
                        const r = data[i], g = data[i + 1], b = data[i + 2]; 
                        let y = 0.2126 * r + 0.7152 * g + 0.0722 * b; 

                        if (y < threshold) { 
                            let v = factor * (y - 128) + 128; 
                            v = 255 * Math.pow(v / 255, gamma); 
                            if (v > y) v = y; 
                            if (v < 0) v = 0; 
                            if (v > 255) v = 255; 

                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } else { 
                            const v = y > 255 ? 255 : y; 
                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } 
                    } 
                    ctx.putImageData(img, 0, 0); 
                    canvas.toBlob(resolve, 'image/png', 1); 
                    if (imgElement.src) URL.revokeObjectURL(imgElement.src); 
                }; 
                imgElement.onerror = reject; 
                imgElement.src = URL.createObjectURL(imageBlob); 
            }); 
        } 
    }); 
</script>
<script src="shared.js"></script>

</body>
</html>

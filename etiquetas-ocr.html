<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Etiquetas PDF</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css?v=20240826">
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
  <script src="expedicao-notifier.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <style>
    .progress-bar-bg {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      border-radius: 9999px;
      height: 1.5rem;
      overflow: hidden;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
    }
    .progress-bar-fill {
      background: linear-gradient(90deg, #06B6D4 0%, #3B82F6 100%);
      height: 100%;
      border-radius: 9999px 0 0 9999px;
      transition: width 0.3s cubic-bezier(.4,0,.2,1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 600;
      font-size: 0.875rem;
      background-size: 200% 100%;
      animation: progress-animation 2s linear infinite;
    }
    .progress-bar-fill.completed {
      background: linear-gradient(90deg, #16A34A 0%, #22C55E 100%);
      animation: none;
    }
    .progress-bar-fill.failed {
      background: linear-gradient(90deg, #DC2626 0%, #EF4444 100%);
      animation: none;
    }
    @keyframes progress-animation {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }
    #timerText {
      font-size: 0.875rem;
      color: #374151;
      font-weight: 500;
    }
    #status {
      min-height: 2rem;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen">
  <div class="app-container">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="max-w-xl w-full mx-auto p-4">
    <h1 class="text-4xl font-bold text-center mb-6 flex items-center justify-center gap-2">
      <i class="fa-solid fa-barcode"></i>
      ETIQUETAS PDF
    </h1>

    <div class="mb-4">
      <p class="text-sm font-medium text-gray-700 mb-1">Seus Gestores</p>
      <input type="text" id="gestoresEmails" placeholder="E-mails do gestor de expedição (separados por vírgula)" class="w-full border border-gray-300 rounded-lg p-2" />
    </div>

    <div class="mb-6">
      <label for="pdfInput" class="block cursor-pointer">
        <div class="w-full p-6 border-2 border-dashed border-gray-300 rounded-lg text-center bg-white hover:bg-gray-50">
          <i class="fa-solid fa-cloud-arrow-up text-3xl text-gray-400 mb-2"></i>
          <p class="text-gray-600">Arrastar e soltar ou clicar para fazer upload</p>
        </div>
      </label>
      <input type="file" id="pdfInput" accept="application/pdf" class="hidden" />
    </div>

    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500 mb-4" onclick="processar()">
      Etiquetas Shopee + lista empacotamento
    </button>
    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500" onclick="processarMercadoLivre()">
      Etiquetas Mercado Livre
    </button>

    <div class="status mt-4 text-blue-700 font-medium" id="status"></div>
    <canvas id="pdfCanvas" class="mt-8 mx-auto border rounded-lg shadow" style="display:none;max-width:100%;box-shadow:0 2px 16px rgba(0,0,0,0.04);"></canvas>
    <div class="flex justify-center mt-8">
      <span class="text-xs text-gray-500">Desenvolvido por Matheus Ferraretto &nbsp;·&nbsp; <i class="fa-solid fa-robot"></i></span>
    </div>
  </div>

  <div id="processingModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-40 px-4">
    <div id="processingModalCard" class="w-full max-w-lg rounded-xl shadow-xl p-6 bg-white border-t-4 border-blue-500 space-y-5 transition-colors duration-300">
      <div class="flex items-start gap-3">
        <i id="processingIcon" class="fa-solid fa-gear fa-spin text-blue-500 text-2xl mt-1"></i>
        <div>
          <h2 id="processingTitle" class="text-xl font-semibold text-gray-800">Processando etiquetas...</h2>
          <p id="processingSubtitle" class="text-sm text-gray-600">Por favor, não feche a página até concluirmos o processamento.</p>
        </div>
      </div>
      <div>
        <div class="progress-bar-bg" id="progressBar" style="display:none;">
          <div class="progress-bar-fill" id="progressFill" style="width:0%;">
            <span id="progressText" class="w-full text-center"></span>
          </div>
        </div>
        <div id="timerText" class="text-center text-sm text-gray-700 mt-3"></div>
      </div>
      <div class="text-xs text-yellow-700 bg-yellow-100 border border-yellow-200 rounded-md px-3 py-2 flex items-start gap-2">
        <i class="fa-solid fa-triangle-exclamation mt-0.5"></i>
        <span>Não feche a página enquanto as etiquetas são processadas e enviadas.</span>
      </div>
      <button id="processingClose" type="button" class="w-full hidden py-2.5 rounded-lg font-medium text-white bg-green-600 hover:bg-green-700 transition" aria-hidden="true">Fechar</button>
    </div>
  </div>

  <div id="gestorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
    <div class="bg-white w-full max-w-md p-4 rounded shadow-lg">
      <h2 class="text-lg font-semibold mb-2">Enviar arquivo para qual gestor?</h2>
      <select id="gestorSelect" class="form-control mb-4"></select>
      <div class="flex justify-end gap-2">
        <button id="gestorCancel" class="btn btn-secondary">Cancelar</button>
        <button id="gestorConfirm" class="btn btn-primary">Confirmar</button>
      </div>
    </div>
  </div>

      <script type="module">
    import { firebaseConfig, storageBucketUrl } from './firebase-config.js';

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

 if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const storage = firebase.storage(storageBucketUrl);
    let currentUser = null;
    let responsavelExpedicaoUid = null;
    let horariosEtiquetas = [];
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const timerText = document.getElementById('timerText');
    const processingModal = document.getElementById('processingModal');
    const processingModalCard = document.getElementById('processingModalCard');
    const processingTitle = document.getElementById('processingTitle');
    const processingSubtitle = document.getElementById('processingSubtitle');
    const processingIcon = document.getElementById('processingIcon');
    const processingClose = document.getElementById('processingClose');

    processingModalCard.dataset.status = 'idle';

    function setProcessingModalTheme(state) {
      processingModalCard.classList.remove('bg-white', 'border-blue-500', 'bg-green-50', 'border-green-500', 'bg-red-50', 'border-red-500');
      processingTitle.classList.remove('text-gray-800', 'text-green-700', 'text-red-700');
      processingSubtitle.classList.remove('text-gray-600', 'text-green-700', 'text-red-700');
      timerText.classList.remove('text-gray-700', 'text-green-700', 'text-red-700');

      if (state === 'success') {
        processingModalCard.classList.add('bg-green-50', 'border-green-500');
        processingTitle.classList.add('text-green-700');
        processingSubtitle.classList.add('text-green-700');
        timerText.classList.add('text-green-700');
      } else if (state === 'error') {
        processingModalCard.classList.add('bg-red-50', 'border-red-500');
        processingTitle.classList.add('text-red-700');
        processingSubtitle.classList.add('text-red-700');
        timerText.classList.add('text-red-700');
      } else {
        processingModalCard.classList.add('bg-white', 'border-blue-500');
        processingTitle.classList.add('text-gray-800');
        processingSubtitle.classList.add('text-gray-600');
        timerText.classList.add('text-gray-700');
      }
    }

    function openProcessingModal() {
      setProcessingModalTheme('processing');
      processingModal.classList.remove('hidden');
      processingModal.classList.add('flex');
      document.body.classList.add('overflow-hidden');
      processingModalCard.dataset.status = 'processing';
      processingIcon.className = 'fa-solid fa-gear fa-spin text-blue-500 text-2xl mt-1';
      processingTitle.textContent = 'Processando etiquetas...';
      processingSubtitle.textContent = 'Por favor, não feche a página até concluirmos o processamento.';
      progressBar.style.display = 'block';
      progressFill.style.width = '0%';
      progressFill.classList.remove('completed', 'failed');
      progressText.textContent = '';
      timerText.textContent = '';
      processingClose.classList.add('hidden');
      processingClose.setAttribute('aria-hidden', 'true');
      processingClose.disabled = true;
    }

    function completeProcessingModal(totalSeconds) {
      setProcessingModalTheme('success');
      processingModalCard.dataset.status = 'completed';
      processingIcon.className = 'fa-solid fa-circle-check text-green-500 text-2xl mt-1';
      processingTitle.textContent = 'Tudo pronto!';
      processingSubtitle.textContent = 'Arquivo final salvo com sucesso. Agora você já pode fechar esta janela.';
      progressFill.classList.add('completed');
      progressFill.classList.remove('failed');
      progressFill.style.width = '100%';
      progressText.textContent = 'Processamento finalizado (100%)';
      if (Number.isFinite(totalSeconds)) {
        timerText.textContent = `Tempo total: ${formatTime(Math.max(0, Math.floor(totalSeconds)))}`;
      }
      processingClose.classList.remove('hidden');
      processingClose.removeAttribute('aria-hidden');
      processingClose.disabled = false;
    }

    function failProcessingModal(message) {
      setProcessingModalTheme('error');
      processingModalCard.dataset.status = 'failed';
      processingIcon.className = 'fa-solid fa-circle-exclamation text-red-500 text-2xl mt-1';
      processingTitle.textContent = 'Algo deu errado';
      processingSubtitle.textContent = message || 'Não foi possível concluir o processamento. Tente novamente.';
      progressFill.classList.add('failed');
      progressFill.classList.remove('completed');
      processingClose.classList.remove('hidden');
      processingClose.removeAttribute('aria-hidden');
      processingClose.disabled = false;
    }

    function hideProcessingModal() {
      processingModal.classList.add('hidden');
      processingModal.classList.remove('flex');
      document.body.classList.remove('overflow-hidden');
      progressBar.style.display = 'none';
      processingModalCard.dataset.status = 'idle';
    }

    if (processingClose) {
      processingClose.addEventListener('click', () => {
        if (processingModalCard.dataset.status !== 'processing') {
          hideProcessingModal();
        }
      });
    }

    function escolherGestorEmail(emails) {
      return new Promise(resolve => {
        if (!emails || !emails.length) return resolve([]);
        if (emails.length === 1) return resolve([emails[0]]);

        const modal = document.getElementById('gestorModal');
        const select = document.getElementById('gestorSelect');
        const confirmBtn = document.getElementById('gestorConfirm');
        const cancelBtn = document.getElementById('gestorCancel');

        select.innerHTML = '';
        emails.forEach(email => {
          const opt = document.createElement('option');
          opt.value = email;
          opt.textContent = email;
          select.appendChild(opt);
        });

        function close(value) {
          modal.classList.add('hidden');
          confirmBtn.removeEventListener('click', onConfirm);
          cancelBtn.removeEventListener('click', onCancel);
          modal.removeEventListener('click', onBackdrop);
          resolve([value]);
        }

        function onConfirm() { close(select.value || emails[0]); }
        function onCancel() { close(emails[0]); }
        function onBackdrop(e) { if (e.target === modal) close(emails[0]); }

        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        modal.addEventListener('click', onBackdrop);

        modal.classList.remove('hidden');
      });
    }
firebase.auth().onAuthStateChanged(async u => {
      currentUser = u;
      if (!u) return;
      try {
        const doc = await db.collection('uid').doc(u.uid).get();
        const data = doc.data() || {};
        const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
        document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
        const respEmail = Array.isArray(data.gestoresExpedicaoEmails) ? data.gestoresExpedicaoEmails[0] : data.responsavelExpedicaoEmail;
        if (respEmail) {
          const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
          if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
          await carregarHorarios();
        }
      } catch (err) {
        console.error('Erro ao carregar gestor de expedição:', err);
      }
    });
    
    function showMessage(text) {
      const messageBox = document.getElementById("messageBox");
      const messageText = document.getElementById("messageText");
      messageText.textContent = text;
      messageBox.style.display = "block";
    }

    async function carregarHorarios() {
      if (!responsavelExpedicaoUid) return;
      try {
        const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
        const data = doc.data() || {};
        horariosEtiquetas = data.horariosEtiquetas || [];
      } catch (e) {
        console.error('Erro ao carregar horários:', e);
      }
    }

    function foraDoHorario() {
      if (!horariosEtiquetas.length) return false;
      const now = new Date();
      return !horariosEtiquetas.some(h => {
        if (!h.inicio || !h.fim) return false;
        const [ih, im] = h.inicio.split(':').map(Number);
        const [fh, fm] = h.fim.split(':').map(Number);
        const start = new Date(now);
        start.setHours(ih, im, 0, 0);
        const end = new Date(now);
        end.setHours(fh, fm, 0, 0);
        return now >= start && now <= end;
      });
    }

    async function extractSkuQuantitiesFromCanvas(canvas, info) {
      const ctxInfo = info || {};
      console.groupCollapsed('[OCR] Iniciando reconhecimento', ctxInfo);
      console.time('[OCR] tempo');
      const { data } = await Tesseract.recognize(canvas, 'por+eng');
      const text = data?.text || '';
      console.timeEnd('[OCR] tempo');
      console.log('[OCR] Dimensões canvas', { width: canvas.width, height: canvas.height });
      console.log('[OCR] Texto bruto');
      console.log(text);

      const items = [];
      // 1) Padrão principal: SKU ... (QTD|QUANTIDADE|QTY) ... número
      //    Permite + no SKU (ex.: T6+P4)
      const regex = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+).*?(?:QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/gis;
      let match;
      while ((match = regex.exec(text)) !== null) {
        items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
      }

      // 2) Padrão alternativo: SKU ... x 2
      if (items.length === 0) {
        const alt = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)\s*[xX*]\s*(\d{1,3})/gis;
        while ((match = alt.exec(text)) !== null) {
          items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
        }
      }

      // 3) Heurística linha-a-linha (SKU na linha N, quantidade na N+1)
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        console.log('[OCR] Linhas normalizadas', lines);
        for (let i = 0; i < lines.length; i++) {
          const skuMatch = lines[i].match(/SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)/i);
          if (skuMatch) {
            const next = (lines[i + 1] || '') + ' ' + (lines[i + 2] || '');
            const qtdMatch = next.match(/(QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/i) || next.match(/[xX*]\s*(\d{1,3})/);
            const qtdVal = qtdMatch ? parseInt(qtdMatch[qtdMatch.length - 1], 10) || 0 : 0;
            items.push({ sku: (skuMatch[1]||'').trim(), quantidade: qtdVal });
          }
        }
      }

      // 4) Heurística por linha com quantidade no fim
      //    Estruturas vistas no OCR: "1 Artigo ... T6+P4 CILINDROS + ARCO 2" ou "1 Trio de Boleiras TR15 1"
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        for (const line of lines) {
          const mQty = line.match(/(.+?)\s+(\d{1,3})\s*$/);
          if (!mQty) continue;
          const body = mQty[1];
          const qty = parseInt(mQty[2], 10) || 0;

          const rawTokens = body.split(/\s+/);
          // vasculha da direita p/ esquerda
          let candidate = '';
          for (let ti = rawTokens.length - 1; ti >= 0; ti--) {
            let tok = rawTokens[ti];
            // junta sinais adjacentes separados (por ex. '+' isolado)
            if ((tok === '+' || tok === '-' || tok === '/') && ti > 0) {
              rawTokens[ti - 1] = rawTokens[ti - 1] + tok;
              continue;
            }
            const clean = tok.replace(/[^A-Za-z0-9+_\-\/\.]/g, '');
            const hasDigit = /\d/.test(clean);
            const hasSpecial = /[+_\-\/\.]/.test(clean);
            if (clean.length >= 2 && (hasDigit || hasSpecial)) {
              candidate = clean;
              break;
            }
          }
          // fallback: última palavra relevante antes da quantidade
          if (!candidate) {
            const lastWord = body.split(/\s+/).pop() || '';
            const clean = lastWord.replace(/[^A-Za-z0-9]/g, '');
            if (clean.length >= 3) candidate = clean.toUpperCase();
          }

          if (candidate) {
            console.log('[OCR] Heurística (linha com quantidade) encontrou', { line, candidate, qty });
            items.push({ sku: candidate, quantidade: qty });
          }
        }
      }

      // ===== Construção do rodapé (4 linhas) com base no CHECKLIST =====
      // Estratégia: pegar as 4 primeiras linhas originais a partir da linha que começa com "1"
      const rawLines = text.split(/\n/).map(l => l.trim());
      const cleaned = rawLines
        .filter(l => l)
        .filter(l => !/^=+/.test(l))
        .filter(l => !/\b(Produto|SKU|Variac[aã]o|Quantidade)\b/i.test(l));

      const footerLines = [];
      let footerOneLine = '';
      const idx1 = cleaned.findIndex(l => /^\s*1\b/.test(l));
      if (idx1 >= 0) {
        // Linha da contagem 1: remove o "1" do início e mantém o restante intacto (inclusive quantidade ao final)
        const firstLine = cleaned[idx1].replace(/^\s*1\s*/, '').trim();
        footerLines.push(firstLine);
        for (let k = idx1 + 1; k < cleaned.length && footerLines.length < 4; k++) {
          // Mantém as linhas seguintes exatamente como o OCR retornou
          footerLines.push(cleaned[k]);
        }
      }
      while (footerLines.length < 4) footerLines.push('');

      // ===== Segmentação por COLUNAS (Produto | SKU | Variação | Quantidade) =====
      try {
        const words = Array.isArray(data?.words) ? data.words : [];
        const W = canvas.width, H = canvas.height;
        function norm(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
        const headerZoneY = H * 0.45; // cabeçalho costuma ficar no topo da área
        const headers = { produto: null, sku: null, variacao: null, quantidade: null };
        for (const w of words) {
          const t = norm(w.text || w.symbol || '');
          const y0 = w.bbox?.y0 ?? w.bbox?.y ?? 0;
          if (y0 > headerZoneY) continue;
          if (!headers.produto && t === 'produto') headers.produto = w;
          if (!headers.sku && t === 'sku') headers.sku = w;
          if (!headers.variacao && (t === 'variacao' || t === 'variacao:')) headers.variacao = w;
          if (!headers.quantidade && (t === 'quantidade' || t === 'quantidade:')) headers.quantidade = w;
        }
        // Limites em X das colunas
        const xPos = [];
        if (headers.produto?.bbox?.x0 != null) xPos.push({ key: 'produto', x: headers.produto.bbox.x0 });
        if (headers.sku?.bbox?.x0 != null) xPos.push({ key: 'sku', x: headers.sku.bbox.x0 });
        if (headers.variacao?.bbox?.x0 != null) xPos.push({ key: 'variacao', x: headers.variacao.bbox.x0 });
        if (headers.quantidade?.bbox?.x0 != null) xPos.push({ key: 'quantidade', x: headers.quantidade.bbox.x0 });
        xPos.sort((a,b)=>a.x-b.x);

        let bounds = [];
        if (xPos.length >= 3) {
          for (let i=0;i<xPos.length;i++){
            const left = xPos[i].x - 40; // margem
            const right = (xPos[i+1]?.x ?? (W-10)) - 10;
            bounds.push({ key: xPos[i].key, left: Math.max(0,left), right: Math.min(W,right) });
          }
        } else {
          // fallback: frações fixas
          bounds = [
            { key: 'produto', left: Math.round(W*0.08), right: Math.round(W*0.55) },
            { key: 'sku', left: Math.round(W*0.56), right: Math.round(W*0.66) },
            { key: 'variacao', left: Math.round(W*0.66), right: Math.round(W*0.83) },
            { key: 'quantidade', left: Math.round(W*0.83), right: Math.round(W*0.97) },
          ];
        }

        const headerMaxY = Math.max(
          headers.produto?.bbox?.y1 ?? 0,
          headers.sku?.bbox?.y1 ?? 0,
          headers.variacao?.bbox?.y1 ?? 0,
          headers.quantidade?.bbox?.y1 ?? 0,
          H*0.18
        );
        const rowStartY = headerMaxY + 10;
        const band = H * 0.08; // faixa para capturar a primeira linha após o cabeçalho

        const colFirst = { produto: '', sku: '', variacao: '', quantidade: '' };
        for (const b of bounds) {
          const colW = words.filter(w => {
            const x0 = w.bbox?.x0 ?? 0, x1 = w.bbox?.x1 ?? 0, y0 = w.bbox?.y0 ?? 0;
            return x0 >= b.left && x1 <= b.right && y0 >= rowStartY;
          });
          if (!colW.length) continue;
          // encontra a menor y (primeira linha)
          const yMin = Math.min(...colW.map(w => w.bbox?.y0 ?? 0));
          const lineWords = colW.filter(w => (w.bbox?.y0 ?? 0) <= yMin + band)
                                .sort((a,b)=>(a.bbox?.x0 ?? 0)-(b.bbox?.x0 ?? 0));
          const txt = lineWords.map(w => (w.text||'').trim()).join(' ').replace(/\s+/g,' ').trim();
          colFirst[b.key] = txt;
        }
        console.log('[OCR] Colunas (primeira linha)', colFirst, bounds);

        // Reconstrói a primeira linha completa e a versão resumida (SKU + Quantidade)
        const firstLine = [colFirst.produto, colFirst.sku, colFirst.variacao, colFirst.quantidade]
          .filter(Boolean)
          .join(' ')
          .replace(/\s+/g,' ')
          .trim();
        if (firstLine) footerLines[0] = firstLine; // substitui linha 1 por linha reconstruída

        const skuLine = (colFirst.sku || '').trim();
        const qtyLine = (colFirst.quantidade || '').trim();
        if (skuLine || qtyLine) {
          footerOneLine = `SKU: ${skuLine} | Quantidade: ${qtyLine}`
            .replace(/\s+\|\s+$/, '')
            .trim();
        }
      } catch (e) {
        console.warn('[OCR] Falha ao segmentar colunas:', e);
      }

      console.log('[OCR] Footer 4 linhas', footerLines);
      console.log('[OCR] Itens extraídos', items);
      if (footerOneLine) console.log('[OCR] Rodapé (SKU+Qtd)', footerOneLine);
      console.groupEnd();
      return { items, footerLines, footerOneLine };
    }

    async function extractMercadoLivreData(canvas) {
      const { data: { text } } = await Tesseract.recognize(canvas, 'por+eng');
      const lines = text.split(/\n/).map(l => l.trim()).filter(l => l);
      let sku = '', quantidade = 0, loja = '';
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const skuMatch = line.match(/SKU\s*[:\-]?\s*([\w\.\-\/]+)/i);
        if (skuMatch) sku = skuMatch[1];
        const qtdMatch = line.match(/(QTD|QUANTIDADE)\s*[:\-]?\s*(\d+)/i);
        if (qtdMatch) quantidade = parseInt(qtdMatch[2], 10) || 0;
        if (!loja && !line.match(/SKU|QTD|QUANTIDADE/i)) loja = line;
      }
      return { sku, quantidade, loja };
    }

    async function getNextOcrLabelNumber(total) {
      if (!currentUser) return 1;
      const value = Number(total);
      if (!Number.isFinite(value) || value <= 0) return 1;
      const totalSanitizado = Math.max(1, Math.floor(value));
      const ref = db.collection('uid').doc(currentUser.uid).collection('config').doc('contadores');
      try {
        return await db.runTransaction(async tx => {
          const snap = await tx.get(ref);
          const atual = snap.exists ? (snap.data().ocrLastNumber || 0) : 0;
          const inicio = atual + 1;
          const proximo = atual + totalSanitizado;
          tx.set(ref, { ocrLastNumber: proximo }, { merge: true });
          return inicio;
        });
      } catch (err) {
        console.error('Erro ao atualizar o contador de etiquetas OCR:', err);
        return 1;
      }
    }

    async function savePrintedSkuQuantities(items) {
      if (!currentUser || !items || items.length === 0) return;
      const batch = db.batch();
      const userDoc = db.collection('uid').doc(currentUser.uid);
      const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
      items.forEach(item => {
        if (!item || !item.sku) return;
        const quantidadeValida = Number.isFinite(item.quantidade) ? item.quantidade : 0;
        const data = {
          sku: item.sku,
          quantidade: quantidadeValida,
          loja: item.loja || '',
          data: firebase.firestore.FieldValue.serverTimestamp()
        };
        const numeroEtiqueta = item.labelNumber ?? item.numeroEtiqueta;
        if (Number.isFinite(numeroEtiqueta)) data.labelNumber = numeroEtiqueta;
        batch.set(userDoc.collection('etiquetasimpressas').doc(), data);
        if (respDoc) batch.set(respDoc.collection('etiquetasimpressas').doc(), data);
      });
      await batch.commit();
    }

    async function saveLabelSummary(summary) {
      if (!currentUser) return;
      try {
        const totalPaginas = Math.max(0, Math.floor(Number(summary?.totalPaginas) || 0));
        const paginasRaw = Array.isArray(summary?.paginasResumo) ? summary.paginasResumo : [];
        const paginas = paginasRaw.map(p => {
          const numero = Number.isFinite(p?.numero) ? Math.floor(p.numero) : null;
          const sku = (p?.sku || '').toString().trim();
          const quantidade = Number.isFinite(p?.quantidade) ? p.quantidade : null;
          return { numero, sku, quantidade };
        });
        const totaisPorSkuMap = new Map();
        paginas.forEach(p => {
          if (!p.sku) return;
          const quantidade = Number.isFinite(p.quantidade) ? p.quantidade : 0;
          totaisPorSkuMap.set(p.sku, (totaisPorSkuMap.get(p.sku) || 0) + quantidade);
        });
        const totaisPorSku = Array.from(totaisPorSkuMap.entries()).map(([sku, quantidade]) => ({ sku, quantidade }));
        const contadorInicial = Number.isFinite(summary?.contadorInicial) ? Math.floor(summary.contadorInicial) : null;
        const contadorFinal = Number.isFinite(summary?.contadorFinal) ? Math.floor(summary.contadorFinal) : null;
        const baseData = {
          arquivo: summary?.fileName || '',
          totalPaginas: totalPaginas || paginas.length,
          paginas,
          totaisPorSku,
          paginasSemSku: paginas.filter(p => !p.sku).length,
          contadorInicial,
          contadorFinal,
          pdfDocId: summary?.pdfDocId || null,
          pdfUrl: summary?.pdfUrl || '',
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email || '',
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          foraHorario: Boolean(summary?.foraHorario)
        };
        const userCollection = db.collection('users').doc(currentUser.uid).collection('etiquetasResumo');
        const docRef = userCollection.doc();
        const writes = [docRef.set(baseData)];
        if (responsavelExpedicaoUid) {
          const managerDoc = db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetasResumo').doc(docRef.id);
          writes.push(managerDoc.set(baseData));
        }
        await Promise.all(writes);
      } catch (err) {
        console.error('Erro ao salvar resumo de etiquetas:', err);
      }
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function updateProgress(current, total, startTime, progressFill, progressText, timerText) {
      const progress = Math.round((current / total) * 100);
      progressFill.style.width = progress + "%";
      if (current > 0) {
        progressText.textContent = `Processando página ${current} de ${total} (${progress}%)`;
        const elapsed = (Date.now() - startTime) / 1000;
        const avg = elapsed / current;
        const remaining = Math.max(0, Math.round(avg * (total - current)));
        timerText.textContent = `Tempo restante: ${formatTime(remaining)}`;
      } else {
        progressText.textContent = `Preparando (${total} páginas)...`;
        timerText.textContent = "";
      }
    }

    async function uploadPdfToFirebase(blob, fileName, items, extraMeta = {}) {
      if (!currentUser) {
        await savePrintedSkuQuantities(items);
        return;
      }
      try {
        const gestoresRaw = document.getElementById('gestoresEmails').value || '';
        const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
        const selecionado = await escolherGestorEmail(gestoresEmails);
        const totalPaginas = Math.max(0, Math.floor(Number(extraMeta.totalPaginas) || 0));
        const contadorInicial = Number.isFinite(extraMeta.contadorInicial) ? Math.floor(extraMeta.contadorInicial) : null;
        const contadorFinal = Number.isFinite(extraMeta.contadorFinal) ? Math.floor(extraMeta.contadorFinal) : null;
        const foraHorarioAtual = foraDoHorario();
        const docPayload = {
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email,
          gestoresExpedicaoEmails: selecionado,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          name: fileName,
          foraHorario: foraHorarioAtual,
          totalPaginas
        };
        if (contadorInicial !== null) docPayload.contadorInicial = contadorInicial;
        if (contadorFinal !== null) docPayload.contadorFinal = contadorFinal;
        const docRef = await db.collection('pdfDocs').add(docPayload);
        const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
        await fileRef.put(blob);
        const url = await fileRef.getDownloadURL();
        await docRef.update({ url: url, storagePath: fileRef.fullPath });
        const record = {
          name: fileName,
          url: url,
          path: fileRef.fullPath,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          totalPaginas,
          contadorInicial,
          contadorFinal
        };
        await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
        if (
          window.ExpedicaoNotifier &&
          typeof window.ExpedicaoNotifier.notifyNovaEtiqueta === 'function'
        ) {
          await window.ExpedicaoNotifier.notifyNovaEtiqueta({
            db,
            firebase,
            currentUser,
            destinatarioEmails: selecionado,
            destinatarioUids: responsavelExpedicaoUid
              ? [responsavelExpedicaoUid]
              : [],
            arquivoNome: fileName,
            totalPaginas,
            foraHorario: foraHorarioAtual,
            origem: 'Etiquetas PDF (OCR)',
            pdfDocId: docRef.id,
            additionalData: {
              contadorInicial,
              contadorFinal,
            },
          });
        }
        await savePrintedSkuQuantities(items);
        if (Array.isArray(extraMeta.paginasResumo)) {
          await saveLabelSummary({
            totalPaginas,
            paginasResumo: extraMeta.paginasResumo,
            contadorInicial,
            contadorFinal,
            fileName,
            pdfDocId: docRef.id,
            pdfUrl: url,
            foraHorario: foraHorarioAtual
          });
        }
      } catch (err) {
        console.error('Erro ao enviar PDF para Firebase:', err);
        showMessage('Erro ao enviar PDF. Tente novamente mais tarde.');
        throw err;
      }
    }

    async function processar() {
      const status = document.getElementById("status");
      const pdfFile = document.getElementById("pdfInput").files[0];

      if (!pdfFile) {
        hideProcessingModal();
        return showMessage("Envie o arquivo PDF.");
      }

      openProcessingModal();

      const startTime = Date.now();
      const allExtractedItems = [];
      const paginasResumo = [];
      let contadorInicial = null;
      let proximoNumeroEtiqueta = 1;
      let contadorInicializado = false;
      let totalPrevisto = 0;

      try {
        status.textContent = "📸 Lendo PDF...";
        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const novoPdf = await PDFLib.PDFDocument.create();
        const rodapeFont = await novoPdf.embedFont(PDFLib.StandardFonts.Helvetica);
        const canvas = document.getElementById("pdfCanvas");
        const ctx = canvas.getContext("2d");
        canvas.style.display = "block";
        updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const scale = 6;
          const viewport = page.getViewport({ scale });

          canvas.width = viewport.width;
          canvas.height = viewport.height;

          await page.render({ canvasContext: ctx, viewport }).promise;
          updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);

          const largura = canvas.width;
          const altura = canvas.height;
          const colWidth = largura / 2;
          const rowHeight = altura / 1.75;

          const pares = [
            { etiqueta: { x: 0, y: 0 }, checklist: { x: 0, y: rowHeight } },
            { etiqueta: { x: colWidth, y: 0 }, checklist: { x: colWidth, y: rowHeight } }
          ];

          if (!contadorInicializado) {
            totalPrevisto = pdf.numPages * pares.length;
            if (currentUser) {
              contadorInicial = await getNextOcrLabelNumber(totalPrevisto);
              proximoNumeroEtiqueta = contadorInicial;
            } else {
              contadorInicial = 1;
              proximoNumeroEtiqueta = 1;
            }
            contadorInicializado = true;
          }

          for (const par of pares) {
            const proporcaoEtiqueta = 0.88;
            const proporcaoChecklist = 0.12;

            const alturaEtiquetaPrincipal = rowHeight * proporcaoEtiqueta;
            const alturaChecklist = rowHeight * proporcaoChecklist;
            const deslocamentoEtiquetaY = 6;

            const etCanvas = document.createElement("canvas");
            etCanvas.width = colWidth;
            etCanvas.height = alturaEtiquetaPrincipal - deslocamentoEtiquetaY;
            const etCtx = etCanvas.getContext("2d");
            etCtx.drawImage(
              canvas,
              par.etiqueta.x,
              par.etiqueta.y + deslocamentoEtiquetaY,
              colWidth,
              alturaEtiquetaPrincipal - deslocamentoEtiquetaY,
              0,
              0,
              colWidth,
              alturaEtiquetaPrincipal - deslocamentoEtiquetaY
            );

            const chkCanvas = document.createElement("canvas");
            const deslocamentoY = 60;
            const novaAlturaChecklist = Math.max(alturaChecklist - deslocamentoY, 100);
            const scaleChecklist = 7;
            chkCanvas.width = Math.floor(colWidth * scaleChecklist);
            chkCanvas.height = Math.floor(novaAlturaChecklist * scaleChecklist);
            const chkCtx = chkCanvas.getContext("2d");
            chkCtx.imageSmoothingEnabled = true;
            chkCtx.imageSmoothingQuality = 'high';
            chkCtx.drawImage(
              canvas,
              par.checklist.x,
              par.checklist.y + deslocamentoY,
              colWidth,
              novaAlturaChecklist,
              0,
              0,
              chkCanvas.width,
              chkCanvas.height
            );

            console.groupCollapsed('[Crop] Parâmetros de corte');
            console.log({
              pagina: i + 1,
              par,
              colWidth,
              rowHeight,
              proporcaoEtiqueta,
              proporcaoChecklist,
              alturaEtiquetaPrincipal,
              alturaChecklist,
              deslocamentoEtiquetaY,
              deslocamentoY,
              novaAlturaChecklist,
              scaleChecklist
            });
            console.groupEnd();

            const extracted = await extractSkuQuantitiesFromCanvas(chkCanvas, { pagina: i + 1, par });
            const numeroEtiquetaAtual = proximoNumeroEtiqueta;
            proximoNumeroEtiqueta++;

            const etiquetaCompletaCanvas = document.createElement("canvas");
            const paddingX = 0;
            etiquetaCompletaCanvas.width = colWidth + paddingX * 2;
            const ajusteVerticalChecklist = 12;
            etiquetaCompletaCanvas.height =
              (alturaEtiquetaPrincipal - deslocamentoEtiquetaY) +
              ajusteVerticalChecklist;

            const completoCtx = etiquetaCompletaCanvas.getContext("2d");
            completoCtx.imageSmoothingEnabled = true;
            completoCtx.imageSmoothingQuality = 'high';
            completoCtx.drawImage(etCanvas, paddingX, 0);

            const imgBytes = await fetch(etiquetaCompletaCanvas.toDataURL("image/png")).then(res => res.arrayBuffer());
            const imgEmbed = await novoPdf.embedPng(imgBytes);

            const larguraPagina = 293.46;
            const alturaPagina = 475.2;
            const scaleFactor = 0.90;
            const larguraEtiquetaFinal = 277 * scaleFactor;
            const alturaEtiquetaFinal = 449 * scaleFactor;
            const margemX = (larguraPagina - larguraEtiquetaFinal) / 2;
            const margemY = (alturaPagina - alturaEtiquetaFinal) / 2;
            const ajusteVertical = 20;
            const yPos = margemY + ajusteVertical;

            const pag = novoPdf.addPage([larguraPagina, alturaPagina]);
            pag.drawImage(imgEmbed, {
              x: margemX,
              y: yPos,
              width: larguraEtiquetaFinal,
              height: alturaEtiquetaFinal,
            });

            const fallbackItem = extracted?.items && extracted.items[0] ? extracted.items[0] : null;
            const oneLine = extracted?.footerOneLine
              ? extracted.footerOneLine
              : (fallbackItem
                  ? `SKU: ${fallbackItem.sku} | Quantidade: ${fallbackItem.quantidade}`
                  : (extracted?.footerLines ? extracted.footerLines[0] : ''));

            let saveSku = '';
            let saveQtd = null;
            let possuiQtd = false;
            let skuTxt = '';
            let qtdTxt = '';

            if (oneLine) {
              const mSku = oneLine.match(/SKU\s*:\s*([^|]+?)(?:\s*\||$)/i);
              if (mSku && mSku[1]) {
                saveSku = mSku[1].trim();
                if (saveSku) skuTxt = `SKU: ${saveSku}`;
              }
              const mQtd = oneLine.match(/Quantidade\s*:\s*(\d+)/i);
              if (mQtd && mQtd[1]) {
                const qtdParse = parseInt(mQtd[1], 10);
                if (!Number.isNaN(qtdParse)) {
                  saveQtd = qtdParse;
                  possuiQtd = true;
                  qtdTxt = `Quantidade: ${qtdParse}`;
                }
              }
            }

            if (!saveSku && fallbackItem?.sku != null) {
              const fallbackSku = String(fallbackItem.sku).trim();
              if (fallbackSku) {
                saveSku = fallbackSku;
                skuTxt = `SKU: ${saveSku}`;
              }
            }
            if (!possuiQtd && fallbackItem && fallbackItem.quantidade != null) {
              const qtdFallback = Number(fallbackItem.quantidade);
              if (Number.isFinite(qtdFallback)) {
                saveQtd = qtdFallback;
                possuiQtd = true;
                qtdTxt = `Quantidade: ${qtdFallback}`;
              }
            }

            if (saveSku) {
              allExtractedItems.push({
                sku: saveSku,
                quantidade: possuiQtd ? saveQtd : 0,
                labelNumber: numeroEtiquetaAtual
              });
            }

            paginasResumo.push({
              numero: numeroEtiquetaAtual,
              sku: saveSku || '',
              quantidade: possuiQtd ? saveQtd : null
            });

            const numeroTxt = `Etiqueta Nº: ${numeroEtiquetaAtual}`;
            const linhasRodape = [];
            if (skuTxt) linhasRodape.push(skuTxt);
            if (possuiQtd && qtdTxt) linhasRodape.push(qtdTxt);
            linhasRodape.push(numeroTxt);

            const fontSize = 9.5;
            const lineGap = 2;
            const padding = 4;
            const blocoAltura = (fontSize + lineGap) * linhasRodape.length + padding * 2;
            let footerY = yPos - blocoAltura - 2;
            if (footerY < 2) footerY = yPos;

            pag.drawRectangle({
              x: margemX,
              y: footerY,
              width: larguraEtiquetaFinal,
              height: blocoAltura,
              color: PDFLib.rgb(1, 1, 1)
            });

            for (let li = 0; li < linhasRodape.length; li++) {
              pag.drawText(linhasRodape[li], {
                x: margemX + 6,
                y: footerY + padding + li * (fontSize + lineGap),
                size: fontSize,
                font: rodapeFont,
                color: PDFLib.rgb(0, 0, 0)
              });
            }
        }
      }

        progressFill.style.width = "100%";
        progressText.textContent = "Processamento concluído (100%)";
        const totalTime = Math.round((Date.now() - startTime) / 1000);
        timerText.textContent = `Tempo decorrido: ${formatTime(totalTime)}`;

        const pdfFinal = await novoPdf.save();
        const blob = new Blob([pdfFinal], { type: "application/pdf" });
        const fileName = `etiquetas_editadas_${Date.now()}.pdf`;
        const localUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = localUrl;
        a.download = fileName;
        a.click();

        const contadorFinal = contadorInicializado ? (proximoNumeroEtiqueta - 1) : null;
        const totalPaginasGeradas = paginasResumo.length || totalPrevisto;
        status.textContent = "📤 Enviando ao servidor...";
        try {
          await uploadPdfToFirebase(blob, fileName, allExtractedItems, {
            totalPaginas: totalPaginasGeradas,
            paginasResumo,
            contadorInicial: contadorInicializado ? contadorInicial : null,
            contadorFinal
          });
          status.textContent = "✅ PDF gerado com sucesso! Concluído.";
          const finalTime = Math.round((Date.now() - startTime) / 1000);
          completeProcessingModal(finalTime);
        } catch (err) {
          console.error('Erro ao enviar PDF gerado:', err);
          status.textContent = "⚠️ PDF gerado, mas houve erro no envio.";
          failProcessingModal('Não foi possível salvar o arquivo final. Tente novamente.');
        }
      } catch (err) {
        console.error('Erro no processamento de etiquetas:', err);
        status.textContent = "⚠️ Ocorreu um erro durante o processamento das etiquetas.";
        failProcessingModal('O processamento falhou. Verifique o arquivo e tente novamente.');
      }
    }

    window.processar = processar;
    async function processarMercadoLivre() {
      const status = document.getElementById("status");
      const pdfFile = document.getElementById("pdfInput").files[0];

      if (!pdfFile) {
        hideProcessingModal();
        return showMessage("Envie o arquivo PDF.");
      }

      openProcessingModal();
      const startTime = Date.now();

      try {
        status.textContent = "📸 Lendo PDF Mercado Livre...";
        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const canvas = document.getElementById("pdfCanvas");
        const ctx = canvas.getContext("2d");
        canvas.style.display = "block";
        const allItems = [];
        updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

        for (let i = 0; i < pdf.numPages; i++) {
          const page = await pdf.getPage(i + 1);
          const scale = 3;
          const viewport = page.getViewport({ scale });
          canvas.width = viewport.width;
          canvas.height = viewport.height;
          await page.render({ canvasContext: ctx, viewport }).promise;
          updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);
          const data = await extractMercadoLivreData(canvas);
          if (data.sku) allItems.push(data);
        }

        progressFill.style.width = "100%";
        progressText.textContent = "Processamento concluído (100%)";
        const totalTime = Math.round((Date.now() - startTime) / 1000);
        timerText.textContent = `Tempo decorrido: ${formatTime(totalTime)}`;

        status.textContent = "📤 Enviando ao servidor...";
        if (currentUser) {
          const gestoresRaw = document.getElementById('gestoresEmails').value || '';
          const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
          const fileName = `mercado_livre_${Date.now()}.pdf`;
          const selecionado = await escolherGestorEmail(gestoresEmails);
          const docRef = await db.collection('pdfDocs').add({
            ownerUid: currentUser.uid,
            ownerEmail: currentUser.email,
            gestoresExpedicaoEmails: selecionado,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            name: fileName,
            foraHorario: foraDoHorario()
          });
          const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
          await fileRef.put(pdfFile);
          const url = await fileRef.getDownloadURL();
          await docRef.update({ url: url, storagePath: fileRef.fullPath });
          const record = {
            name: fileName,
            url: url,
            path: fileRef.fullPath,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          };
          await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
          if (responsavelExpedicaoUid) {
            const respRecord = {
              name: fileName,
              url: url,
              path: fileRef.fullPath,
              createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
          }
          if (
            window.ExpedicaoNotifier &&
            typeof window.ExpedicaoNotifier.notifyNovaEtiqueta === 'function'
          ) {
            await window.ExpedicaoNotifier.notifyNovaEtiqueta({
              db,
              firebase,
              currentUser,
              destinatarioEmails: selecionado,
              destinatarioUids: responsavelExpedicaoUid
                ? [responsavelExpedicaoUid]
                : [],
              arquivoNome: fileName,
              totalEtiquetas: allItems.length,
              foraHorario: foraDoHorario(),
              origem: 'Etiquetas Mercado Livre',
              pdfDocId: docRef.id,
            });
          }
        }

        await savePrintedSkuQuantities(allItems);
        status.textContent = "✅ Etiquetas Mercado Livre processadas! Concluído.";
        const finalTime = Math.round((Date.now() - startTime) / 1000);
        completeProcessingModal(finalTime);
      } catch (err) {
        console.error('Erro no processamento Mercado Livre:', err);
        status.textContent = "⚠️ Não foi possível processar as etiquetas do Mercado Livre.";
        failProcessingModal('Não foi possível salvar o arquivo do Mercado Livre. Tente novamente.');
      }
    }

    window.processarMercadoLivre = processarMercadoLivre;
    </script>

  <script src="shared.js"></script>
  </div>
</body>
</html>

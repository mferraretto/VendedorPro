<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Etiquetas PDF</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/styles.css?v=20240826">
  <link rel="stylesheet" href="css/mobile.css">
  <link rel="stylesheet" href="css/components.css">
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  <style>
    .progress-bar-bg {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      border-radius: 9999px;
      height: 1.5rem;
      overflow: hidden;
      box-shadow: 0 2px 16px rgba(0,0,0,0.08);
    }
    .progress-bar-fill {
      background: linear-gradient(90deg, #06B6D4 0%, #3B82F6 100%);
      height: 100%;
      border-radius: 9999px 0 0 9999px;
      transition: width 0.3s cubic-bezier(.4,0,.2,1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-weight: 600;
      font-size: 0.875rem;
      background-size: 200% 100%;
      animation: progress-animation 2s linear infinite;
    }
    @keyframes progress-animation {
      0% { background-position: 0% 0; }
      100% { background-position: -200% 0; }
    }
    #timerText {
      font-size: 0.875rem;
      color: #374151;
      font-weight: 500;
    }
    #status {
      min-height: 2rem;
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="max-w-xl w-full mx-auto p-4">
    <h1 class="text-4xl font-bold text-center mb-6 flex items-center justify-center gap-2">
      <i class="fa-solid fa-barcode"></i>
      ETIQUETAS PDF
    </h1>

    <div class="mb-4">
      <p class="text-sm font-medium text-gray-700 mb-1">Seus Gestores</p>
      <input type="text" id="gestoresEmails" placeholder="E-mails do gestor de expedição (separados por vírgula)" class="w-full border border-gray-300 rounded-lg p-2" />
    </div>

    <div class="mb-6">
      <label for="pdfInput" class="block cursor-pointer">
        <div class="w-full p-6 border-2 border-dashed border-gray-300 rounded-lg text-center bg-white hover:bg-gray-50">
          <i class="fa-solid fa-cloud-arrow-up text-3xl text-gray-400 mb-2"></i>
          <p class="text-gray-600">Arrastar e soltar ou clicar para fazer upload</p>
        </div>
      </label>
      <input type="file" id="pdfInput" accept="application/pdf" class="hidden" />
    </div>

    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500 mb-4" onclick="processar()">
      Etiquetas Shopee + lista empacotamento
    </button>
    <button class="w-full py-3 rounded-lg text-white font-medium bg-gradient-to-r from-teal-500 to-blue-500" onclick="processarMercadoLivre()">
      Etiquetas Mercado Livre
    </button>

    <div class="mt-6">
      <div class="progress-bar-bg" id="progressBar" style="display:none;">
        <div class="progress-bar-fill" id="progressFill" style="width:0%;">
          <span id="progressText" class="w-full text-center"></span>
        </div>
      </div>
      <div id="timerText" class="text-center text-sm text-gray-700 mt-2"></div>
    </div>

    <div class="status mt-4 text-blue-700 font-medium" id="status"></div>
    <canvas id="pdfCanvas" class="mt-8 mx-auto border rounded-lg shadow" style="display:none;max-width:100%;box-shadow:0 2px 16px rgba(0,0,0,0.04);"></canvas>
    <div class="flex justify-center mt-8">
      <span class="text-xs text-gray-500">Desenvolvido por Matheus Ferraretto &nbsp;·&nbsp; <i class="fa-solid fa-robot"></i></span>
    </div>
  </div>

  <div id="gestorModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden">
    <div class="bg-white w-full max-w-md p-4 rounded shadow-lg">
      <h2 class="text-lg font-semibold mb-2">Enviar arquivo para qual gestor?</h2>
      <select id="gestorSelect" class="form-control mb-4"></select>
      <div class="flex justify-end gap-2">
        <button id="gestorCancel" class="btn btn-secondary">Cancelar</button>
        <button id="gestorConfirm" class="btn btn-primary">Confirmar</button>
      </div>
    </div>
  </div>

      <script type="module">
    import { firebaseConfig } from './firebase-config.js';

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

 if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();
    const storage = firebase.storage();
    let currentUser = null;
    let responsavelExpedicaoUid = null;
    let horariosEtiquetas = [];

    function escolherGestorEmail(emails) {
      return new Promise(resolve => {
        if (!emails || !emails.length) return resolve([]);
        if (emails.length === 1) return resolve([emails[0]]);

        const modal = document.getElementById('gestorModal');
        const select = document.getElementById('gestorSelect');
        const confirmBtn = document.getElementById('gestorConfirm');
        const cancelBtn = document.getElementById('gestorCancel');

        select.innerHTML = '';
        emails.forEach(email => {
          const opt = document.createElement('option');
          opt.value = email;
          opt.textContent = email;
          select.appendChild(opt);
        });

        function close(value) {
          modal.classList.add('hidden');
          confirmBtn.removeEventListener('click', onConfirm);
          cancelBtn.removeEventListener('click', onCancel);
          modal.removeEventListener('click', onBackdrop);
          resolve([value]);
        }

        function onConfirm() { close(select.value || emails[0]); }
        function onCancel() { close(emails[0]); }
        function onBackdrop(e) { if (e.target === modal) close(emails[0]); }

        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        modal.addEventListener('click', onBackdrop);

        modal.classList.remove('hidden');
      });
    }
firebase.auth().onAuthStateChanged(async u => {
      currentUser = u;
      if (!u) return;
      try {
        const doc = await db.collection('uid').doc(u.uid).get();
        const data = doc.data() || {};
        const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
        document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
        const respEmail = Array.isArray(data.gestoresExpedicaoEmails) ? data.gestoresExpedicaoEmails[0] : data.responsavelExpedicaoEmail;
        if (respEmail) {
          const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
          if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
          await carregarHorarios();
        }
      } catch (err) {
        console.error('Erro ao carregar gestor de expedição:', err);
      }
    });
    
    function showMessage(text) {
      const messageBox = document.getElementById("messageBox");
      const messageText = document.getElementById("messageText");
      messageText.textContent = text;
      messageBox.style.display = "block";
    }

    async function carregarHorarios() {
      if (!responsavelExpedicaoUid) return;
      try {
        const doc = await db.collection('uid').doc(responsavelExpedicaoUid).get();
        const data = doc.data() || {};
        horariosEtiquetas = data.horariosEtiquetas || [];
      } catch (e) {
        console.error('Erro ao carregar horários:', e);
      }
    }

    function foraDoHorario() {
      if (!horariosEtiquetas.length) return false;
      const now = new Date();
      return !horariosEtiquetas.some(h => {
        if (!h.inicio || !h.fim) return false;
        const [ih, im] = h.inicio.split(':').map(Number);
        const [fh, fm] = h.fim.split(':').map(Number);
        const start = new Date(now);
        start.setHours(ih, im, 0, 0);
        const end = new Date(now);
        end.setHours(fh, fm, 0, 0);
        return now >= start && now <= end;
      });
    }

    async function extractSkuQuantitiesFromCanvas(canvas, info) {
      const ctxInfo = info || {};
      console.groupCollapsed('[OCR] Iniciando reconhecimento', ctxInfo);
      console.time('[OCR] tempo');
      const { data } = await Tesseract.recognize(canvas, 'por+eng');
      const text = data?.text || '';
      console.timeEnd('[OCR] tempo');
      console.log('[OCR] Dimensões canvas', { width: canvas.width, height: canvas.height });
      console.log('[OCR] Texto bruto');
      console.log(text);

      const items = [];
      // 1) Padrão principal: SKU ... (QTD|QUANTIDADE|QTY) ... número
      //    Permite + no SKU (ex.: T6+P4)
      const regex = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+).*?(?:QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/gis;
      let match;
      while ((match = regex.exec(text)) !== null) {
        items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
      }

      // 2) Padrão alternativo: SKU ... x 2
      if (items.length === 0) {
        const alt = /SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)\s*[xX*]\s*(\d{1,3})/gis;
        while ((match = alt.exec(text)) !== null) {
          items.push({ sku: (match[1]||'').trim(), quantidade: parseInt(match[2], 10) || 0 });
        }
      }

      // 3) Heurística linha-a-linha (SKU na linha N, quantidade na N+1)
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        console.log('[OCR] Linhas normalizadas', lines);
        for (let i = 0; i < lines.length; i++) {
          const skuMatch = lines[i].match(/SKU\s*[:\-]?\s*([A-Z0-9\.\+_\-\/]+)/i);
          if (skuMatch) {
            const next = (lines[i + 1] || '') + ' ' + (lines[i + 2] || '');
            const qtdMatch = next.match(/(QTD|QUANTIDADE|QTY|QDE)\s*[:\-]?\s*(\d{1,3})/i) || next.match(/[xX*]\s*(\d{1,3})/);
            const qtdVal = qtdMatch ? parseInt(qtdMatch[qtdMatch.length - 1], 10) || 0 : 0;
            items.push({ sku: (skuMatch[1]||'').trim(), quantidade: qtdVal });
          }
        }
      }

      // 4) Heurística por linha com quantidade no fim
      //    Estruturas vistas no OCR: "1 Artigo ... T6+P4 CILINDROS + ARCO 2" ou "1 Trio de Boleiras TR15 1"
      if (items.length === 0) {
        const lines = text.split(/\n/).map(l => l.trim()).filter(Boolean);
        for (const line of lines) {
          const mQty = line.match(/(.+?)\s+(\d{1,3})\s*$/);
          if (!mQty) continue;
          const body = mQty[1];
          const qty = parseInt(mQty[2], 10) || 0;

          const rawTokens = body.split(/\s+/);
          // vasculha da direita p/ esquerda
          let candidate = '';
          for (let ti = rawTokens.length - 1; ti >= 0; ti--) {
            let tok = rawTokens[ti];
            // junta sinais adjacentes separados (por ex. '+' isolado)
            if ((tok === '+' || tok === '-' || tok === '/') && ti > 0) {
              rawTokens[ti - 1] = rawTokens[ti - 1] + tok;
              continue;
            }
            const clean = tok.replace(/[^A-Za-z0-9+_\-\/\.]/g, '');
            const hasDigit = /\d/.test(clean);
            const hasSpecial = /[+_\-\/\.]/.test(clean);
            if (clean.length >= 2 && (hasDigit || hasSpecial)) {
              candidate = clean;
              break;
            }
          }
          // fallback: última palavra relevante antes da quantidade
          if (!candidate) {
            const lastWord = body.split(/\s+/).pop() || '';
            const clean = lastWord.replace(/[^A-Za-z0-9]/g, '');
            if (clean.length >= 3) candidate = clean.toUpperCase();
          }

          if (candidate) {
            console.log('[OCR] Heurística (linha com quantidade) encontrou', { line, candidate, qty });
            items.push({ sku: candidate, quantidade: qty });
          }
        }
      }

      // ===== Construção do rodapé (4 linhas) com base no CHECKLIST =====
      // Estratégia: pegar as 4 primeiras linhas originais a partir da linha que começa com "1"
      const rawLines = text.split(/\n/).map(l => l.trim());
      const cleaned = rawLines
        .filter(l => l)
        .filter(l => !/^=+/.test(l))
        .filter(l => !/\b(Produto|SKU|Variac[aã]o|Quantidade)\b/i.test(l));

      const footerLines = [];
      let footerOneLine = '';
      const idx1 = cleaned.findIndex(l => /^\s*1\b/.test(l));
      if (idx1 >= 0) {
        // Linha da contagem 1: remove o "1" do início e mantém o restante intacto (inclusive quantidade ao final)
        const firstLine = cleaned[idx1].replace(/^\s*1\s*/, '').trim();
        footerLines.push(firstLine);
        for (let k = idx1 + 1; k < cleaned.length && footerLines.length < 4; k++) {
          // Mantém as linhas seguintes exatamente como o OCR retornou
          footerLines.push(cleaned[k]);
        }
      }
      while (footerLines.length < 4) footerLines.push('');

      // ===== Segmentação por COLUNAS (Produto | SKU | Variação | Quantidade) =====
      try {
        const words = Array.isArray(data?.words) ? data.words : [];
        const W = canvas.width, H = canvas.height;
        function norm(s){ return (s||'').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
        const headerZoneY = H * 0.45; // cabeçalho costuma ficar no topo da área
        const headers = { produto: null, sku: null, variacao: null, quantidade: null };
        for (const w of words) {
          const t = norm(w.text || w.symbol || '');
          const y0 = w.bbox?.y0 ?? w.bbox?.y ?? 0;
          if (y0 > headerZoneY) continue;
          if (!headers.produto && t === 'produto') headers.produto = w;
          if (!headers.sku && t === 'sku') headers.sku = w;
          if (!headers.variacao && (t === 'variacao' || t === 'variacao:')) headers.variacao = w;
          if (!headers.quantidade && (t === 'quantidade' || t === 'quantidade:')) headers.quantidade = w;
        }
        // Limites em X das colunas
        const xPos = [];
        if (headers.produto?.bbox?.x0 != null) xPos.push({ key: 'produto', x: headers.produto.bbox.x0 });
        if (headers.sku?.bbox?.x0 != null) xPos.push({ key: 'sku', x: headers.sku.bbox.x0 });
        if (headers.variacao?.bbox?.x0 != null) xPos.push({ key: 'variacao', x: headers.variacao.bbox.x0 });
        if (headers.quantidade?.bbox?.x0 != null) xPos.push({ key: 'quantidade', x: headers.quantidade.bbox.x0 });
        xPos.sort((a,b)=>a.x-b.x);

        let bounds = [];
        if (xPos.length >= 3) {
          for (let i=0;i<xPos.length;i++){
            const left = xPos[i].x - 40; // margem
            const right = (xPos[i+1]?.x ?? (W-10)) - 10;
            bounds.push({ key: xPos[i].key, left: Math.max(0,left), right: Math.min(W,right) });
          }
        } else {
          // fallback: frações fixas
          bounds = [
            { key: 'produto', left: Math.round(W*0.08), right: Math.round(W*0.55) },
            { key: 'sku', left: Math.round(W*0.56), right: Math.round(W*0.66) },
            { key: 'variacao', left: Math.round(W*0.66), right: Math.round(W*0.83) },
            { key: 'quantidade', left: Math.round(W*0.83), right: Math.round(W*0.97) },
          ];
        }

        const headerMaxY = Math.max(
          headers.produto?.bbox?.y1 ?? 0,
          headers.sku?.bbox?.y1 ?? 0,
          headers.variacao?.bbox?.y1 ?? 0,
          headers.quantidade?.bbox?.y1 ?? 0,
          H*0.18
        );
        const rowStartY = headerMaxY + 10;
        const band = H * 0.08; // faixa para capturar a primeira linha após o cabeçalho

        const colFirst = { produto: '', sku: '', variacao: '', quantidade: '' };
        for (const b of bounds) {
          const colW = words.filter(w => {
            const x0 = w.bbox?.x0 ?? 0, x1 = w.bbox?.x1 ?? 0, y0 = w.bbox?.y0 ?? 0;
            return x0 >= b.left && x1 <= b.right && y0 >= rowStartY;
          });
          if (!colW.length) continue;
          // encontra a menor y (primeira linha)
          const yMin = Math.min(...colW.map(w => w.bbox?.y0 ?? 0));
          const lineWords = colW.filter(w => (w.bbox?.y0 ?? 0) <= yMin + band)
                                .sort((a,b)=>(a.bbox?.x0 ?? 0)-(b.bbox?.x0 ?? 0));
          const txt = lineWords.map(w => (w.text||'').trim()).join(' ').replace(/\s+/g,' ').trim();
          colFirst[b.key] = txt;
        }
        console.log('[OCR] Colunas (primeira linha)', colFirst, bounds);

        // Reconstrói a primeira linha completa e a versão resumida (SKU + Quantidade)
        const firstLine = [colFirst.produto, colFirst.sku, colFirst.variacao, colFirst.quantidade]
          .filter(Boolean)
          .join(' ')
          .replace(/\s+/g,' ')
          .trim();
        if (firstLine) footerLines[0] = firstLine; // substitui linha 1 por linha reconstruída

        const skuLine = (colFirst.sku || '').trim();
        const qtyLine = (colFirst.quantidade || '').trim();
        if (skuLine || qtyLine) {
          footerOneLine = `SKU: ${skuLine} | Quantidade: ${qtyLine}`
            .replace(/\s+\|\s+$/, '')
            .trim();
        }
      } catch (e) {
        console.warn('[OCR] Falha ao segmentar colunas:', e);
      }

      console.log('[OCR] Footer 4 linhas', footerLines);
      console.log('[OCR] Itens extraídos', items);
      if (footerOneLine) console.log('[OCR] Rodapé (SKU+Qtd)', footerOneLine);
      console.groupEnd();
      return { items, footerLines, footerOneLine };
    }

    async function extractMercadoLivreData(canvas) {
      const { data: { text } } = await Tesseract.recognize(canvas, 'por+eng');
      const lines = text.split(/\n/).map(l => l.trim()).filter(l => l);
      let sku = '', quantidade = 0, loja = '';
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const skuMatch = line.match(/SKU\s*[:\-]?\s*([\w\.\-\/]+)/i);
        if (skuMatch) sku = skuMatch[1];
        const qtdMatch = line.match(/(QTD|QUANTIDADE)\s*[:\-]?\s*(\d+)/i);
        if (qtdMatch) quantidade = parseInt(qtdMatch[2], 10) || 0;
        if (!loja && !line.match(/SKU|QTD|QUANTIDADE/i)) loja = line;
      }
      return { sku, quantidade, loja };
    }

    async function savePrintedSkuQuantities(items) {
      if (!currentUser || !items || items.length === 0) return;
      const batch = db.batch();
      const userDoc = db.collection('uid').doc(currentUser.uid);
      const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
      items.forEach(item => {
        const data = {
          sku: item.sku,
          quantidade: item.quantidade,
          loja: item.loja || '',
          data: firebase.firestore.FieldValue.serverTimestamp()
        };
        batch.set(userDoc.collection('etiquetasimpressas').doc(), data);
        if (respDoc) batch.set(respDoc.collection('etiquetasimpressas').doc(), data);
      });
      await batch.commit();
    }

    function formatTime(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function updateProgress(current, total, startTime, progressFill, progressText, timerText) {
      const progress = Math.round((current / total) * 100);
      progressFill.style.width = progress + "%";
      if (current > 0) {
        progressText.textContent = `Processando página ${current} de ${total} (${progress}%)`;
        const elapsed = (Date.now() - startTime) / 1000;
        const avg = elapsed / current;
        const remaining = Math.max(0, Math.round(avg * (total - current)));
        timerText.textContent = `Tempo restante: ${formatTime(remaining)}`;
      } else {
        progressText.textContent = `Preparando (${total} páginas)...`;
        timerText.textContent = "";
      }
    }

    async function uploadPdfToFirebase(blob, fileName, items) {
      if (!currentUser) {
        await savePrintedSkuQuantities(items);
        return;
      }
      try {
        const gestoresRaw = document.getElementById('gestoresEmails').value || '';
        const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
        const selecionado = await escolherGestorEmail(gestoresEmails);
        const docRef = await db.collection('pdfDocs').add({
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email,
          gestoresExpedicaoEmails: selecionado,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          name: fileName,
          foraHorario: foraDoHorario()
        });
        const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
        await fileRef.put(blob);
        const url = await fileRef.getDownloadURL();
        await docRef.update({ url: url, storagePath: fileRef.fullPath });
        const record = {
          name: fileName,
          url: url,
          path: fileRef.fullPath,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
        await savePrintedSkuQuantities(items);
      } catch (err) {
        console.error('Erro ao enviar PDF para Firebase:', err);
        showMessage('Erro ao enviar PDF. Tente novamente mais tarde.');
        throw err;
      }
    }

    async function processar() {
  const progressBar = document.getElementById("progressBar");
  const progressFill = document.getElementById("progressFill");
  const progressText = document.getElementById("progressText");
  const timerText = document.getElementById("timerText");
  progressBar.style.display = "block";
  progressFill.style.width = "0%";
  progressText.textContent = "";
  timerText.textContent = "";
  const startTime = Date.now();

  const status = document.getElementById("status");
  const pdfFile = document.getElementById("pdfInput").files[0];
  const allExtractedItems = [];
  if (!pdfFile) {
    progressBar.style.display = "none";
    return showMessage("Envie o arquivo PDF.");
  }

  status.textContent = "📸 Lendo PDF...";
    const arrayBuffer = await pdfFile.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    const novoPdf = await PDFLib.PDFDocument.create();
    // Fonte para escrever o rodapé textual (SKU + Quantidade) no PDF
    const rodapeFont = await novoPdf.embedFont(PDFLib.StandardFonts.Helvetica);
    const canvas = document.getElementById("pdfCanvas");
    const ctx = canvas.getContext("2d");
    canvas.style.display = "block";
    updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

    for (let i = 0; i < pdf.numPages; i++) {
      const page = await pdf.getPage(i + 1);
      const scale = 7;
      const viewport = page.getViewport({ scale });

      canvas.width = viewport.width;
      canvas.height = viewport.height;

      await page.render({ canvasContext: ctx, viewport }).promise;
      updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);

    const largura = canvas.width;
    const altura = canvas.height;

    const colWidth = largura / 2;
    const rowHeight = altura / 1.75;

    const pares = [
      { etiqueta: { x: 0, y: 0 }, checklist: { x: 0, y: rowHeight } },
      { etiqueta: { x: colWidth, y: 0 }, checklist: { x: colWidth, y: rowHeight } }
    ];

    for (const par of pares) {
      // Ajuste das proporções para garantir que a parte do checklist seja totalmente capturada.
      // Desta vez, vamos dar mais espaço para o checklist para garantir que nada seja cortado.
      const proporcaoEtiqueta = 0.88; 
      const proporcaoChecklist = 0.12; 

      const alturaEtiquetaPrincipal = rowHeight * proporcaoEtiqueta;
      const alturaChecklist = rowHeight * proporcaoChecklist;
      
      const deslocamentoEtiquetaY = 6;
      
      // CORTA A ETIQUETA PRINCIPAL
      const etCanvas = document.createElement("canvas");
      etCanvas.width = colWidth;
      etCanvas.height = alturaEtiquetaPrincipal - deslocamentoEtiquetaY;
      const etCtx = etCanvas.getContext("2d");
      etCtx.drawImage(canvas, par.etiqueta.x, par.etiqueta.y + deslocamentoEtiquetaY, colWidth, alturaEtiquetaPrincipal - deslocamentoEtiquetaY, 0, 0, colWidth, alturaEtiquetaPrincipal - deslocamentoEtiquetaY);
      
      // CORTA A PARTE DO CHECKLIST
      const chkCanvas = document.createElement("canvas");
      
      // Definimos um deslocamento mínimo para evitar a linha de separação, mas não cortar o texto.
      const deslocamentoY = 60; 
const novaAlturaChecklist = Math.max(alturaChecklist - deslocamentoY, 100); // evita 5/negativo
      
     const scaleChecklist = 7; // resolução extra
chkCanvas.width  = Math.floor(colWidth * scaleChecklist);
chkCanvas.height = Math.floor(novaAlturaChecklist * scaleChecklist);
const chkCtx = chkCanvas.getContext("2d");
chkCtx.imageSmoothingEnabled = true;
chkCtx.imageSmoothingQuality = 'high';

// captura em alta resolução
chkCtx.drawImage(
  canvas,
  par.checklist.x, par.checklist.y + deslocamentoY,     // origem (na página)
  colWidth, novaAlturaChecklist,                        // tamanho a capturar
  0, 0,                                                 // destino no chkCanvas
  chkCanvas.width, chkCanvas.height                     // destino (maior)
);

      console.groupCollapsed('[Crop] Parâmetros de corte');
      console.log({
        pagina: i + 1,
        par,
        colWidth,
        rowHeight,
        proporcaoEtiqueta,
        proporcaoChecklist,
        alturaEtiquetaPrincipal,
        alturaChecklist,
        deslocamentoEtiquetaY,
        deslocamentoY,
        novaAlturaChecklist,
        scaleChecklist
      });
      console.groupEnd();

      const extracted = await extractSkuQuantitiesFromCanvas(chkCanvas, { pagina: i + 1, par });


      
            
     // COMBINAÇÃO FINAL: somente a etiqueta principal (sem checklist no PNG final)
const etiquetaCompletaCanvas = document.createElement("canvas");
const paddingX = 0; // margem lateral extra (se quiser)
etiquetaCompletaCanvas.width = colWidth + paddingX * 2;

const ajusteVerticalChecklist = 12; // pequeno espaçamento interno
etiquetaCompletaCanvas.height =
  (alturaEtiquetaPrincipal - deslocamentoEtiquetaY) +
  ajusteVerticalChecklist;

const completoCtx = etiquetaCompletaCanvas.getContext("2d");
completoCtx.imageSmoothingEnabled = true;
completoCtx.imageSmoothingQuality = 'high';

// Desenha somente a etiqueta principal
completoCtx.drawImage(etCanvas, paddingX, 0);


      // Inserção no novo PDF
      const imgBytes = await fetch(etiquetaCompletaCanvas.toDataURL("image/png")).then(res => res.arrayBuffer());
      const imgEmbed = await novoPdf.embedPng(imgBytes);

      // Usando dimensões de página padrão para uma etiqueta
      const larguraPagina = 293.46;
      const alturaPagina = 475.2;
      
      // Adicionamos um fator de escala para diminuir a etiqueta de forma proporcional.
      const scaleFactor = 0.90;
      const larguraEtiquetaFinal = 277 * scaleFactor; 
      const alturaEtiquetaFinal = 449 * scaleFactor;
      
      const margemX = (larguraPagina - larguraEtiquetaFinal) / 2;
      const margemY = (alturaPagina - alturaEtiquetaFinal) / 2;

      // Ajustado a posição vertical para subir a etiqueta e dar espaço para o checklist.
      const ajusteVertical = 20; 
      const yPos = margemY + ajusteVertical;

      // Adiciona uma página para cada etiqueta
      const pag = novoPdf.addPage([larguraPagina, alturaPagina]);

      // Desenha a imagem da etiqueta
      pag.drawImage(imgEmbed, {
        x: margemX,
        y: yPos,
        width: larguraEtiquetaFinal,
        height: alturaEtiquetaFinal,
      });

      // Rodapé textual: agora exibimos SKU e Quantidade em 2 linhas
      const oneLine = (extracted && extracted.footerOneLine)
        ? extracted.footerOneLine
        : (extracted && extracted.items && extracted.items[0]
            ? `SKU: ${extracted.items[0].sku} | Quantidade: ${extracted.items[0].quantidade}`
            : (extracted && extracted.footerLines ? extracted.footerLines[0] : ''));

      // Garante que os dados salvos correspondam ao rodapé final
      let saveSku = '';
      let saveQtd = 0;
      if (oneLine) {
        const mSku = oneLine.match(/SKU\s*:\s*([^|]+?)(?:\s*\||$)/i);
        const mQtd = oneLine.match(/Quantidade\s*:\s*(\d+)/i);
        saveSku = mSku ? mSku[1].trim() : (extracted.items && extracted.items[0] ? extracted.items[0].sku : '');
        saveQtd = mQtd ? parseInt(mQtd[1], 10) || 0 : (extracted.items && extracted.items[0] ? extracted.items[0].quantidade : 0);
      } else if (extracted.items && extracted.items[0]) {
        saveSku = extracted.items[0].sku;
        saveQtd = extracted.items[0].quantidade;
      }
      if (saveSku) {
        allExtractedItems.push({ sku: saveSku, quantidade: saveQtd });
      }

      if (oneLine) {
        const fontSize = 9.5;
        const lineGap = 2;
        const padding = 4;
        // Deriva as duas linhas (SKU e Quantidade) a partir do texto consolidado
        let skuTxt = '';
        let qtdTxt = '';
        const mSku = oneLine.match(/SKU\s*:\s*([^|]+?)(?:\s*\||$)/i);
        const mQtd = oneLine.match(/Quantidade\s*:\s*(\d+)/i);
        skuTxt = mSku ? `SKU: ${mSku[1].trim()}` : oneLine;
        qtdTxt = mQtd ? `Quantidade: ${mQtd[1].trim()}` : '';
        const linhasRodape = [skuTxt, qtdTxt].filter(Boolean);
        const blocoAltura = (fontSize + lineGap) * linhasRodape.length + padding * 2;

        // Preferência: desenhar logo abaixo da etiqueta; se não couber, sobrepor a base da etiqueta
        let footerY = yPos - blocoAltura - 2;
        if (footerY < 2) footerY = yPos; // sem espaço: sobrepõe base da etiqueta

        // Fundo branco para garantir legibilidade
        pag.drawRectangle({
          x: margemX,
          y: footerY,
          width: larguraEtiquetaFinal,
          height: blocoAltura,
          color: PDFLib.rgb(1, 1, 1)
        });

        // Texto em preto (duas linhas: SKU e Quantidade)
        for (let li = 0; li < linhasRodape.length; li++) {
          pag.drawText(linhasRodape[li], {
            x: margemX + 6,
            y: footerY + padding + li * (fontSize + lineGap),
            size: fontSize,
            font: rodapeFont,
            color: PDFLib.rgb(0, 0, 0)
          });
        }
      }
    }
  }

    progressFill.style.width = "100%";
    progressText.textContent = "✅ Concluído!";
    const totalTime = Math.round((Date.now() - startTime) / 1000);
    timerText.textContent = `Concluído em: ${formatTime(totalTime)}`;
    setTimeout(() => {
      progressBar.style.display = "none";
    }, 2000);
  const pdfFinal = await novoPdf.save();
  const blob = new Blob([pdfFinal], { type: "application/pdf" });
  const fileName = `etiquetas_editadas_${Date.now()}.pdf`;
  const localUrl = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = localUrl;
  a.download = fileName;
  a.click();

  status.textContent = "📤 Enviando ao servidor...";
  uploadPdfToFirebase(blob, fileName, allExtractedItems)
    .then(() => {
      status.textContent = "✅ PDF gerado com sucesso! Concluído.";
    })
    .catch(() => {
      status.textContent = "⚠️ PDF gerado, mas houve erro no envio.";
    });
    }

    window.processar = processar;
    async function processarMercadoLivre() {
      const progressBar = document.getElementById("progressBar");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const timerText = document.getElementById("timerText");
      progressBar.style.display = "block";
      progressFill.style.width = "0%";
      progressText.textContent = "";
      timerText.textContent = "";
      const startTime = Date.now();

      const status = document.getElementById("status");
      const pdfFile = document.getElementById("pdfInput").files[0];
      if (!pdfFile) {
        progressBar.style.display = "none";
        return showMessage("Envie o arquivo PDF.");
      }

      status.textContent = "📸 Lendo PDF Mercado Livre...";
      const arrayBuffer = await pdfFile.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const canvas = document.getElementById("pdfCanvas");
      const ctx = canvas.getContext("2d");
      canvas.style.display = "block";
      const allItems = [];
      updateProgress(0, pdf.numPages, startTime, progressFill, progressText, timerText);

      for (let i = 0; i < pdf.numPages; i++) {
        const page = await pdf.getPage(i + 1);
        const scale = 3;
        const viewport = page.getViewport({ scale });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: ctx, viewport }).promise;
        updateProgress(i + 1, pdf.numPages, startTime, progressFill, progressText, timerText);
        const data = await extractMercadoLivreData(canvas);
        if (data.sku) allItems.push(data);
      }

      progressFill.style.width = "100%";
      progressText.textContent = "✅ Concluído!";
      const totalTime = Math.round((Date.now() - startTime) / 1000);
      timerText.textContent = `Concluído em: ${formatTime(totalTime)}`;
      setTimeout(() => { progressBar.style.display = "none"; }, 2000);

      if (currentUser) {
        const gestoresRaw = document.getElementById('gestoresEmails').value || '';
        const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
        const fileName = `mercado_livre_${Date.now()}.pdf`;
        const selecionado = await escolherGestorEmail(gestoresEmails);
        const docRef = await db.collection('pdfDocs').add({
          ownerUid: currentUser.uid,
          ownerEmail: currentUser.email,
          gestoresExpedicaoEmails: selecionado,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          name: fileName,
          foraHorario: foraDoHorario()
        });
        const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
        await fileRef.put(pdfFile);
        const url = await fileRef.getDownloadURL();
        await docRef.update({ url: url, storagePath: fileRef.fullPath });
        const record = {
          name: fileName,
          url: url,
          path: fileRef.fullPath,
          createdAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
        if (responsavelExpedicaoUid) {
          const respRecord = {
            name: fileName,
            url: url,
            path: fileRef.fullPath,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          };
          await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
        }
      }

      await savePrintedSkuQuantities(allItems);
      status.textContent = "✅ Etiquetas Mercado Livre processadas! Concluído.";
    }

    window.processarMercadoLivre = processarMercadoLivre;
    </script>

  <script src="shared.js"></script>
</body>
</html>

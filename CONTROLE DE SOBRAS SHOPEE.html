<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sistema de Sobras - Shopee Premium</title>
  
  <!-- Fontes Google -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Bibliotecas CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="css/styles.css?v=20240826">
<link rel="stylesheet" href="css/tabs-mobile.css?v=20240826">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <!-- Bibliotecas JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/pt.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" integrity="sha512-q+4liFwdPC/bNdhUpZx6aXDx/h77yEQtn4I1slHydcbZK34nLaR3cAeYSJshoxIOq3mjEf7xJE8YWIUHMn+oCQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script type="module" src="firebase-config.js"></script>


</head>
<body class="bg-gray-50">
  <div class="app-container">
    <!-- Sidebar -->
  <div id="sidebar-container"></div>



<!-- Top Navbar -->
  <div id="navbar-container"></div>


    <!-- Conteúdo Principal -->
    <div class="main-content space-y-10">
      <div class="page-title">
        <i class="fas fa-check-circle"></i>
        <h1>Vendedor Pro - Vendas e Faturamento</h1>
      </div>

      <div class="alert-container">
        <div id="alertSuccess" class="alert alert-success" role="status" style="display: none;">
          <i class="fas fa-check-circle"></i>
          <div class="alert-content"></div>
          <button type="button" class="alert-close" aria-label="Fechar alerta de sucesso">
            <i class="fas fa-times"></i>
          </button>
        </div>

        <div id="alertError" class="alert alert-error" role="alert" style="display: none;">
          <i class="fas fa-triangle-exclamation"></i>
          <div class="alert-content"></div>
          <button type="button" class="alert-close" aria-label="Fechar alerta de erro">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>


      <div id="firebase-error" class="card" style="display: none;">
        <div class="card-header">
          <i class="fas fa-exclamation-triangle"></i>
          <h3>Erro de Conexão com o Firebase</h3>
        </div>
        <p id="error-message" style="margin-bottom: 1rem;"></p>
        <button onclick="verificarConexao()" class="btn btn-primary">
          <i class="fas fa-sync-alt"></i> Tentar Reconectar
        </button>
      </div>
      
      <!-- Tab bar removida -->

      <!-- Aba de Importação/Conferência -->
      <div id="importar" class="tab-content active">
 
      </div>

      <!-- Aba de Metas -->
      <div id="metas" class="tab-content">
          </div>

      

      <!-- Aba de Gráficos -->
      <div id="graficos" class="tab-content">
     
      </div>

      <!-- Aba de Histórico -->
      <div id="historico" class="tab-content">
    
      </div>
      
      <!-- Aba de Faturamento -->
      <div id="faturamento" class="tab-content">

      </div>

      <!-- Aba de Vendas Mercado Livre -->
      <div id="vendasML" class="tab-content">

      </div>

      <!-- Aba de Registro de Faturamento -->
      <div id="registroFaturamento" class="tab-content">

      </div>

      <!-- Aba de Controle de Vendas -->
      <div id="controleVendas" class="tab-content">

      </div>

      <!-- Aba de Produtos Vendidos (Gestores/Responsáveis Financeiros) -->
      <div
        id="produtosVendidos"
        class="tab-content"
        data-perfil="gestor,responsavel,gestor financeiro,responsavel financeiro"
      >

      </div>

      <!-- Aba de Sobras -->
      <div id="sobras" class="tab-content">

      </div>

      <!-- Aba de Previsão -->
      <div id="previsao" class="tab-content">

      </div>

      <!-- Aba de Acompanhamento -->
      <div id="acompanhamento" class="tab-content">

      </div>
      <!-- Aba de Acompanhamento Diário -->
      <div id="diariamente" class="tab-content">

      </div>
      <!-- Aba de VTS -->
      <div id="vts" class="tab-content">

      </div>
      <!-- Aba de Acompanhamento Sobras (Gestor) -->
      <div id="acompanhamentoGestor" class="tab-content">

      </div>
      <!-- Aba de Acompanhamento Diário (Gestor/Responsável) -->
      <div
        id="diariamenteGestor"
        class="tab-content"
        data-perfil="gestor,responsavel,gestor financeiro,responsavel financeiro"
      >

      </div>
    </div>
  </div>

  <!-- Status de conexão -->
  <div id="connectionStatus" class="connection-status offline">
    <div class="status-dot"></div>
    <span>Offline - Trabalhando localmente</span>
  </div>

<script type="module">
    import { firebaseConfig } from './firebase-config.js';
    import { parseMagalu } from './parser-magalu.js';
    import { parseShopeePage } from './parser-shopee.js';
  // =============================================
    // CONFIGURAÇÃO INICIAL E VARIÁVEIS GLOBAIS
    // =============================================
    // Variáveis globais
    let db;
    let metas = {};
    let metasNormalizadas = {};
    let historico = [];
    let produtos = {};
        let dadosAcompanhamento = [];
    let sobraPorSku = {};
      let resumoSku = {};
      let produtosVendidosResumo = [];
      let produtosVendidosCarregado = false;
      let produtosVendidosCarregando = false;
      let totalSaquesAcompanhamento = 0;
      let totalComissaoAcompanhamento = 0;
      let totalComissaoPagaAcompanhamento = 0;
      let totalComissaoAPagarAcompanhamento = 0;
      let usuarioLogado = { uid: null, perfil: '' };
      window.usuarioLogado = usuarioLogado;
let pedidosProcessados = [];
let resultadosConferenciaComissao = [];
let graficoBarras, graficoPizza, graficoPrevisao;
let previsaoDados = {};
let initialTab = null;
const API_URL = 'https://us-central1-matheus-35023.cloudfunctions.net/proxyDeepSeek';
const controleVendasSelecao = new Map();
const controleVendasBaseCache = new Map();
let controleVendasEventosRegistrados = false;

const referenciaFaixaConfig = {
  minima: {
    cssClass: 'referencia-minima',
    excelColor: 'FFF8D7DA',
    pdfColor: [248, 215, 218]
  },
  media: {
    cssClass: 'referencia-media',
    excelColor: 'FFFFF3CD',
    pdfColor: [255, 243, 205]
  },
  maxima: {
    cssClass: 'referencia-maxima',
    excelColor: 'FFD4EDDA',
    pdfColor: [212, 237, 218]
  }
};

function identificarTipoReferenciaFaixa(rotulo = '') {
  const textoNormalizado = rotulo
    .toString()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase();

  if (textoNormalizado.includes('referencia minima')) return 'minima';
  if (textoNormalizado.includes('referencia media')) return 'media';
  if (textoNormalizado.includes('referencia maxima')) return 'maxima';
  return null;
}

function obterConfiguracaoReferenciaFaixa(rotulo, tipoReferencia) {
  const chave = tipoReferencia || identificarTipoReferenciaFaixa(rotulo);
  return chave ? referenciaFaixaConfig[chave] : null;
}

const gerarChaveSkuNormalizada = (valor) =>
  String(valor ?? '')
    .trim()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]+/g, '')
    .toLowerCase();

const registrarMetaNormalizada = (sku, dadosMeta) => {
  const chave = gerarChaveSkuNormalizada(sku);
  if (!chave) return;
  metasNormalizadas[chave] = { skuOriginal: sku, meta: dadosMeta };
};

const removerMetaNormalizada = (sku) => {
  const chave = gerarChaveSkuNormalizada(sku);
  if (!chave) return;
  delete metasNormalizadas[chave];
};

const obterMetaSku = (sku) => {
  if (sku === undefined || sku === null) return null;
  const chaveOriginal = String(sku).trim();
  if (!chaveOriginal) return null;
  if (metas[chaveOriginal]) return metas[chaveOriginal];
  const chaveNormalizada = gerarChaveSkuNormalizada(chaveOriginal);
  return metasNormalizadas[chaveNormalizada]?.meta || null;
};

if (window.pdfjsLib?.GlobalWorkerOptions) {
  window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
}

let vtsEtiquetasRegistros = [];
let vtsCarregado = false;
let vtsUltimoDiagnostico = [];
let vtsUltimoArquivo = '';
let vtsUltimoModelo = '';
let vtsSkuAssociacoes = [];
let vtsSkuMapa = new Map();
let vtsSkuEdicaoAtual = null;
let vtsFiltroDataInicio = '';
let vtsFiltroDataFim = '';
let vtsFiltroDataColocadaInicio = '';
let vtsFiltroDataColocadaFim = '';
let vtsFiltroLoja = '';
let vtsEtiquetasSelecionadas = new Set();
let vtsResumoDadosExportacao = [];
let vtsResumoTotaisExportacao = { vendido: 0, cancelado: 0, esperado: 0 };

const VTS_DEVOLUCAO_HEADER_CANDIDATOS = Object.freeze([
  'rastreio',
  'codigorastreio',
  'codigoderastreio',
  'codigo',
  'codigodeenvio',
  'codigodevolucao',
  'tracking',
  'trackingcode',
  'awb',
  'codigoobjeto',
  'objeto',
  'codigopostagem',
  'codigopostal',
]);

const VTS_MODELOS_CONFIG = Object.freeze({
  mercadoLivre: {
    inputId: 'vtsPdfInput',
    buttonId: 'vtsProcessarBtn',
    nome: 'Mercado Livre',
  },
  shopee: {
    inputId: 'vtsPdfInputShopee',
    buttonId: 'vtsProcessarBtnShopee',
    nome: 'Shopee',
  },
  magalu: {
    inputId: 'vtsPdfInputMagalu',
    buttonId: 'vtsProcessarBtnMagalu',
    nome: 'Magalu',
  },
});

const VTS_PLANILHA_COLUNAS = Object.freeze([
  { chave: 'sku', rotulo: 'SKU', obrigatorio: true },
  { chave: 'pedido', rotulo: 'Número do pedido', obrigatorio: true },
  { chave: 'rastreio', rotulo: 'Código de rastreio', obrigatorio: false },
  { chave: 'loja', rotulo: 'Loja', obrigatorio: false },
  { chave: 'dataEtiqueta', rotulo: 'Data da etiqueta (AAAA-MM-DD)', obrigatorio: false },
  { chave: 'dataEtiquetaTexto', rotulo: 'Data original informada', obrigatorio: false },
  { chave: 'origemArquivo', rotulo: 'Arquivo de origem', obrigatorio: false },
  { chave: 'modeloEtiqueta', rotulo: 'Modelo da etiqueta', obrigatorio: false },
  { chave: 'buyerUsername', rotulo: 'Usuário comprador', obrigatorio: false },
]);

const VTS_PLANILHA_HEADER_NORMALIZADO = Object.freeze(
  VTS_PLANILHA_COLUNAS.reduce((acc, coluna) => {
    acc[coluna.chave] = normalizeHeaderKey(coluna.rotulo);
    return acc;
  }, {}),
);

const VTS_SKU_PLANILHA_COLUNAS = Object.freeze([
  { chave: 'skuPrincipal', rotulo: 'SKU principal' },
  { chave: 'associados', rotulo: 'SKUs associados' },
  { chave: 'sobraEsperada', rotulo: 'Sobra esperada' },
]);

const VTS_SKU_PLANILHA_HEADER_NORMALIZADO = Object.freeze(
  VTS_SKU_PLANILHA_COLUNAS.reduce((acc, coluna) => {
    acc[coluna.chave] = normalizeHeaderKey(coluna.rotulo);
    return acc;
  }, {}),
);

const VTS_SKU_PLANILHA_HEADER_MAP = Object.freeze(
  Object.entries(VTS_SKU_PLANILHA_HEADER_NORMALIZADO).reduce((acc, [chave, normalizado]) => {
    acc[normalizado] = chave;
    return acc;
  }, {}),
);

function normalizeDate(value) {
  if (!value) return '';
  if (value instanceof Date && !isNaN(value)) return value.toISOString().split('T')[0];

  const str = String(value).trim();
  if (!str) return '';

  const directDate = new Date(str);
  if (!isNaN(directDate)) return directDate.toISOString().split('T')[0];

  const brMatch = str.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
  if (brMatch) {
    const dia = brMatch[1].padStart(2, '0');
    const mes = brMatch[2].padStart(2, '0');
    const ano = brMatch[3];
    return `${ano}-${mes}-${dia}`;
  }

  const isoMatch = str.match(/\d{4}-\d{2}-\d{2}/);
  if (isoMatch) return isoMatch[0];

  const sanitized = str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\bhs\b\.?/gi, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();

  const months = {
    janeiro: '01',
    fevereiro: '02',
    marco: '03',
    abril: '04',
    maio: '05',
    junho: '06',
    julho: '07',
    agosto: '08',
    setembro: '09',
    outubro: '10',
    novembro: '11',
    dezembro: '12'
  };

  const ptMatch = sanitized.match(/(\d{1,2})\s+de\s+([a-z]+)\s+de\s+(\d{4})(?:\s+(\d{1,2}:\d{2}))?/);
  if (ptMatch) {
    const dia = ptMatch[1].padStart(2, '0');
    const mes = months[ptMatch[2]];
    const ano = ptMatch[3];
    if (mes) {
      return `${ano}-${mes}-${dia}`;
    }
  }

  return '';
}

function parseDiasInformados(valor) {
  const dias = [];
  if (Array.isArray(valor)) {
    for (const item of valor) {
      const normalizado = normalizeDate(item);
      if (normalizado) dias.push(normalizado);
    }
  } else if (typeof valor === 'string') {
    const partes = valor
      .split(/[,;\n]+/)
      .map(parte => normalizeDate(parte))
      .filter(Boolean);
    dias.push(...partes);
  }

  const unicos = [];
  for (const dia of dias) {
    if (!unicos.includes(dia)) {
      unicos.push(dia);
    }
  }
  return unicos;
}

function normalizeHeaderKey(key) {
  return String(key || '')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]/g, '')
    .toLowerCase();
}

function gerarTimestampArquivoVts() {
  const agora = new Date();
  const pad = (valor) => String(valor).padStart(2, '0');
  return `${agora.getFullYear()}${pad(agora.getMonth() + 1)}${pad(agora.getDate())}-${pad(agora.getHours())}${pad(
    agora.getMinutes(),
  )}${pad(agora.getSeconds())}`;
}

function buildHeaderMap(row) {
  return Object.keys(row || {}).reduce((acc, original) => {
    acc[normalizeHeaderKey(original)] = original;
    return acc;
  }, {});
}

function getFieldByKey(row, headerMap, normalizedKey) {
  if (!row || !headerMap) return undefined;
  const actual = headerMap[normalizedKey];
  return actual !== undefined ? row[actual] : undefined;
}

function parseNumber(value) {
  if (typeof value === 'number') {
    if (Number.isFinite(value)) return value;
    return 0;
  }
  if (value === null || value === undefined) return 0;
  const normalized = String(value)
    .replace(/[^0-9,.-]/g, '')
    .replace(/\.(?=\d{3}(?:\D|$))/g, '')
    .replace(',', '.');
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : 0;
}

const makeSkuDocId = (sku) => encodeURIComponent(String(sku ?? '').trim());
const makeLegacySkuDocId = (sku) =>
  String(sku ?? '')
    .trim()
    .replace(/[.#$\/\[\]]/g, '_');

let cacheNomeUsuario = null;

function formatarMesReferencia(anoMes) {
  if (!anoMes) return '';
  const [ano, mes] = String(anoMes).split('-');
  if (!ano || !mes) return anoMes;
  const anoNumero = Number(ano);
  const mesNumero = Number(mes) - 1;
  if (!Number.isInteger(anoNumero) || !Number.isInteger(mesNumero) || mesNumero < 0) {
    return anoMes;
  }
  const data = new Date(anoNumero, mesNumero, 1);
  if (Number.isNaN(data.getTime())) return anoMes;
  return new Intl.DateTimeFormat('pt-BR', {
    month: 'long',
    year: 'numeric'
  }).format(data);
}

function obterDataIsoHoje() {
  const hoje = new Date();
  const ano = hoje.getFullYear();
  const mes = String(hoje.getMonth() + 1).padStart(2, '0');
  const dia = String(hoje.getDate()).padStart(2, '0');
  return `${ano}-${mes}-${dia}`;
}

function obterMesIsoAtual() {
  const hoje = new Date();
  const ano = hoje.getFullYear();
  const mes = String(hoje.getMonth() + 1).padStart(2, '0');
  return `${ano}-${mes}`;
}

function obterSemanaIso(date) {
  const data = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
  const diaSemana = data.getUTCDay() || 7;
  data.setUTCDate(data.getUTCDate() + 4 - diaSemana);
  const ano = data.getUTCFullYear();
  const inicioAno = new Date(Date.UTC(ano, 0, 1));
  const semana = Math.ceil(((data - inicioAno) / 86400000 + 1) / 7);
  return { ano, semana };
}

function obterSemanaIsoAtual() {
  const { ano, semana } = obterSemanaIso(new Date());
  return `${ano}-W${String(semana).padStart(2, '0')}`;
}

function calcularIntervaloSemana(semanaIso) {
  if (!semanaIso || typeof semanaIso !== 'string' || !semanaIso.includes('-W')) {
    return null;
  }

  const [anoStr, semanaStr] = semanaIso.split('-W');
  const ano = Number(anoStr);
  const semana = Number(semanaStr);

  if (!Number.isInteger(ano) || !Number.isInteger(semana) || semana <= 0 || semana > 53) {
    return null;
  }

  const janQuatro = new Date(Date.UTC(ano, 0, 4));
  const diaJanQuatro = janQuatro.getUTCDay() || 7;
  const primeiraSegunda = new Date(janQuatro);
  primeiraSegunda.setUTCDate(janQuatro.getUTCDate() - (diaJanQuatro - 1));

  const inicio = new Date(primeiraSegunda);
  inicio.setUTCDate(primeiraSegunda.getUTCDate() + (semana - 1) * 7);

  const fim = new Date(inicio);
  fim.setUTCDate(inicio.getUTCDate() + 6);

  const formatar = (data) => data.toISOString().slice(0, 10);

  return {
    inicio: formatar(inicio),
    fim: formatar(fim),
  };
}

function formatarNumeroPadrao(valor) {
  const numero = Number(valor) || 0;
  return new Intl.NumberFormat('pt-BR').format(numero);
}

function formatarPercentualPadrao(valor) {
  if (valor === null || valor === undefined || Number.isNaN(Number(valor))) {
    return '-';
  }
  const numero = Number(valor);
  return `${numero.toFixed(2)}%`;
}

async function obterNomeUsuarioAtual() {
  if (cacheNomeUsuario) return cacheNomeUsuario;
  const fallback = (usuarioLogado?.email || usuarioLogado?.uid || 'Usuário').trim();
  if (!usuarioLogado?.uid || !db) {
    cacheNomeUsuario = fallback;
    return cacheNomeUsuario;
  }
  try {
    const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
    const dados = usuarioDoc.exists ? usuarioDoc.data() || {} : {};
    const nome = String(dados.nome || '').trim();
    cacheNomeUsuario = nome || fallback;
  } catch (error) {
    console.error('Erro ao obter nome do usuário para o relatório:', error);
    cacheNomeUsuario = fallback;
  }
  return cacheNomeUsuario;
}

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function gerarIdDiario(data, plataforma, loja) {
  const baseLoja = String(loja || 'loja')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();
  const segmentoLoja = baseLoja || 'loja';
  const segmentoPlataforma = String(plataforma || 'plataforma')
    .replace(/[^a-zA-Z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase() || 'plataforma';
  return `${data}_${segmentoPlataforma}_${segmentoLoja}`;
}

function gerarIdDiarioTurno(data, plataforma, loja, momento) {
  const base = gerarIdDiario(data, plataforma, loja);
  const turno = (momento || '').toString().trim().toLowerCase();
  if (!turno) return `${base}__turno`;
  return `${base}__${turno}`;
}

async function obterBasesUsuario() {
  const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
  const dadosUsuario = usuarioDoc.data() || {};
  const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
  let baseResp = null;
  if (respEmail) {
    try {
      const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
      if (!respSnap.empty) {
        const respDoc = respSnap.docs[0];
        const respData = respDoc.data() || {};
        const responsavelUid = respData.uid || respDoc.id;
        baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
      }
    } catch (err) {
      console.error('Erro ao buscar responsável financeiro', err);
    }
  }

  const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
    ? dadosUsuario.gestoresExpedicaoEmails[0]
    : dadosUsuario.responsavelExpedicaoEmail || null;
  let baseExp = null;
  if (gestorEmail) {
    try {
      const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
      if (!expSnap.empty) {
        const expDoc = expSnap.docs[0];
        const expData = expDoc.data() || {};
        const gestorUid = expData.uid || expDoc.id;
        baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
      }
    } catch (err) {
      console.error('Erro ao buscar base do gestor de expedição', err);
    }
  }

  return { dadosUsuario, respEmail, baseResp, gestorEmail, baseExp };
}

async function processarPlanilhaVendas({
  rows,
  dataReferencia,
  loja,
  plataforma,
  resultadoId,
  progressIds = {},
  rowParser,
  datasInformadas = []
}) {
  const { containerId, barId, textId } = progressIds || {};
  const progressContainer = containerId ? document.getElementById(containerId) : null;
  const progressBar = barId ? document.getElementById(barId) : null;
  const progressText = textId ? document.getElementById(textId) : null;

  if (progressContainer) progressContainer.classList.remove('hidden');
  if (progressBar) progressBar.style.width = '0%';
  if (progressText) progressText.textContent = '0%';

  const { baseResp, respEmail, gestorEmail, baseExp } = await obterBasesUsuario();
  const { encryptString, decryptString } = await import('./crypto.js');
  const pass = getPassphrase() || usuarioLogado.uid;
  const diasInformados = parseDiasInformados(datasInformadas);

  const ref = db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('faturamento')
    .doc(dataReferencia)
    .collection('lojas')
    .doc(loja);

  const doc = await ref.get();
  let operacao = 'substituir';
  let dadosAnteriores = null;

  if (doc.exists) {
    const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
      title: 'Registro existente',
      text: `Já existe um registro para ${loja} em ${dataReferencia}. O que deseja fazer?`,
      showDenyButton: true,
      showCancelButton: true,
      confirmButtonText: 'Substituir',
      denyButtonText: 'Somar',
      cancelButtonText: 'Pular'
    });
    if (!substituir && !somar) {
      if (progressContainer) progressContainer.classList.add('hidden');
      return null;
    }
    operacao = somar ? 'somar' : 'substituir';
    const docData = doc.data();
    if (docData?.encrypted) {
      try {
        dadosAnteriores = JSON.parse(await decryptString(docData.encrypted, pass));
      } catch (err) {
        console.error('Erro ao descriptografar faturamento existente', err);
      }
    } else {
      dadosAnteriores = docData;
    }
  }

  let bruto = 0;
  let liquidoTotal = 0;
  let qtdVendas = 0;
  const skusVendidos = {};
  const faturamentoPorDia = {};
  const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
  const totalRows = rows.length;
  let processedRows = 0;

  const updateProgress = async () => {
    if (!progressBar || !progressText) return;
    const pct = totalRows ? Math.round((processedRows / totalRows) * 100) : 0;
    progressBar.style.width = pct + '%';
    progressText.textContent = pct + '%';
    if (processedRows % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0));
  };

  for (const row of rows) {
    const parsed = typeof rowParser === 'function' ? rowParser(row, { dataReferencia }) : null;
    if (!parsed || !parsed.numeroVenda) {
      processedRows++;
      await updateProgress();
      continue;
    }

    const {
      numeroVenda,
      estado = '',
      sku = '',
      unidades,
      receitaProdutos = 0,
      receitaAcrescimo = 0,
      receitaEnvio = 0,
      taxaParcelamento = 0,
      tarifaVenda = 0,
      tarifasEnvio = 0,
      cancelamentos = 0,
      totalLinha,
      dataVenda: dataVendaOriginal,
      ativo: ativoOverride,
      extrasPedido = {}
    } = parsed;

    const unidadesNumero = Number.isFinite(unidades) ? unidades : parseNumber(unidades);
    const brutoLinha = Number(receitaProdutos || 0) + Number(receitaAcrescimo || 0) + Number(receitaEnvio || 0);
    const liquidoCalculado = brutoLinha - (Number(taxaParcelamento || 0) + Number(tarifaVenda || 0) + Number(tarifasEnvio || 0) + Math.abs(Number(cancelamentos || 0)));
    const liquidoLinha = Number.isFinite(totalLinha) ? Number(totalLinha) : liquidoCalculado;
    const taxasLinha = Math.max(0, brutoLinha - liquidoLinha);
    const dataVenda = normalizeDate(dataVendaOriginal) || dataReferencia;

    const statusLower = String(estado || '').toLowerCase();
    const ativo = typeof ativoOverride === 'boolean'
      ? ativoOverride
      : !(statusLower.includes('cancel') || statusLower.includes('devol') || statusLower.includes('reemb'));

    if (ativo) {
      bruto += brutoLinha;
      liquidoTotal += liquidoLinha;
      qtdVendas += 1;
      if (sku) {
        if (!skusVendidos[sku]) skusVendidos[sku] = { total: 0, valorLiquido: 0 };
        skusVendidos[sku].total += 1;
        skusVendidos[sku].valorLiquido += liquidoLinha;
      }
      const diaResumo = dataVenda || dataReferencia;
      if (diaResumo) {
        if (!faturamentoPorDia[diaResumo]) {
          faturamentoPorDia[diaResumo] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[diaResumo].bruto += brutoLinha;
        faturamentoPorDia[diaResumo].liquido += liquidoLinha;
        faturamentoPorDia[diaResumo].vendas += 1;
      }
    }

    const extrasLimpos = {};
    if (extrasPedido && typeof extrasPedido === 'object') {
      for (const [key, value] of Object.entries(extrasPedido)) {
        if (value !== undefined) extrasLimpos[key] = value;
      }
    }

    const pedidoPayload = {
      pedidoId: numeroVenda,
      numeroVenda,
      status: estado,
      sku,
      loja,
      data: dataReferencia,
      dataVenda,
      horaPagamento: dataVenda,
      unidades: Number.isFinite(unidadesNumero) ? unidadesNumero : 0,
      subtotal: brutoLinha,
      taxas: taxasLinha,
      liquido: liquidoLinha,
      receitaProdutos,
      receitaAcrescimoPreco: receitaAcrescimo,
      receitaEnvio,
      taxaParcelamentoAcrescimo: taxaParcelamento,
      tarifasEnvio,
      tarifaVendaImpostos: tarifaVenda,
      cancelamentosReembolsos: cancelamentos,
      total: Number.isFinite(totalLinha) ? Number(totalLinha) : liquidoLinha,
      plataforma,
      ...extrasLimpos
    };

    const pedidoDocRef = pedidosRef
      .doc(dataReferencia)
      .collection('lista')
      .doc(numeroVenda);
    const pedidoDoc = await pedidoDocRef.get();
    let needsUpdate = true;
    if (pedidoDoc.exists) {
      try {
        const atual = JSON.parse(await decryptString(pedidoDoc.data().encrypted, pass));
        if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
          needsUpdate = false;
        }
      } catch (err) {
        console.error('Erro ao comparar pedido existente', err);
      }
    }
    if (needsUpdate) {
      const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
      await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
      if (baseResp && respEmail) {
        const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
        await baseResp
          .collection('pedidosreais')
          .doc(dataReferencia)
          .collection('lista')
          .doc(numeroVenda)
          .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
      }
      if (baseExp && gestorEmail) {
        const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
        await baseExp
          .collection('pedidosreais')
          .doc(dataReferencia)
          .collection('lista')
          .doc(numeroVenda)
          .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
      }
    }

    processedRows++;
    await updateProgress();
  }

  if (operacao === 'somar' && dadosAnteriores) {
    bruto += Number(dadosAnteriores.valorBruto || 0);
    liquidoTotal += Number(dadosAnteriores.valorLiquido || 0);
    qtdVendas += Number(dadosAnteriores.qtdVendas || 0);
    if (Array.isArray(dadosAnteriores.resumoPorDia)) {
      for (const diaAnterior of dadosAnteriores.resumoPorDia) {
        const chaveDia =
          diaAnterior?.data ||
          diaAnterior?.dia ||
          diaAnterior?.dataVenda ||
          dadosAnteriores.data ||
          dataReferencia;
        if (!chaveDia) continue;
        if (!faturamentoPorDia[chaveDia]) {
          faturamentoPorDia[chaveDia] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[chaveDia].bruto += Number(diaAnterior.valorBruto || diaAnterior.bruto || 0);
        faturamentoPorDia[chaveDia].liquido += Number(diaAnterior.valorLiquido || diaAnterior.liquido || 0);
        faturamentoPorDia[chaveDia].vendas += Number(
          diaAnterior.vendas ||
          diaAnterior.qtdVendas ||
          diaAnterior.quantidade ||
          0
        );
      }
    } else {
      const chaveDiaAnterior = dadosAnteriores.data || dataReferencia;
      if (chaveDiaAnterior) {
        if (!faturamentoPorDia[chaveDiaAnterior]) {
          faturamentoPorDia[chaveDiaAnterior] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[chaveDiaAnterior].bruto += Number(dadosAnteriores.valorBruto || 0);
        faturamentoPorDia[chaveDiaAnterior].liquido += Number(dadosAnteriores.valorLiquido || 0);
        faturamentoPorDia[chaveDiaAnterior].vendas += Number(
          dadosAnteriores.qtdVendas ||
          dadosAnteriores.vendas ||
          0
        );
      }
    }
  }

  const taxas = Math.max(0, bruto - liquidoTotal);

  const resumoPorDia = Object.entries(faturamentoPorDia)
    .map(([dia, valores]) => {
      const brutoDia = Number(valores?.bruto || 0);
      const liquidoDia = Number(valores?.liquido || 0);
      return {
        data: dia,
        valorBruto: brutoDia,
        valorLiquido: liquidoDia,
        taxas: Math.max(0, brutoDia - liquidoDia),
        vendas: Number(valores?.vendas || 0)
      };
    })
    .sort((a, b) => new Date(a.data) - new Date(b.data));

  const periodoResumo =
    resumoPorDia.length > 0
      ? { inicio: resumoPorDia[0].data, fim: resumoPorDia[resumoPorDia.length - 1].data }
      : { inicio: dataReferencia, fim: dataReferencia };

  const resumoPedidos = {
    data: dataReferencia,
    loja,
    plataforma,
    atualizadoEm:
      typeof firebase !== 'undefined' && firebase.firestore?.FieldValue?.serverTimestamp
        ? firebase.firestore.FieldValue.serverTimestamp()
        : new Date().toISOString(),
    totalLinhas: totalRows,
    totalPedidosAtivos: qtdVendas,
    valorBruto: bruto,
    valorLiquido: liquidoTotal,
    taxas,
    diasInformados
  };

  await pedidosRef.doc(dataReferencia).set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp && respEmail) {
    await baseResp
      .collection('pedidosreais')
      .doc(dataReferencia)
      .set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  }
  if (baseExp && gestorEmail) {
    await baseExp
      .collection('pedidosreais')
      .doc(dataReferencia)
      .set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  }

  const refSku = db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('skusVendidos')
    .doc(dataReferencia);
  await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp) {
    await baseResp
      .collection('skusVendidos')
      .doc(dataReferencia)
      .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
  }

  for (const [skuItem, dadosSku] of Object.entries(skusVendidos)) {
    const skuId = makeSkuDocId(skuItem);
    const legacySkuId = makeLegacySkuDocId(skuItem);
    const listaCollection = db
      .collection('uid')
      .doc(usuarioLogado.uid)
      .collection('skusVendidos')
      .doc(dataReferencia)
      .collection('lista');
    const docRef = listaCollection.doc(skuId);
    const docSnap = await docRef.get();

    let totalFinal = dadosSku.total;
    let valorLiquidoFinal = dadosSku.valorLiquido;
    if (docSnap.exists) {
      const dadosAnterioresSku = docSnap.data();
      totalFinal += dadosAnterioresSku.total || 0;
      valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
    } else if (legacySkuId !== skuId) {
      const legacyDocRef = listaCollection.doc(legacySkuId);
      const legacySnap = await legacyDocRef.get();
      if (legacySnap.exists) {
        const dadosAnterioresSku = legacySnap.data();
        totalFinal += dadosAnterioresSku.total || 0;
        valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
        try {
          await legacyDocRef.delete();
        } catch (err) {
          console.warn('Não foi possível remover SKU legado', legacySkuId, err);
        }
      }
    }

    await docRef.set({
      sku: skuItem,
      total: totalFinal,
      valorLiquido: valorLiquidoFinal,
      data: dataReferencia,
      loja,
      uid: usuarioLogado.uid
    });

    if (baseResp && respEmail) {
      const skuPayload = {
        sku: skuItem,
        total: totalFinal,
        valorLiquido: valorLiquidoFinal,
        data: dataReferencia,
        loja,
        uid: usuarioLogado.uid
      };
      const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
      const baseRespLista = baseResp
        .collection('skusVendidos')
        .doc(dataReferencia)
        .collection('lista');
      await baseRespLista.doc(skuId).set({ encrypted: encSku, uid: usuarioLogado.uid });
    }

    if (baseExp && gestorEmail) {
      const skuPayload = {
        sku: skuItem,
        total: totalFinal,
        valorLiquido: valorLiquidoFinal,
        data: dataReferencia,
        loja,
        uid: usuarioLogado.uid
      };
      const encSku = await encryptString(JSON.stringify(skuPayload), gestorEmail);
      const baseExpLista = baseExp
        .collection('skusVendidos')
        .doc(dataReferencia)
        .collection('lista');
      await baseExpLista.doc(skuId).set({ encrypted: encSku, uid: usuarioLogado.uid });
    }
  }

  if (progressBar && progressText) {
    progressBar.style.width = '100%';
    progressText.textContent = '100%';
  }

  const lojaPayload = {
    valorBruto: bruto,
    taxasPlataforma: taxas,
    valorLiquido: liquidoTotal,
    qtdVendas,
    loja,
    atualizadoEm: new Date(),
    uid: usuarioLogado.uid,
    diasInformados
  };
  const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
  await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
  if (baseResp && respEmail) {
    const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
    await baseResp
      .collection('faturamento')
      .doc(dataReferencia)
      .collection('lojas')
      .doc(loja)
      .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
  }

  const resumoPayload = {
    valorBruto: bruto,
    valorLiquido: liquidoTotal,
    taxasPlataforma: taxas,
    vendas: qtdVendas,
    plataforma,
    atualizadoEm: new Date(),
    uid: usuarioLogado.uid,
    resumoPorDia,
    periodoVendas: periodoResumo,
    diasInformados
  };
  const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
  await db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('faturamento')
    .doc(dataReferencia)
    .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp && respEmail) {
    const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
    await baseResp
      .collection('faturamento')
      .doc(dataReferencia)
      .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
  }

  await notificarResponsavelFinanceiro(dataReferencia, loja, bruto, liquidoTotal, qtdVendas);

  if (resultadoId) {
    const resultado = document.getElementById(resultadoId);
    if (resultado) {
      const formatCurrency = (valor) =>
        Number(valor || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
      const formatDateBr = (iso) => {
        if (!iso || typeof iso !== 'string') return iso || '';
        const partes = iso.split('-');
        if (partes.length !== 3) return iso;
        return `${partes[2]}/${partes[1]}/${partes[0]}`;
      };
      const periodoTexto =
        periodoResumo.inicio === periodoResumo.fim
          ? formatDateBr(periodoResumo.inicio)
          : `${formatDateBr(periodoResumo.inicio)} até ${formatDateBr(periodoResumo.fim)}`;
      const diasInformadosTexto = diasInformados.length
        ? diasInformados.map(formatDateBr).join(', ')
        : '';
      const resumoDiasHtml = resumoPorDia.length
        ? `
          <div class="mt-4">
            <h4 class="font-semibold text-sm text-gray-700 mb-2">Faturamento por dia</h4>
            <div class="overflow-x-auto">
              <table class="min-w-full text-xs text-left text-gray-600">
                <thead class="bg-gray-100 text-gray-700">
                  <tr>
                    <th class="px-3 py-2 font-medium">Data</th>
                    <th class="px-3 py-2 font-medium">Bruto</th>
                    <th class="px-3 py-2 font-medium">Líquido</th>
                    <th class="px-3 py-2 font-medium">Taxas</th>
                    <th class="px-3 py-2 font-medium">Vendas</th>
                  </tr>
                </thead>
                <tbody>
                  ${resumoPorDia
                    .map(
                      (dia) => `
                        <tr class="border-b last:border-none">
                          <td class="px-3 py-2">${formatDateBr(dia.data)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.valorBruto)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.valorLiquido)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.taxas)}</td>
                          <td class="px-3 py-2">${dia.vendas}</td>
                        </tr>
                      `
                    )
                    .join('')}
                </tbody>
              </table>
            </div>
          </div>
        `
        : `<p class="mt-4 text-sm text-gray-500">Nenhum faturamento ativo encontrado na planilha.</p>`;

      resultado.innerHTML = `
        <div class="alert alert-success">
          <i class="fas fa-check-circle"></i> Faturamento ${escapeHtml(plataforma)} processado com sucesso!<br>
          <strong>Loja:</strong> ${escapeHtml(loja)}<br>
          <strong>Período identificado:</strong> ${periodoTexto}<br>
          ${diasInformadosTexto ? `<strong>Dias informados:</strong> ${diasInformadosTexto}<br>` : ''}
          <strong>Bruto total:</strong> ${formatCurrency(bruto)}<br>
          <strong>Líquido total:</strong> ${formatCurrency(liquidoTotal)}<br>
          <strong>Vendas:</strong> ${qtdVendas}
        </div>
        ${resumoDiasHtml}
      `;
    }
  }

  mostrarSucesso(`Faturamento ${plataforma} importado com sucesso!`);
  return { bruto, liquidoTotal, qtdVendas };
}

function extrairLinhaMercadoLivre(row, { dataReferencia } = {}) {
  const headerMap = buildHeaderMap(row);
  const numeroVenda = String(getFieldByKey(row, headerMap, 'ndevenda') || '').trim();
  if (!numeroVenda) return null;
  return {
    numeroVenda,
    estado: String(getFieldByKey(row, headerMap, 'estado') || '').trim(),
    sku: String(getFieldByKey(row, headerMap, 'sku') || '').trim(),
    unidades: parseNumber(getFieldByKey(row, headerMap, 'unidades')),
    receitaProdutos: parseNumber(getFieldByKey(row, headerMap, 'receitaporprodutosbrl')),
    receitaAcrescimo: parseNumber(getFieldByKey(row, headerMap, 'receitaporacrescimonoprecopagopelocomprador')),
    receitaEnvio: parseNumber(getFieldByKey(row, headerMap, 'receitaporenviobrl')),
    taxaParcelamento: parseNumber(getFieldByKey(row, headerMap, 'taxadeparcelamentoequivalenteaoacrescimo')),
    tarifaVenda: parseNumber(getFieldByKey(row, headerMap, 'tarifadevendaeimpostosbrl')),
    tarifasEnvio: parseNumber(getFieldByKey(row, headerMap, 'tarifasdeenviobrl')),
    cancelamentos: parseNumber(getFieldByKey(row, headerMap, 'cancelamentoseerembolsosbrl')),
    totalLinha: parseNumber(getFieldByKey(row, headerMap, 'totalbrl')),
    dataVenda: getFieldByKey(row, headerMap, 'datadavenda') || dataReferencia
  };
}

function extrairLinhaTiny(row, { dataReferencia } = {}) {
  const headerMap = buildHeaderMap(row);
  const numeroVenda = String(getFieldByKey(row, headerMap, 'numerodaordemdecompra') || '').trim();
  if (!numeroVenda) return null;
  const quantidade = parseNumber(getFieldByKey(row, headerMap, 'quantidade'));
  const valorUnitario = parseNumber(getFieldByKey(row, headerMap, 'valorunitario'));
  const totalCalculado = Number(valorUnitario || 0) * (Number(quantidade || 0) || 0);
  const buscarCampoFrete = () => {
    const candidatos = [
      'frete',
      'valorfrete',
      'valordofrete',
      'valorfretepago',
      'valorfretepedido',
      'fretevendedor',
      'valortotalfrete',
      'freteporpedido'
    ];
    for (const chave of candidatos) {
      const encontrado = getFieldByKey(row, headerMap, chave);
      if (encontrado !== undefined && encontrado !== null && String(encontrado).trim() !== '') {
        return encontrado;
      }
    }
    return undefined;
  };
  const valorFreteBruto = buscarCampoFrete();
  const freteNumero = parseNumber(valorFreteBruto);
  const freteCalculado = Number.isFinite(freteNumero) ? freteNumero : 0;
  const freteValor = Number(freteCalculado.toFixed(2));
  const brutoPedido = Math.max(0, Number(totalCalculado || 0));
  const brutoPedidoFormatado = Math.max(0, Number(brutoPedido.toFixed(2)));
  const taxaMarketplaceBruta = brutoPedido * 0.12;
  const taxaMarketplaceValor = Math.max(0, Number(taxaMarketplaceBruta.toFixed(2)));
  const liquidoEstimadoValor = Number((brutoPedido - taxaMarketplaceValor - freteValor).toFixed(2));
  const dataPrevistaBruta = getFieldByKey(row, headerMap, 'dataprevista');
  const dataPrevistaNormalizada = normalizeDate(dataPrevistaBruta);
  const extras = {};
  if (dataPrevistaNormalizada) {
    extras.dataPrevista = dataPrevistaNormalizada;
  } else if (dataPrevistaBruta) {
    extras.dataPrevistaTexto = String(dataPrevistaBruta);
  }
  if (Number.isFinite(valorUnitario)) {
    extras.valorUnitario = valorUnitario;
  }
  extras.taxaMarketplacePercentual = 12;
  extras.taxaMarketplaceValor = taxaMarketplaceValor;
  if (freteValor !== 0) {
    extras.valorFrete = freteValor;
  }
  extras.valorBrutoCalculado = brutoPedidoFormatado;
  extras.valorLiquidoCalculado = liquidoEstimadoValor;
  return {
    numeroVenda,
    estado: String(getFieldByKey(row, headerMap, 'situacao') || '').trim(),
    sku: String(getFieldByKey(row, headerMap, 'codigosku') || '').trim(),
    unidades: quantidade,
    receitaProdutos: totalCalculado,
    receitaAcrescimo: 0,
    receitaEnvio: 0,
    taxaParcelamento: 0,
    tarifaVenda: taxaMarketplaceValor,
    tarifasEnvio: freteValor,
    cancelamentos: 0,
    totalLinha: liquidoEstimadoValor,
    dataVenda: getFieldByKey(row, headerMap, 'data') || dataReferencia,
    extrasPedido: extras
  };
}

   const tabIds = ['importar','metas','graficos','historico','faturamento','vendasML','registroFaturamento','controleVendas','produtosVendidos','sobras','previsao','acompanhamento','diariamente','vts','acompanhamentoGestor','diariamenteGestor'];
      const tabsLoaded = Promise.all(
        tabIds.map(t =>
          fetch(`sobras-tabs/${t}.html`)
            .then(res => res.text())
            .then(html => {
              const el = document.getElementById(t);
              if (el) el.innerHTML = html;
            })
            .catch(err => {
              console.error('Erro ao carregar aba', t, err);
              updateConnectionStatus(false);
              return '';
            })
        )
      );

      window.addEventListener('online', () => updateConnectionStatus(true));
      window.addEventListener('offline', () => updateConnectionStatus(false));
      updateConnectionStatus(navigator.onLine);

    // =============================================
    // INICIALIZAÇÃO DO FIREBASE E CONFIGURAÇÕES
    // =============================================
    
    // Inicialização mais robusta do Firebase
    document.addEventListener('DOMContentLoaded', async () => {
      initialTab = new URLSearchParams(window.location.search).get('tab') ||
        (window.location.hash ? window.location.hash.substring(1) : null);
      try {
        const app = !firebase.apps.length ? firebase.initializeApp(window.firebaseConfig) : firebase.app();
        db = firebase.firestore(app);
        const auth = firebase.auth();

        auth.onAuthStateChanged(async user => {
          if (!user) {
            window.location.href = 'index.html?login=1';
            return;
          }
          usuarioLogado.uid = user.uid;
          usuarioLogado.email = user.email;
          try {
            const perfilDoc = await db.collection('usuarios').doc(user.uid).get();
            usuarioLogado.perfil = perfilDoc.exists ? (perfilDoc.data().perfil || '') : '';
          } catch (e) {
            console.error('Erro ao obter perfil do usuário:', e);
          }
          await tabsLoaded;
          window.initTooltips && window.initTooltips();

          await carregarProdutos();
          await carregarMetas();
          carregarHistorico();
          await verificarGestorFinanceiro();
          await inicializarAbaDiaria();
          await inicializarDiarioGestor();
          document.getElementById('filtroSKU').addEventListener('input', filtrarPorSKU);
          document.getElementById('filtroHistorico').addEventListener('input', filtrarHistorico);
          document.getElementById('metaSku').addEventListener('input', atualizarPrecoMinimo);
          document.getElementById('filtroStatus').addEventListener('change', filtrarPorSKU);
          document.getElementById('tipoFiltro').addEventListener('change', filtrarPorSKU);
          document.getElementById('btnLimparFiltros')?.addEventListener('click', limparFiltros);
          await inicializarAbaVts();
          if (initialTab && document.getElementById(initialTab)) {
            trocarAba(initialTab);
            if (initialTab === 'sobras') {
              carregarSobras();
            }
          }
        });

        // Configurações importantes para a conexão
        db.settings({
          experimentalForceLongPolling: true
        });

        // Habilita persistência offline
        firebase.firestore().enablePersistence()
          .catch((err) => {
            if (err.code == 'failed-precondition') {
              console.warn("Persistência offline não suportada em múltiplas abas");
            } else if (err.code == 'unimplemented') {
              console.warn("Persistência offline não disponível no navegador");
            }
          });

        // Verifica conexão
        verificarConexao();

      } catch (error) {
        console.error("Erro ao inicializar Firebase:", error);
        mostrarErroFirebase(error);
      }
    });

 // Eventos dependentes do carregamento da navbar
    document.addEventListener('navbarLoaded', () => {
      const darkToggle = document.getElementById('darkModeToggle');
      if (darkToggle) {
        darkToggle.addEventListener('click', function() {
          this.classList.toggle('active');
          document.body.classList.toggle('dark-mode');
        });
      }

      const menuToggle = document.querySelector('.menu-toggle');
      if (menuToggle) {
        menuToggle.addEventListener('click', () => {
          document.querySelector('.sidebar')?.classList.toggle('active');
        });
      }
    });

    // =============================================
    // FUNÇÕES DE GERENCIAMENTO DE CONEXÃO
    // =============================================
    async function consultarDeepSeek(mensagemUser) {
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: "deepseek-chat",
            messages: [
              { role: "system", content: "Você é um analista de sobras de produtos da Shopee." },
              { role: "user", content: mensagemUser }
            ]
          })
        });

        const dados = await resposta.json();
        return dados.choices?.[0]?.message?.content || "❌ Sem resposta da IA.";
      } catch (error) {
        console.error("Erro ao consultar DeepSeek:", error);
        updateConnectionStatus(false);
        return "❌ Erro ao se comunicar com o servidor.";
      }
    }

    function verificarConexao() {
      firebase.firestore().enableNetwork()
        .then(() => {
          console.log("Conectado ao Firestore");
          document.getElementById('connectionStatus').className = 'connection-status online';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        })
        .catch((error) => {
          console.error("Erro de conexão:", error);
          document.getElementById('connectionStatus').className = 'connection-status offline';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        });
    }

    function mostrarErroFirebase(error) {
      const errorBox = document.getElementById('firebase-error');
      const errorMessage = document.getElementById('error-message');
      
      errorMessage.innerHTML = `<strong>${error.message}</strong><br>(Código: ${error.code})`;
      errorBox.style.display = 'block';

      console.error("Erro Firebase:", error);
      updateConnectionStatus(false);
    }

    function updateConnectionStatus(online) {
      const statusElement = document.getElementById('connectionStatus');
      
      if (online) {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        statusElement.className = 'connection-status online';
      } else {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        statusElement.className = 'connection-status offline';
      }
    }

    // =============================================
    // FUNÇÕES UTILITÁRIAS
    // =============================================
    
    function mostrarSucesso(mensagem) {
      const alerta = document.getElementById('alertSuccess');
      if (!alerta) {
        console.warn('Alerta de sucesso não encontrado na página.');
        return;
      }
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';

      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    function mostrarErro(mensagem) {
      const alerta = document.getElementById('alertError');
      if (!alerta) {
        console.warn('Alerta de erro não encontrado na página.');
        return;
      }
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';

      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    document.addEventListener('click', (event) => {
      if (event.target.closest('.alert-close')) {
        const alerta = event.target.closest('.alert');
        if (alerta) {
          alerta.style.display = 'none';
        }
      }
    });

    function registrarEventosControleVendas() {
      if (controleVendasEventosRegistrados) return;
      const selecionarTodos = document.getElementById('controleVendasSelecionarTodos');
      const botaoExcluir = document.getElementById('btnExcluirControleVendasSelecionados');
      if (!selecionarTodos || !botaoExcluir) return;
      selecionarTodos.addEventListener('change', (event) => {
        const checkboxes = document.querySelectorAll('#listaControleVendas .controle-vendas-checkbox');
        controleVendasSelecao.clear();
        checkboxes.forEach((checkbox) => {
          checkbox.checked = event.target.checked;
          atualizarSelecaoControleVendas(checkbox, false);
        });
        atualizarPainelSelecaoControleVendas();
      });
      botaoExcluir.addEventListener('click', excluirControleVendasSelecionados);
      controleVendasEventosRegistrados = true;
      atualizarPainelSelecaoControleVendas();
    }

    function atualizarSelecaoControleVendas(checkbox, atualizarPainel = true) {
      if (!checkbox) return;
      const dia = checkbox.getAttribute('data-dia');
      const uid = checkbox.getAttribute('data-uid');
      if (!dia || !uid) return;
      const chave = `${uid}__${dia}`;
      if (checkbox.checked) {
        controleVendasSelecao.set(chave, { dia, uid });
      } else {
        controleVendasSelecao.delete(chave);
      }
      if (atualizarPainel) atualizarPainelSelecaoControleVendas();
    }

    function atualizarPainelSelecaoControleVendas() {
      const info = document.getElementById('controleVendasSelecionadosInfo');
      const botao = document.getElementById('btnExcluirControleVendasSelecionados');
      const selecionarTodos = document.getElementById('controleVendasSelecionarTodos');
      const totalSelecionados = controleVendasSelecao.size;
      if (info) {
        info.textContent = totalSelecionados
          ? `${totalSelecionados} dia${totalSelecionados > 1 ? 's' : ''} selecionado${totalSelecionados > 1 ? 's' : ''}`
          : 'Nenhum dia selecionado';
      }
      if (botao) {
        botao.disabled = totalSelecionados === 0;
      }
      if (selecionarTodos) {
        const checkboxes = Array.from(document.querySelectorAll('#listaControleVendas .controle-vendas-checkbox'));
        if (!checkboxes.length) {
          selecionarTodos.checked = false;
          selecionarTodos.indeterminate = false;
        } else {
          const selecionados = checkboxes.filter((cb) => cb.checked).length;
          selecionarTodos.checked = selecionados > 0 && selecionados === checkboxes.length;
          selecionarTodos.indeterminate = selecionados > 0 && selecionados < checkboxes.length;
        }
      }
    }

    function limparSelecaoControleVendas() {
      controleVendasSelecao.clear();
      const selecionarTodos = document.getElementById('controleVendasSelecionarTodos');
      if (selecionarTodos) {
        selecionarTodos.checked = false;
        selecionarTodos.indeterminate = false;
      }
      document.querySelectorAll('#listaControleVendas .controle-vendas-checkbox').forEach((checkbox) => {
        checkbox.checked = false;
      });
      atualizarPainelSelecaoControleVendas();
    }

    async function obterBaseResponsavelFinanceiroPorUid(uid) {
      if (!uid || !db) return { baseResp: null, respEmail: null };
      if (controleVendasBaseCache.has(uid)) {
        const cached = controleVendasBaseCache.get(uid);
        if (cached && typeof cached.then === 'function') {
          return cached;
        }
        return cached;
      }
      const consulta = (async () => {
        try {
          const usuarioDoc = await db.collection('usuarios').doc(uid).get();
          const dadosUsuario = usuarioDoc.exists ? usuarioDoc.data() || {} : {};
          const respEmail = String(dadosUsuario.responsavelFinanceiroEmail || '').trim();
          if (!respEmail) return { baseResp: null, respEmail: null };
          let responsavelUid = null;
          const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
          if (!respSnap.empty) {
            const respDoc = respSnap.docs[0];
            responsavelUid = respDoc.data()?.uid || respDoc.id;
          }
          if (!responsavelUid) {
            const altSnap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
            if (!altSnap.empty) {
              const altDoc = altSnap.docs[0];
              responsavelUid = altDoc.data()?.uid || altDoc.id;
            }
          }
          if (!responsavelUid) return { baseResp: null, respEmail };
          const baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(uid);
          return { baseResp, respEmail };
        } catch (erro) {
          console.error('Erro ao obter base do responsável financeiro para exclusão:', erro);
          return { baseResp: null, respEmail: null };
        }
      })();
      controleVendasBaseCache.set(uid, consulta);
      const resultado = await consulta;
      controleVendasBaseCache.set(uid, resultado);
      return resultado;
    }

    async function excluirControleVendasSelecionados() {
      if (!controleVendasSelecao.size) {
        mostrarErro('Selecione ao menos um dia para excluir.');
        return;
      }
      const selecionados = Array.from(controleVendasSelecao.values());
      const quantidade = selecionados.length;
      const mensagem = quantidade === 1
        ? `Deseja realmente excluir o registro do dia ${selecionados[0].dia}?`
        : `Deseja realmente excluir ${quantidade} registros de dias diferentes?`;
      let confirmado = true;
      if (typeof Swal !== 'undefined' && Swal.fire) {
        const resultado = await Swal.fire({
          title: 'Confirmar exclusão',
          text: mensagem,
          icon: 'warning',
          showCancelButton: true,
          confirmButtonText: 'Sim, excluir',
          cancelButtonText: 'Cancelar'
        });
        confirmado = resultado.isConfirmed;
      } else {
        confirmado = window.confirm(mensagem);
      }
      if (!confirmado) return;

      const botao = document.getElementById('btnExcluirControleVendasSelecionados');
      if (botao) {
        botao.disabled = true;
        toggleLoading(botao, 'Excluir selecionados');
      }

      const erros = [];
      try {
        const agrupadoPorUid = selecionados.reduce((acc, item) => {
          if (!acc[item.uid]) acc[item.uid] = [];
          acc[item.uid].push(item.dia);
          return acc;
        }, {});

        for (const [uid, dias] of Object.entries(agrupadoPorUid)) {
          const { baseResp } = await obterBaseResponsavelFinanceiroPorUid(uid);
          for (const dia of dias) {
            try {
              const docRef = db.collection('uid').doc(uid).collection('skusVendidos').doc(dia);
              await excluirDocumentosSubcolecao(docRef, 'lista');
              await docRef.delete();
            } catch (erro) {
              console.error('Erro ao excluir registro de vendas:', erro);
              erros.push(dia);
              continue;
            }
            if (baseResp) {
              try {
                const destinoDoc = baseResp.collection('skusVendidos').doc(dia);
                await excluirDocumentosSubcolecao(destinoDoc, 'lista');
                await destinoDoc.delete();
              } catch (erro) {
                console.warn('Erro ao excluir cópia para o responsável financeiro:', erro);
              }
            }
          }
        }
      } finally {
        if (botao) {
          toggleLoading(botao, 'Excluir selecionados');
          botao.disabled = false;
        }
      }

      if (erros.length) {
        mostrarErro('Alguns registros não puderam ser excluídos. Verifique o console para mais detalhes.');
      } else {
        mostrarSucesso('Registros de vendas excluídos com sucesso.');
      }
      limparSelecaoControleVendas();
      await carregarControleVendas();
    }

    function toggleLoading(botao, texto) {
      const btnText = botao.querySelector('span') || botao;
      if (botao.classList.contains('loading')) {
        botao.classList.remove('loading');
        btnText.innerHTML = texto;
      } else {
        botao.classList.add('loading');
        btnText.innerHTML = '<div class="loading"></div> Carregando...';
      }
    }

    async function notificarResponsavelFinanceiro(dataRef, loja, bruto, liquido, qtdVendas) {
      try {
        const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
        const dadosUsuario = usuarioDoc.data() || {};
        const autorNome = dadosUsuario.nome || firebase.auth().currentUser?.email || '';
        const autorEmail = firebase.auth().currentUser?.email || '';
        const respEmail = dadosUsuario.responsavelFinanceiroEmail;
        if (!respEmail) return;
        const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
        if (respSnap.empty) return;
        const respDoc = respSnap.docs[0];
        const respData = respDoc.data() || {};
        const responsavelUid = respData.uid || respDoc.id;
        const descricao = `Faturamento de ${dataRef} da loja ${loja} atualizado. Bruto: R$ ${bruto.toFixed(2)}, Líquido: R$ ${liquido.toFixed(2)}, Vendas: ${qtdVendas}`;
        await db.collection('financeiroAtualizacoes').add({
          descricao,
          autorUid: usuarioLogado.uid,
          autorNome,
          autorEmail,
          dataFaturamento: dataRef,
          destinatarios: [responsavelUid, usuarioLogado.uid],
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          anexos: [],
          tipo: 'faturamento'
        });
      } catch (e) {
        console.error('Erro ao notificar responsável financeiro:', e);
      }
    }

    async function executarComRetry(operacao, maxTentativas = 3, delay = 1000) {
      let tentativas = 0;
      
      while (tentativas < maxTentativas) {
        try {
          return await operacao();
        } catch (error) {
          tentativas++;
          if (tentativas >= maxTentativas) throw error;
          
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Aumenta o delay exponencialmente
        }
      }
    }
    
    function atualizarPrecoMinimo() {
      const sku = document.getElementById('metaSku').value.trim();
      const custo = produtos[sku]; // usa o campo `custo`
          const info = document.getElementById('custoProdutoInfo');
      const metaInput = document.getElementById('metaValor');

      if (!info || !metaInput) return;

      if (custo) {
        const valorFormatado = parseFloat(custo).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
        info.textContent = `Custo (usado como meta): R$ ${valorFormatado}`;
        info.style.color = '#06d6a0';

        metaInput.value = parseFloat(custo).toFixed(2); // preencher automaticamente o campo de meta
      } else {
        info.textContent = '';
        metaInput.value = '';
      }
    }
    
    // =============================================
    // FUNÇÕES DE NAVEGAÇÃO E INTERFACE
    // =============================================
    
    function podeAcessarProdutosVendidos() {
      const perfilRaw = (window.userPerfil || usuarioLogado.perfil || '')
        .toString()
        .toLowerCase();
      const perfilNormalizado = perfilRaw
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .trim();
      const perfisPermitidos = new Set([
        'gestor',
        'responsavel',
        'gestor financeiro',
        'responsavel financeiro',
        'adm',
        'admin',
        'administrador',
      ]);
      return (
        perfisPermitidos.has(perfilNormalizado) ||
        window.isFinanceiroResponsavel === true
      );
    }

    function verificarPermissaoAba(id) {
      if (!['produtosVendidos', 'diariamenteGestor'].includes(id)) {
        return true;
      }
      const autorizado = podeAcessarProdutosVendidos();
      if (!autorizado) {
        if (window.Swal) {
          Swal.fire(
            'Acesso restrito',
            'Esta aba está disponível apenas para gestores ou responsáveis financeiros.',
            'warning',
          );
        } else {
          alert(
            'A aba Produtos Vendidos está disponível apenas para gestores ou responsáveis financeiros.',
          );
        }
      }
      return autorizado;
    }

    window.trocarAba = function trocarAba(id) {
      if (!verificarPermissaoAba(id)) {
        return;
      }

      // Remove a classe 'active' de todas as abas
      document
        .querySelectorAll('.tab-content')
        .forEach((aba) => aba.classList.remove('active'));

      // Ativa a aba correspondente, se existir
      const abaSelecionada = document.getElementById(id);
      if (abaSelecionada) {
        abaSelecionada.classList.add('active');
      } else {
        console.warn(`❌ Aba com ID '${id}' não encontrada.`);
        return;
      }

      // Atualiza gráficos, se necessário
      if (id === 'graficos') {
        setTimeout(atualizarGraficos, 100);
      }
      if (id === 'produtosVendidos') {
        if (!produtosVendidosCarregado) carregarProdutosVendidos();
        else renderProdutosVendidos();
      }
      if (id === 'vts' && !vtsCarregado) {
        carregarEtiquetasVts();
      }
      if (id === 'diariamente') {
        inicializarAbaDiaria();
      }
      if (id === 'diariamenteGestor') {
        inicializarDiarioGestor();
      }
    };


    // =============================================
    // FUNÇÕES DA ABA VTS
    // =============================================
    function obterNomeModeloVts(modelo) {
      if (!modelo) return '';
      const config = VTS_MODELOS_CONFIG[modelo];
      return config?.nome || modelo;
    }

    function setVtsFeedback(mensagem = '', tipo = 'info', modelo = '') {
      const feedback = document.getElementById('vtsFeedback');
      if (!feedback) return;

      const classesBase = 'mt-3 rounded-lg px-4 py-3 text-sm font-medium';
      const tons = {
        success: 'bg-emerald-50 text-emerald-700 border border-emerald-200',
        error: 'bg-red-50 text-red-700 border border-red-200',
        warning: 'bg-amber-50 text-amber-700 border border-amber-200',
        info: 'bg-slate-50 text-slate-600 border border-slate-200',
      };

      if (!mensagem) {
        feedback.style.display = 'none';
        feedback.textContent = '';
        feedback.className = classesBase;
        return;
      }

      const prefixo = modelo ? `[${obterNomeModeloVts(modelo)}] ` : '';

      feedback.style.display = '';
      feedback.textContent = `${prefixo}${mensagem}`;
      feedback.className = `${classesBase} ${tons[tipo] || tons.info}`;
    }

    function atualizarDiagnosticoVts(diagnostico = [], arquivoNome = '', modelo = '') {
      const container = document.getElementById('vtsDebugContainer');
      const resumo = document.getElementById('vtsDebugResumo');
      const pre = document.getElementById('vtsDebugPre');
      const botao = document.getElementById('vtsToggleDebug');

      if (!container || !resumo || !pre) return;

      vtsUltimoDiagnostico = Array.isArray(diagnostico) ? diagnostico : [];
      vtsUltimoArquivo = arquivoNome || '';
      vtsUltimoModelo = modelo || '';

      if (!vtsUltimoDiagnostico.length) {
        resumo.textContent = 'Nenhum diagnóstico disponível no momento. Importe um PDF para visualizar os dados lidos.';
        pre.textContent = 'Nenhum dado processado ainda.';
        pre.scrollTop = 0;
        if (botao) {
          botao.textContent = container.classList.contains('hidden')
            ? 'Mostrar diagnóstico'
            : 'Ocultar diagnóstico';
        }
        return;
      }

      const partes = vtsUltimoDiagnostico.map((entrada) => {
        const linhasTexto = (entrada.linhas || [])
          .map((linha, indice) => `  [${indice + 1}] ${linha}`)
          .join('\n');
        const interpretado = entrada.interpretado
          ? JSON.stringify(entrada.interpretado, null, 2)
          : 'Nenhum dado interpretado para esta página.';
        const modeloDiagnostico = obterNomeModeloVts(entrada.modelo || modelo);
        return [
          modeloDiagnostico ? `Modelo: ${modeloDiagnostico}` : null,
          `Página ${entrada.pagina}`,
          'Texto lido:',
          linhasTexto || '  (nenhuma linha identificada)',
          'Interpretação:',
          interpretado,
        ]
          .filter(Boolean)
          .join('\n');
      });

      const modeloNome = obterNomeModeloVts(modelo);
      const origemTexto = arquivoNome
        ? `arquivo "${arquivoNome}"`
        : 'último arquivo processado';
      const modeloTexto = modeloNome ? `Modelo: ${modeloNome}. ` : '';

      resumo.textContent = `${modeloTexto}Diagnóstico gerado a partir do ${origemTexto}.`;

      pre.textContent = partes.join('\n\n----------------------------------------\n\n');
      pre.scrollTop = 0;

      if (botao) {
        botao.textContent = container.classList.contains('hidden')
          ? 'Mostrar diagnóstico'
          : 'Ocultar diagnóstico';
      }
    }

    function construirMapaCabecalhoPlanilhaVts(cabecalho = []) {
      const mapa = new Map();
      if (!Array.isArray(cabecalho)) return mapa;

      cabecalho.forEach((titulo, indice) => {
        const chaveNormalizada = normalizeHeaderKey(titulo);
        if (chaveNormalizada && !mapa.has(chaveNormalizada)) {
          mapa.set(chaveNormalizada, indice);
        }
      });

      return mapa;
    }

    function extrairValorCelulaPlanilhaVts(linha, indice, chaveCampo = '') {
      if (!Array.isArray(linha) || typeof indice !== 'number') return '';

      const bruto = linha[indice];
      if (bruto === null || bruto === undefined) return '';

      const ehCampoData = chaveCampo === 'dataEtiqueta' || chaveCampo === 'dataEtiquetaTexto';

      if (ehCampoData && typeof bruto === 'number' && typeof XLSX !== 'undefined') {
        const parsed = XLSX?.SSF?.parse_date_code?.(bruto);
        if (parsed && parsed.y && parsed.m && parsed.d) {
          const data = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d));
          if (!Number.isNaN(data)) {
            return data.toISOString().split('T')[0];
          }
        }
      }

      if (bruto instanceof Date && !Number.isNaN(bruto)) {
        return bruto.toISOString().split('T')[0];
      }

      return String(bruto).trim();
    }

    function obterStatusExportacaoVts(registro = {}) {
      const statusTexto = (registro.status || '').toString().trim();
      const estaCancelado = statusTexto.toLowerCase() === 'cancelado';
      if (estaCancelado) {
        const dataCancelamento =
          registro.canceladoEm instanceof Date && !Number.isNaN(registro.canceladoEm.getTime())
            ? registro.canceladoEm
            : null;
        const descricaoData = dataCancelamento
          ? ` em ${dataCancelamento.toLocaleDateString('pt-BR')} às ${dataCancelamento.toLocaleTimeString('pt-BR')}`
          : '';
        const motivo = (registro.canceladoMotivo || '').toString().trim();
        return `Pedido cancelado${descricaoData}${motivo ? ` (${motivo})` : ''}`;
      }

      return statusTexto || '-';
    }

    function mapearEtiquetasParaExportacaoVts(registros = []) {
      if (!Array.isArray(registros)) return [];

      return registros.map((registro) => {
        const dataEtiquetaIso = normalizeDate(registro?.dataEtiqueta) || '';
        const dataColocadaIso = normalizeDate(registro?.datacolocada) || '';

        const pedido = registro?.pedido;
        const rastreio = registro?.rastreio;
        const loja = registro?.loja;
        const arquivo = registro?.origemArquivo;

        return {
          sku: obterSkuAssociadoTextoVts(registro) || '-',
          pedido: pedido !== undefined && pedido !== null && String(pedido).trim() ? String(pedido).trim() : '-',
          rastreio:
            rastreio !== undefined && rastreio !== null && String(rastreio).trim() ? String(rastreio).trim() : '-',
          loja: loja !== undefined && loja !== null && String(loja).trim() ? String(loja).trim() : '-',
          data: formatarDataVts(dataEtiquetaIso, registro?.dataEtiquetaTexto),
          dataColocada: formatarDataVts(dataColocadaIso, registro?.datacolocadaTexto),
          arquivo:
            arquivo !== undefined && arquivo !== null && String(arquivo).trim() ? String(arquivo).trim() : '-',
          status: obterStatusExportacaoVts(registro),
        };
      });
    }

    async function exportarEtiquetasVtsExcel() {
      const registrosFiltrados = obterEtiquetasFiltradasVts();
      if (!Array.isArray(registrosFiltrados) || !registrosFiltrados.length) {
        setVtsFeedback('Não há pedidos cadastrados para exportar com os filtros aplicados.', 'warning');
        return;
      }

      if (typeof XLSX === 'undefined') {
        setVtsFeedback('Biblioteca de planilhas indisponível no momento.', 'error');
        return;
      }

      try {
        const cabecalho = [
          'SKU',
          'Número do pedido',
          'Rastreio',
          'Loja',
          'Data',
          'Data colocada',
          'Arquivo',
          'Status',
        ];
        const dadosExportacao = mapearEtiquetasParaExportacaoVts(registrosFiltrados);
        const linhas = dadosExportacao.map((item) => ({
          SKU: item.sku,
          'Número do pedido': item.pedido,
          Rastreio: item.rastreio,
          Loja: item.loja,
          Data: item.data,
          'Data colocada': item.dataColocada,
          Arquivo: item.arquivo,
          Status: item.status,
        }));

        const worksheet = linhas.length
          ? XLSX.utils.json_to_sheet(linhas, { header: cabecalho, skipHeader: false })
          : XLSX.utils.aoa_to_sheet([cabecalho]);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Pedidos VTS');

        XLSX.writeFile(workbook, `vts-etiquetas-${gerarTimestampArquivoVts()}.xlsx`);
        setVtsFeedback('Planilha exportada com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao exportar planilha de etiquetas VTS:', erro);
        setVtsFeedback('Não foi possível exportar a planilha neste momento.', 'error');
      }
    }

    async function exportarEtiquetasVtsPdf() {
      const registrosFiltrados = obterEtiquetasFiltradasVts();
      if (!Array.isArray(registrosFiltrados) || !registrosFiltrados.length) {
        setVtsFeedback('Não há pedidos cadastrados para exportar com os filtros aplicados.', 'warning');
        return;
      }

      if (typeof html2pdf === 'undefined') {
        setVtsFeedback('Ferramenta de exportação em PDF indisponível no momento.', 'error');
        return;
      }

      const dadosExportacao = mapearEtiquetasParaExportacaoVts(registrosFiltrados);
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.left = '-9999px';
      container.style.top = '0';
      container.style.padding = '24px';
      container.style.fontFamily = 'Inter, sans-serif';
      container.style.color = '#1f2937';
      container.style.maxWidth = '1100px';

      const titulo = document.createElement('h2');
      titulo.textContent = 'Etiquetas VTS';
      titulo.style.marginBottom = '8px';
      titulo.style.fontSize = '18px';
      titulo.style.fontWeight = '600';
      container.appendChild(titulo);

      const descricao = document.createElement('p');
      descricao.textContent = `${construirDescricaoFiltrosVts()} • Registros exportados: ${dadosExportacao.length}`;
      descricao.style.marginBottom = '16px';
      descricao.style.fontSize = '12px';
      container.appendChild(descricao);

      const tabela = document.createElement('table');
      tabela.style.width = '100%';
      tabela.style.borderCollapse = 'collapse';
      tabela.style.fontSize = '11px';

      const colunas = [
        { chave: 'sku', titulo: 'SKU', alinhamento: 'left' },
        { chave: 'pedido', titulo: 'Número do pedido', alinhamento: 'left' },
        { chave: 'rastreio', titulo: 'Rastreio', alinhamento: 'left' },
        { chave: 'loja', titulo: 'Loja', alinhamento: 'left' },
        { chave: 'data', titulo: 'Data', alinhamento: 'center' },
        { chave: 'dataColocada', titulo: 'Data colocada', alinhamento: 'center' },
        { chave: 'arquivo', titulo: 'Arquivo', alinhamento: 'left' },
        { chave: 'status', titulo: 'Status', alinhamento: 'left' },
      ];

      const cabecalho = document.createElement('thead');
      const cabecalhoLinha = document.createElement('tr');
      colunas.forEach((coluna) => {
        const th = document.createElement('th');
        th.textContent = coluna.titulo;
        th.style.border = '1px solid #e2e8f0';
        th.style.backgroundColor = '#f1f5f9';
        th.style.padding = '8px';
        th.style.fontWeight = '600';
        th.style.textAlign = coluna.alinhamento;
        cabecalhoLinha.appendChild(th);
      });
      cabecalho.appendChild(cabecalhoLinha);
      tabela.appendChild(cabecalho);

      const corpo = document.createElement('tbody');
      dadosExportacao.forEach((item) => {
        const linha = document.createElement('tr');
        linha.style.borderBottom = '1px solid #e2e8f0';

        colunas.forEach((coluna) => {
          const td = document.createElement('td');
          td.textContent = item[coluna.chave] || '-';
          td.style.padding = '8px';
          td.style.border = '1px solid #e2e8f0';
          td.style.textAlign = coluna.alinhamento;
          linha.appendChild(td);
        });

        corpo.appendChild(linha);
      });
      tabela.appendChild(corpo);
      container.appendChild(tabela);

      document.body.appendChild(container);

      try {
        await html2pdf()
          .set({
            margin: 10,
            filename: `vts-etiquetas-${gerarTimestampArquivoVts()}.pdf`,
            html2canvas: { scale: 2 },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
          })
          .from(container)
          .save();
        setVtsFeedback('PDF exportado com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao exportar etiquetas VTS em PDF:', erro);
        setVtsFeedback('Não foi possível exportar o PDF neste momento.', 'error');
      } finally {
        container.remove();
      }
    }

    async function importarEtiquetasVtsExcel(evento) {
      const input = evento?.target || document.getElementById('vtsImportarExcel');
      const arquivo = input?.files?.[0];

      if (!arquivo) {
        setVtsFeedback('Selecione um arquivo no formato exportado para importar pedidos.', 'warning');
        return;
      }

      if (typeof XLSX === 'undefined') {
        setVtsFeedback('Biblioteca de planilhas indisponível no momento.', 'error');
        if (input) input.value = '';
        return;
      }

      try {
        setVtsFeedback('Processando planilha de pedidos, aguarde...', 'info');

        const arrayBuffer = await arquivo.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const primeiraAba = workbook.SheetNames?.[0];
        if (!primeiraAba) {
          setVtsFeedback('A planilha informada está vazia.', 'warning');
          return;
        }

        const sheet = workbook.Sheets[primeiraAba];
        const linhas = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        if (!Array.isArray(linhas) || !linhas.length) {
          setVtsFeedback('A planilha informada está vazia.', 'warning');
          return;
        }

        const cabecalho = linhas[0].map((valor) => String(valor ?? '').trim());
        const mapaCabecalho = construirMapaCabecalhoPlanilhaVts(cabecalho);

        const indicesColunas = new Map();
        VTS_PLANILHA_COLUNAS.forEach((coluna) => {
          const chaveNormalizada = VTS_PLANILHA_HEADER_NORMALIZADO[coluna.chave];
          const indice = mapaCabecalho.get(chaveNormalizada);
          if (typeof indice === 'number') {
            indicesColunas.set(coluna.chave, indice);
          }
        });

        const faltantes = VTS_PLANILHA_COLUNAS.filter(
          (coluna) => coluna.obrigatorio && !indicesColunas.has(coluna.chave),
        );

        if (faltantes.length) {
          const nomesFaltantes = faltantes.map((coluna) => coluna.rotulo).join(', ');
          setVtsFeedback(
            `A planilha não está no formato esperado. Colunas ausentes: ${nomesFaltantes}.`,
            'error',
          );
          return;
        }

        const registros = [];
        for (let linhaIndice = 1; linhaIndice < linhas.length; linhaIndice += 1) {
          const linha = linhas[linhaIndice];
          if (!Array.isArray(linha)) continue;

          const possuiInformacao = linha.some((celula) => String(celula ?? '').trim());
          if (!possuiInformacao) continue;

          const dadosBrutos = {};
          VTS_PLANILHA_COLUNAS.forEach((coluna) => {
            const indice = indicesColunas.get(coluna.chave);
            if (typeof indice !== 'number') return;
            dadosBrutos[coluna.chave] = extrairValorCelulaPlanilhaVts(linha, indice, coluna.chave);
          });

          const dataNormalizada = normalizeDate(dadosBrutos.dataEtiqueta);
          const dataTexto = dadosBrutos.dataEtiquetaTexto || dadosBrutos.dataEtiqueta || '';

          const etiqueta = {
            sku: normalizarLinhaVts(dadosBrutos.sku),
            pedido: normalizarLinhaVts(dadosBrutos.pedido),
            rastreio: normalizarLinhaVts(dadosBrutos.rastreio),
            loja: normalizarLinhaVts(dadosBrutos.loja),
            dataNormalizada,
            dataTexto,
            origemArquivo: dadosBrutos.origemArquivo || arquivo.name,
            modelo: normalizarLinhaVts(dadosBrutos.modeloEtiqueta),
            buyerUsername: normalizarLinhaVts(dadosBrutos.buyerUsername),
          };

          if (!possuiInformacoesEtiquetaVts(etiqueta)) continue;

          registros.push(etiqueta);
        }

        if (!registros.length) {
          setVtsFeedback('Nenhum pedido válido foi encontrado na planilha informada.', 'warning');
          return;
        }

        const resultadoSalvamento = await salvarEtiquetasVts(registros, arquivo, 'planilha');

        if (resultadoSalvamento?.cancelado) {
          setVtsFeedback('Importação cancelada: informe a data em que as etiquetas foram colocadas para continuar.', 'warning');
          return;
        }

        const { salvos = 0, ignorados = 0 } = resultadoSalvamento || {};

        const mensagens = [];
        if (salvos > 0) mensagens.push(`${salvos} pedido(s) importado(s) com sucesso.`);
        if (ignorados > 0)
          mensagens.push(`${ignorados} registro(s) ignorado(s) por já estarem cadastrados.`);

        const tipoFeedback = salvos > 0 ? 'success' : ignorados > 0 ? 'warning' : 'info';
        setVtsFeedback(mensagens.join(' ') || 'Nenhum pedido novo foi importado.', tipoFeedback);

        await carregarEtiquetasVts();
      } catch (erro) {
        console.error('Erro ao importar planilha de etiquetas VTS:', erro);
        setVtsFeedback(
          'Não foi possível importar a planilha. Verifique se o arquivo segue o modelo exportado.',
          'error',
        );
      } finally {
        if (input) input.value = '';
      }
    }

    function formatarDataVts(valorISO, valorOriginal) {
      if (valorISO) {
        const [ano, mes, dia] = valorISO.split('-');
        if (ano && mes && dia) {
          return `${dia}/${mes}/${ano}`;
        }
      }
      if (valorOriginal) {
        return valorOriginal;
      }
      return '-';
    }

    const VTS_FEEDBACK_CLASS_MAP = Object.freeze({
      success: 'bg-emerald-50 text-emerald-700 border border-emerald-200',
      error: 'bg-rose-50 text-rose-700 border border-rose-200',
      warning: 'bg-amber-50 text-amber-700 border border-amber-200',
      info: 'bg-sky-50 text-sky-700 border border-sky-200',
    });

    function aplicarFeedbackGenericoVts(elementId, mensagem, tipo = 'info') {
      const elemento = document.getElementById(elementId);
      if (!elemento) return;

      if (!mensagem) {
        elemento.textContent = '';
        elemento.className = 'hidden';
        return;
      }

      const classeEstado = VTS_FEEDBACK_CLASS_MAP[tipo] || VTS_FEEDBACK_CLASS_MAP.info;
      elemento.className = `rounded-lg px-4 py-3 text-sm font-medium ${classeEstado}`;
      elemento.textContent = mensagem;
      elemento.classList.remove('hidden');
    }

    function parseListaSkusVts(valor) {
      return (valor || '')
        .split(/[\n,;]+/)
        .map((parte) => parte.trim())
        .filter(Boolean);
    }

    function atualizarMapaAssociacoesVts() {
      vtsSkuMapa = new Map();
      vtsSkuAssociacoes.forEach((associacao) => {
        const principal = (associacao.skuPrincipal || associacao.id || '').trim();
        if (!principal) return;

        const todos = new Set([principal, ...(associacao.associados || []), ...(associacao.principaisVinculados || [])]);
        const dadosAssociacao = {
          ...associacao,
          skuPrincipal: principal,
          associados: (associacao.associados || []).filter(Boolean),
          principaisVinculados: (associacao.principaisVinculados || []).filter(Boolean),
          sobraEsperada: Number.isFinite(Number(associacao.sobraEsperada))
            ? Number(associacao.sobraEsperada)
            : 0,
          todos: Array.from(todos).filter(Boolean),
        };

        dadosAssociacao.todos.forEach((sku) => {
          const chave = normalizarComparacaoVts(sku);
          if (chave) {
            vtsSkuMapa.set(chave, dadosAssociacao);
          }
        });
      });
    }

    function renderizarAssociacoesSkuVts() {
      const corpoTabela = document.getElementById('vtsSkuTabelaCorpo');
      if (!corpoTabela) return;

      corpoTabela.innerHTML = '';

      if (!vtsSkuAssociacoes.length) {
        const linha = document.createElement('tr');
        const coluna = document.createElement('td');
        coluna.colSpan = 4;
        coluna.className = 'px-4 py-4 text-center text-sm text-slate-500';
        coluna.textContent = 'Nenhuma associação cadastrada até o momento.';
        linha.appendChild(coluna);
        corpoTabela.appendChild(linha);
        return;
      }

      const listaOrdenada = [...vtsSkuAssociacoes].sort((a, b) =>
        (a.skuPrincipal || '').localeCompare(b.skuPrincipal || '', 'pt-BR', { sensitivity: 'base' }),
      );

      listaOrdenada.forEach((associacao) => {
        const linha = document.createElement('tr');
        linha.className = 'border-b border-slate-100 hover:bg-slate-50 transition-colors';

        const associados = [...new Set([...(associacao.associados || []), ...(associacao.principaisVinculados || [])])]
          .filter(Boolean)
          .join(', ');
        const sobraEsperadaNumero = Number(associacao.sobraEsperada);
        const sobraEsperadaValida = Number.isFinite(sobraEsperadaNumero)
          ? sobraEsperadaNumero
          : 0;
        const sobraEsperadaTexto = sobraEsperadaValida
          ? sobraEsperadaValida.toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 2 })
          : '0';

        linha.innerHTML = `
          <td class="px-4 py-3 font-semibold text-slate-700">${associacao.skuPrincipal || '-'}</td>
          <td class="px-4 py-3 text-slate-600">${associados || '<span class="text-slate-400">-</span>'}</td>
          <td class="px-4 py-3 text-right text-slate-700 font-semibold">${sobraEsperadaTexto}</td>
          <td class="px-4 py-3">
            <div class="flex flex-wrap gap-2">
              <button
                type="button"
                class="inline-flex items-center gap-1 rounded border border-slate-200 px-3 py-1 text-xs font-medium text-slate-600 hover:bg-slate-100 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-1"
                data-acao="editar"
                data-id="${associacao.id}"
              >
                <i class="fas fa-pen"></i>
                Editar
              </button>
              <button
                type="button"
                class="inline-flex items-center gap-1 rounded border border-rose-200 px-3 py-1 text-xs font-medium text-rose-600 hover:bg-rose-50 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-1"
                data-acao="excluir"
                data-id="${associacao.id}"
              >
                <i class="fas fa-trash"></i>
                Excluir
              </button>
            </div>
          </td>
        `;

        corpoTabela.appendChild(linha);
      });
    }

    function exportarAssociacoesSkuVtsExcel() {
      if (!vtsSkuAssociacoes.length) {
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não há associações cadastradas para exportar. Cadastre algum SKU antes de gerar a planilha.',
          'warning',
        );
        return;
      }

      try {
        const cabecalho = VTS_SKU_PLANILHA_COLUNAS.map((coluna) => coluna.rotulo);
        const linhas = [...vtsSkuAssociacoes]
          .sort((a, b) => (a.skuPrincipal || '').localeCompare(b.skuPrincipal || '', 'pt-BR', { sensitivity: 'base' }))
          .map((associacao) => {
            const associados = [...new Set([...(associacao.associados || []), ...(associacao.principaisVinculados || [])])]
              .filter(Boolean)
              .sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }))
              .join(', ');
            const sobraEsperadaNumero = Number(associacao.sobraEsperada ?? 0);
            const sobraEsperadaValida = Number.isFinite(sobraEsperadaNumero) && sobraEsperadaNumero >= 0
              ? sobraEsperadaNumero
              : 0;
            return [
              associacao.skuPrincipal || associacao.id || '',
              associados,
              sobraEsperadaValida,
            ];
          });

        const worksheet = XLSX.utils.aoa_to_sheet([cabecalho, ...linhas]);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'SKUs associados');
        const buffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const nomeArquivo = `vts-sku-associados-${gerarTimestampArquivoVts()}.xlsx`;
        const blob = new Blob([buffer], {
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        });
        saveAs(blob, nomeArquivo);

        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Planilha de SKUs exportada com sucesso. Utilize este arquivo como modelo para futuras importações.',
          'success',
        );
      } catch (erro) {
        console.error('Erro ao exportar associações de SKU VTS:', erro);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível exportar a planilha de SKUs. Tente novamente mais tarde.',
          'error',
        );
      }
    }

    async function importarAssociacoesSkuVts(evento) {
      const input = evento?.target;
      const arquivo = input?.files?.[0];
      if (!arquivo) return;

      if (!db) {
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível conectar ao banco de dados para importar os SKUs.',
          'error',
        );
        input.value = '';
        return;
      }

      try {
        aplicarFeedbackGenericoVts('vtsSkuFeedback', 'Importando planilha de SKUs, aguarde...', 'info');

        const arrayBuffer = await arquivo.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const primeiraPlanilha = workbook.SheetNames[0];
        if (!primeiraPlanilha) {
          aplicarFeedbackGenericoVts(
            'vtsSkuFeedback',
            'Não encontramos dados na planilha enviada. Verifique o arquivo e tente novamente.',
            'warning',
          );
          input.value = '';
          return;
        }

        const sheet = workbook.Sheets[primeiraPlanilha];
        const linhas = XLSX.utils.sheet_to_json(sheet, { defval: '' });
        if (!linhas.length) {
          aplicarFeedbackGenericoVts(
            'vtsSkuFeedback',
            'A planilha está vazia. Utilize o modelo exportado para importar os SKUs.',
            'warning',
          );
          input.value = '';
          return;
        }

        const operacoes = [];
        let registrosProcessados = 0;

        linhas.forEach((linha, indice) => {
          const dadosNormalizados = {};
          Object.entries(linha).forEach(([coluna, valor]) => {
            const chaveNormalizada = normalizeHeaderKey(coluna);
            const destino = VTS_SKU_PLANILHA_HEADER_MAP[chaveNormalizada];
            if (destino) {
              dadosNormalizados[destino] = valor;
            }
          });

          const skuPrincipal = String(dadosNormalizados.skuPrincipal || '').trim();
          if (!skuPrincipal) {
            console.warn(`Linha ${indice + 2} ignorada por não conter SKU principal.`);
            return;
          }

          const associadosValor = dadosNormalizados.associados || '';
          const associados = Array.isArray(associadosValor)
            ? associadosValor.map((item) => String(item).trim()).filter(Boolean)
            : parseListaSkusVts(String(associadosValor));
          const sobraEsperadaNumero = parseNumber(dadosNormalizados.sobraEsperada ?? 0);
          const sobraEsperada = Number.isFinite(sobraEsperadaNumero) && sobraEsperadaNumero >= 0 ? sobraEsperadaNumero : 0;

          operacoes.push(
            db
              .collection('skuAssociado')
              .doc(skuPrincipal)
              .set(
                {
                  skuPrincipal,
                  associados,
                  principaisVinculados: [],
                  sobraEsperada,
                  apenasVts: true,
                  escopo: 'vts',
                },
                { merge: true },
              ),
          );
          registrosProcessados += 1;
        });

        if (!registrosProcessados) {
          aplicarFeedbackGenericoVts(
            'vtsSkuFeedback',
            'Não identificamos SKUs válidos na planilha. Confirme se o cabeçalho está igual ao arquivo modelo.',
            'warning',
          );
          input.value = '';
          return;
        }

        await Promise.all(operacoes);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          `Importação concluída com sucesso. ${registrosProcessados} registro(s) atualizado(s).`,
          'success',
        );
        await carregarAssociacoesSkuVts();
      } catch (erro) {
        console.error('Erro ao importar planilha de SKUs VTS:', erro);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível importar a planilha de SKUs. Verifique o arquivo e tente novamente.',
          'error',
        );
      } finally {
        if (input) {
          input.value = '';
        }
      }
    }

    function resetFormularioAssociacaoVts() {
      const principalInput = document.getElementById('vtsSkuPrincipal');
      const associadosInput = document.getElementById('vtsSkuAssociados');
      const sobraInput = document.getElementById('vtsSkuSobraEsperada');
      const cancelarBotao = document.getElementById('vtsSkuCancelar');

      if (principalInput) principalInput.value = '';
      if (associadosInput) associadosInput.value = '';
      if (sobraInput) sobraInput.value = '';
      if (cancelarBotao) cancelarBotao.classList.add('hidden');

      vtsSkuEdicaoAtual = null;
    }

    function preencherFormularioAssociacaoVts(associacao) {
      const principalInput = document.getElementById('vtsSkuPrincipal');
      const associadosInput = document.getElementById('vtsSkuAssociados');
      const sobraInput = document.getElementById('vtsSkuSobraEsperada');
      const cancelarBotao = document.getElementById('vtsSkuCancelar');

      if (!principalInput || !associadosInput || !associacao) return;

      principalInput.value = associacao.skuPrincipal || '';
      const associados = [...new Set([...(associacao.associados || []), ...(associacao.principaisVinculados || [])])]
        .filter(Boolean)
        .join(', ');
      associadosInput.value = associados;
      if (sobraInput) {
        const sobraNumero = Number(associacao.sobraEsperada);
        sobraInput.value = Number.isFinite(sobraNumero) ? sobraNumero : '';
      }

      if (cancelarBotao) cancelarBotao.classList.remove('hidden');

      vtsSkuEdicaoAtual = { ...associacao };
      aplicarFeedbackGenericoVts(
        'vtsSkuFeedback',
        'Editando associação existente. Ajuste os dados e salve para atualizar.',
        'info',
      );
    }

    async function salvarAssociacaoSkuVts(evento) {
      evento.preventDefault();

      if (!db) return;

      const principalInput = document.getElementById('vtsSkuPrincipal');
      const associadosInput = document.getElementById('vtsSkuAssociados');
      const sobraInput = document.getElementById('vtsSkuSobraEsperada');
      const botaoSalvar = document.getElementById('vtsSkuSalvar');

      if (!principalInput || !associadosInput) return;

      const skuPrincipal = principalInput.value.trim();
      if (!skuPrincipal) {
        aplicarFeedbackGenericoVts('vtsSkuFeedback', 'Informe o SKU principal para salvar a associação.', 'warning');
        principalInput.focus();
        return;
      }

      const associadosList = parseListaSkusVts(associadosInput.value);
      const principalNormalizado = normalizarComparacaoVts(skuPrincipal);
      const associadosFiltrados = associadosList.filter(
        (sku) => normalizarComparacaoVts(sku) && normalizarComparacaoVts(sku) !== principalNormalizado,
      );
      const sobraValor = sobraInput ? parseNumber(sobraInput.value) : 0;
      const sobraEsperada = Number.isFinite(sobraValor) && sobraValor >= 0 ? sobraValor : 0;

      const docId = skuPrincipal;
      const textoOriginal = botaoSalvar?.innerHTML;

      try {
        if (botaoSalvar) {
          botaoSalvar.disabled = true;
          botaoSalvar.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-2"></i>Salvando...';
        }

        if (vtsSkuEdicaoAtual && vtsSkuEdicaoAtual.id && vtsSkuEdicaoAtual.id !== docId) {
          await db.collection('skuAssociado').doc(vtsSkuEdicaoAtual.id).delete();
        }

        await db
          .collection('skuAssociado')
          .doc(docId)
          .set({
            skuPrincipal,
            associados: associadosFiltrados,
            principaisVinculados: [],
            sobraEsperada,
            apenasVts: true,
            escopo: 'vts',
          });

        aplicarFeedbackGenericoVts('vtsSkuFeedback', 'Associação salva com sucesso!', 'success');
        resetFormularioAssociacaoVts();
        await carregarAssociacoesSkuVts();
      } catch (erro) {
        console.error('Erro ao salvar associação de SKU VTS:', erro);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível salvar a associação. Tente novamente mais tarde.',
          'error',
        );
      } finally {
        if (botaoSalvar) {
          botaoSalvar.disabled = false;
          botaoSalvar.innerHTML = textoOriginal || '<i class="fas fa-save mr-2"></i>Salvar associação';
        }
      }
    }

    async function removerAssociacaoSkuVts(id) {
      if (!db || !id) return;

      let confirmado = true;
      if (window.Swal) {
        const resultado = await Swal.fire({
          title: 'Remover associação?',
          text: 'Esta ação não pode ser desfeita.',
          icon: 'warning',
          showCancelButton: true,
          confirmButtonText: 'Remover',
          cancelButtonText: 'Cancelar',
          confirmButtonColor: '#dc2626',
        });
        confirmado = resultado.isConfirmed;
      } else {
        confirmado = window.confirm('Deseja remover esta associação de SKU?');
      }

      if (!confirmado) return;

      try {
        await db.collection('skuAssociado').doc(id).delete();
        vtsSkuAssociacoes = vtsSkuAssociacoes.filter((item) => item.id !== id);
        atualizarMapaAssociacoesVts();
        renderizarAssociacoesSkuVts();
        atualizarResumoMensalVts();
        aplicarFeedbackGenericoVts('vtsSkuFeedback', 'Associação removida com sucesso.', 'success');
        if (vtsSkuEdicaoAtual?.id === id) {
          resetFormularioAssociacaoVts();
        }
      } catch (erro) {
        console.error('Erro ao remover associação de SKU VTS:', erro);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível remover a associação. Tente novamente mais tarde.',
          'error',
        );
      }
    }

    async function carregarAssociacoesSkuVts() {
      if (!db) return;

      try {
        const colecaoSkuAssociado = db.collection('skuAssociado');
        const [apenasVtsSnap, escopoVtsSnap] = await Promise.all([
          colecaoSkuAssociado.where('apenasVts', '==', true).get(),
          colecaoSkuAssociado.where('escopo', '==', 'vts').get(),
        ]);

        const documentosMapeados = new Map();
        [...apenasVtsSnap.docs, ...escopoVtsSnap.docs].forEach((docSnap) => {
          if (!documentosMapeados.has(docSnap.id)) {
            documentosMapeados.set(docSnap.id, docSnap);
          }
        });

        const atualizacoes = [];
        vtsSkuAssociacoes = Array.from(documentosMapeados.values()).map((docSnap) => {
          const data = docSnap.data() || {};
          const skuPrincipal = (data.skuPrincipal || docSnap.id || '').trim();
          const sobraEsperadaNumero = parseNumber(data.sobraEsperada ?? 0);
          const apenasVts = data.apenasVts === true;
          const escopo = String(data.escopo || '').toLowerCase();

          if (!apenasVts || escopo !== 'vts') {
            atualizacoes.push(
              docSnap.ref.set(
                {
                  apenasVts: true,
                  escopo: 'vts',
                },
                { merge: true },
              ),
            );
          }

          return {
            id: docSnap.id,
            skuPrincipal: skuPrincipal || docSnap.id,
            associados: Array.isArray(data.associados) ? data.associados.filter(Boolean) : [],
            principaisVinculados: Array.isArray(data.principaisVinculados)
              ? data.principaisVinculados.filter(Boolean)
              : [],
            sobraEsperada: Number.isFinite(sobraEsperadaNumero) && sobraEsperadaNumero >= 0 ? sobraEsperadaNumero : 0,
          };
        });

        if (atualizacoes.length) {
          try {
            await Promise.allSettled(atualizacoes);
          } catch (atualizacaoErro) {
            console.warn('Não foi possível atualizar todas as associações para o escopo VTS.', atualizacaoErro);
          }
        }

        atualizarMapaAssociacoesVts();
        renderizarAssociacoesSkuVts();
        aplicarFeedbackGenericoVts('vtsSkuFeedback', '', 'info');
        aplicarFiltrosEtiquetasVts();
      } catch (erro) {
        console.error('Erro ao carregar associações de SKU VTS:', erro);
        aplicarFeedbackGenericoVts(
          'vtsSkuFeedback',
          'Não foi possível carregar as associações cadastradas. Tente novamente mais tarde.',
          'error',
        );
      }
    }

    function configurarAssociacoesVts() {
      const formulario = document.getElementById('vtsSkuForm');
      const tabela = document.getElementById('vtsSkuTabelaCorpo');
      const cancelar = document.getElementById('vtsSkuCancelar');

      if (formulario && !formulario.dataset.bound) {
        formulario.addEventListener('submit', salvarAssociacaoSkuVts);
        formulario.dataset.bound = 'true';
      }

      if (cancelar && !cancelar.dataset.bound) {
        cancelar.addEventListener('click', () => {
          resetFormularioAssociacaoVts();
          aplicarFeedbackGenericoVts('vtsSkuFeedback', '', 'info');
        });
        cancelar.dataset.bound = 'true';
      }

      if (tabela && !tabela.dataset.bound) {
        tabela.addEventListener('click', (evento) => {
          const botao = evento.target.closest('button[data-acao]');
          if (!botao) return;

          const acao = botao.getAttribute('data-acao');
          const id = botao.getAttribute('data-id');
          if (!acao || !id) return;

          if (acao === 'editar') {
            const associacao = vtsSkuAssociacoes.find((item) => item.id === id);
            if (associacao) {
              preencherFormularioAssociacaoVts(associacao);
            }
          } else if (acao === 'excluir') {
            removerAssociacaoSkuVts(id);
          }
        });
        tabela.dataset.bound = 'true';
      }

      const botaoExportar = document.getElementById('vtsSkuExportarExcel');
      if (botaoExportar && !botaoExportar.dataset.bound) {
        botaoExportar.addEventListener('click', exportarAssociacoesSkuVtsExcel);
        botaoExportar.dataset.bound = 'true';
      }

      const botaoImportar = document.getElementById('vtsSkuImportarExcel');
      const inputImportar = document.getElementById('vtsSkuImportarExcelInput');
      if (botaoImportar && inputImportar && !botaoImportar.dataset.bound) {
        botaoImportar.addEventListener('click', () => inputImportar.click());
        botaoImportar.dataset.bound = 'true';
      }

      if (inputImportar && !inputImportar.dataset.bound) {
        inputImportar.addEventListener('change', importarAssociacoesSkuVts);
        inputImportar.dataset.bound = 'true';
      }
    }

    function mostrarSubtabVts(subtabId = 'etiquetas') {
      const botoes = document.querySelectorAll('.vts-subtab-btn');
      const paineis = document.querySelectorAll('[data-vts-subtab-panel]');

      botoes.forEach((botao) => {
        const alvo = botao.getAttribute('data-vts-subtab');
        if (alvo === subtabId) {
          botao.classList.add('active');
          botao.classList.add('btn-primary');
          botao.classList.remove('btn-secondary');
        } else {
          botao.classList.remove('active');
          botao.classList.add('btn-secondary');
          botao.classList.remove('btn-primary');
        }
      });

      paineis.forEach((painel) => {
        const alvo = painel.getAttribute('data-vts-subtab-panel');
        if (alvo === subtabId) {
          painel.classList.remove('hidden');
        } else {
          painel.classList.add('hidden');
        }
      });

      if (subtabId === 'resumo') {
        atualizarResumoMensalVts();
      }
    }

    function configurarSubtabsVts() {
      const botoes = document.querySelectorAll('.vts-subtab-btn');
      if (!botoes.length) return;

      botoes.forEach((botao) => {
        if (botao.dataset.bound) return;
        botao.addEventListener('click', () => {
          const destino = botao.getAttribute('data-vts-subtab') || 'etiquetas';
          mostrarSubtabVts(destino);
        });
        botao.dataset.bound = 'true';
      });

      mostrarSubtabVts('etiquetas');
    }

    function sincronizarFiltrosVts() {
      const dataInicioInputs = [
        document.getElementById('vtsFiltroDataInicio'),
        document.getElementById('vtsResumoFiltroDataInicio'),
      ];
      dataInicioInputs.forEach((input) => {
        if (!input) return;
        const valor = vtsFiltroDataInicio || '';
        if (input.value !== valor) {
          input.value = valor;
        }
      });

      const dataFimInputs = [
        document.getElementById('vtsFiltroDataFim'),
        document.getElementById('vtsResumoFiltroDataFim'),
      ];
      dataFimInputs.forEach((input) => {
        if (!input) return;
        const valor = vtsFiltroDataFim || '';
        if (input.value !== valor) {
          input.value = valor;
        }
      });

      const dataColocadaInicioInputs = [
        document.getElementById('vtsFiltroDataColocadaInicio'),
        document.getElementById('vtsResumoFiltroDataColocadaInicio'),
      ];
      dataColocadaInicioInputs.forEach((input) => {
        if (!input) return;
        const valor = vtsFiltroDataColocadaInicio || '';
        if (input.value !== valor) {
          input.value = valor;
        }
      });

      const dataColocadaFimInputs = [
        document.getElementById('vtsFiltroDataColocadaFim'),
        document.getElementById('vtsResumoFiltroDataColocadaFim'),
      ];
      dataColocadaFimInputs.forEach((input) => {
        if (!input) return;
        const valor = vtsFiltroDataColocadaFim || '';
        if (input.value !== valor) {
          input.value = valor;
        }
      });

      const seletoresLoja = [document.getElementById('vtsFiltroLoja'), document.getElementById('vtsResumoFiltroLoja')];
      seletoresLoja.forEach((select) => {
        if (!select) return;
        const valor = vtsFiltroLoja || '';
        if (select.value !== valor) {
          select.value = valor;
        }
      });
    }

    function filtrosVtsAtivos() {
      return Boolean(
        vtsFiltroDataInicio ||
          vtsFiltroDataFim ||
          vtsFiltroDataColocadaInicio ||
          vtsFiltroDataColocadaFim ||
          vtsFiltroLoja,
      );
    }

    function formatarDataBrSimplesVts(iso) {
      if (!iso || typeof iso !== 'string') return '';
      const [ano, mes, dia] = iso.split('-');
      if (!ano || !mes || !dia) return iso;
      return `${dia}/${mes}/${ano}`;
    }

    function construirDescricaoFiltrosVts() {
      const partes = [];

      if (vtsFiltroDataInicio && vtsFiltroDataFim) {
        partes.push(
          `Etiqueta: ${formatarDataBrSimplesVts(vtsFiltroDataInicio)} a ${formatarDataBrSimplesVts(vtsFiltroDataFim)}`,
        );
      } else if (vtsFiltroDataInicio) {
        partes.push(`Etiqueta a partir de ${formatarDataBrSimplesVts(vtsFiltroDataInicio)}`);
      } else if (vtsFiltroDataFim) {
        partes.push(`Etiqueta até ${formatarDataBrSimplesVts(vtsFiltroDataFim)}`);
      } else {
        partes.push('Etiqueta: período completo');
      }

      if (vtsFiltroDataColocadaInicio && vtsFiltroDataColocadaFim) {
        partes.push(
          `Data colocada: ${formatarDataBrSimplesVts(vtsFiltroDataColocadaInicio)} a ${formatarDataBrSimplesVts(
            vtsFiltroDataColocadaFim,
          )}`,
        );
      } else if (vtsFiltroDataColocadaInicio) {
        partes.push(`Data colocada a partir de ${formatarDataBrSimplesVts(vtsFiltroDataColocadaInicio)}`);
      } else if (vtsFiltroDataColocadaFim) {
        partes.push(`Data colocada até ${formatarDataBrSimplesVts(vtsFiltroDataColocadaFim)}`);
      } else {
        partes.push('Data colocada: todas');
      }

      if (vtsFiltroLoja) {
        partes.push(`Loja: ${vtsFiltroLoja}`);
      } else {
        partes.push('Todas as lojas');
      }

      return partes.join(' • ');
    }

    function obterIntervaloFiltroDatasVts() {
      const inicioNormalizado = normalizeDate(vtsFiltroDataInicio) || '';
      const fimNormalizado = normalizeDate(vtsFiltroDataFim) || '';

      const inicio = inicioNormalizado ? new Date(`${inicioNormalizado}T00:00:00`) : null;
      const fim = fimNormalizado ? new Date(`${fimNormalizado}T23:59:59.999`) : null;

      return { inicio, fim };
    }

    function obterIntervaloFiltroDataColocadaVts() {
      const inicioNormalizado = normalizeDate(vtsFiltroDataColocadaInicio) || '';
      const fimNormalizado = normalizeDate(vtsFiltroDataColocadaFim) || '';

      const inicio = inicioNormalizado ? new Date(`${inicioNormalizado}T00:00:00`) : null;
      const fim = fimNormalizado ? new Date(`${fimNormalizado}T23:59:59.999`) : null;

      return { inicio, fim };
    }

    function atualizarOpcoesFiltroLojaVts(registros = []) {
      const lojas = Array.from(
        new Set(
          (registros || [])
            .map((item) => (item.loja || '').trim())
            .filter((valor) => valor),
        ),
      ).sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));

      const lojaNormalizadaSelecionada = normalizarComparacaoVts(vtsFiltroLoja);
      if (
        vtsFiltroLoja &&
        !lojas.some((loja) => normalizarComparacaoVts(loja) === lojaNormalizadaSelecionada)
      ) {
        vtsFiltroLoja = '';
      }

      ['vtsFiltroLoja', 'vtsResumoFiltroLoja'].forEach((id) => {
        const select = document.getElementById(id);
        if (!select) return;

        select.innerHTML = '';
        const optionTodas = document.createElement('option');
        optionTodas.value = '';
        optionTodas.textContent = 'Todas as lojas';
        select.appendChild(optionTodas);

        lojas.forEach((loja) => {
          const option = document.createElement('option');
          option.value = loja;
          option.textContent = loja;
          select.appendChild(option);
        });

        const valorDesejado = vtsFiltroLoja || '';
        select.value = valorDesejado;
        if (valorDesejado && select.value !== valorDesejado) {
          select.value = '';
        }
      });

      sincronizarFiltrosVts();
    }

    function obterEtiquetasFiltradasVts() {
      const { inicio, fim } = obterIntervaloFiltroDatasVts();
      const { inicio: inicioColocada, fim: fimColocada } = obterIntervaloFiltroDataColocadaVts();
      const lojaNormalizada = normalizarComparacaoVts(vtsFiltroLoja);

      return vtsEtiquetasRegistros.filter((registro) => {
        if (lojaNormalizada) {
          const lojaRegistro = normalizarComparacaoVts(registro.loja);
          if (lojaRegistro !== lojaNormalizada) return false;
        }

        const dataRegistro = obterDataRegistroVts(registro);
        if (inicio && (!dataRegistro || dataRegistro < inicio)) return false;
        if (fim && (!dataRegistro || dataRegistro > fim)) return false;

        const dataColocada = obterDataColocadaRegistroVts(registro);
        if (inicioColocada && (!dataColocada || dataColocada < inicioColocada)) return false;
        if (fimColocada && (!dataColocada || dataColocada > fimColocada)) return false;

        return true;
      });
    }

    function configurarFiltrosVts() {
      const configuracoes = [
        { id: 'vtsFiltroDataInicio', tipo: 'dataInicio' },
        { id: 'vtsResumoFiltroDataInicio', tipo: 'dataInicio' },
        { id: 'vtsFiltroDataFim', tipo: 'dataFim' },
        { id: 'vtsResumoFiltroDataFim', tipo: 'dataFim' },
        { id: 'vtsFiltroDataColocadaInicio', tipo: 'dataColocadaInicio' },
        { id: 'vtsResumoFiltroDataColocadaInicio', tipo: 'dataColocadaInicio' },
        { id: 'vtsFiltroDataColocadaFim', tipo: 'dataColocadaFim' },
        { id: 'vtsResumoFiltroDataColocadaFim', tipo: 'dataColocadaFim' },
        { id: 'vtsFiltroLoja', tipo: 'loja' },
        { id: 'vtsResumoFiltroLoja', tipo: 'loja' },
      ];

      configuracoes.forEach(({ id, tipo }) => {
        const elemento = document.getElementById(id);
        if (!elemento || elemento.dataset.bound) return;

        if (tipo === 'dataInicio') {
          elemento.addEventListener('change', (evento) => {
            vtsFiltroDataInicio = normalizeDate(evento.target.value) || '';
            sincronizarFiltrosVts();
            aplicarFiltrosEtiquetasVts();
          });
        } else if (tipo === 'dataFim') {
          elemento.addEventListener('change', (evento) => {
            vtsFiltroDataFim = normalizeDate(evento.target.value) || '';
            sincronizarFiltrosVts();
            aplicarFiltrosEtiquetasVts();
          });
        } else if (tipo === 'dataColocadaInicio') {
          elemento.addEventListener('change', (evento) => {
            vtsFiltroDataColocadaInicio = normalizeDate(evento.target.value) || '';
            sincronizarFiltrosVts();
            aplicarFiltrosEtiquetasVts();
          });
        } else if (tipo === 'dataColocadaFim') {
          elemento.addEventListener('change', (evento) => {
            vtsFiltroDataColocadaFim = normalizeDate(evento.target.value) || '';
            sincronizarFiltrosVts();
            aplicarFiltrosEtiquetasVts();
          });
        } else if (tipo === 'loja') {
          elemento.addEventListener('change', (evento) => {
            vtsFiltroLoja = evento.target.value || '';
            sincronizarFiltrosVts();
            aplicarFiltrosEtiquetasVts();
          });
        }

        elemento.dataset.bound = 'true';
      });

      ['vtsFiltroLimpar', 'vtsResumoFiltroLimpar'].forEach((id) => {
        const botao = document.getElementById(id);
        if (!botao || botao.dataset.bound) return;

        botao.addEventListener('click', () => {
          vtsFiltroDataInicio = '';
          vtsFiltroDataFim = '';
          vtsFiltroDataColocadaInicio = '';
          vtsFiltroDataColocadaFim = '';
          vtsFiltroLoja = '';
          sincronizarFiltrosVts();
          aplicarFiltrosEtiquetasVts();
        });

        botao.dataset.bound = 'true';
      });

      sincronizarFiltrosVts();
    }

    function obterDataColocadaRegistroVts(registro) {
      if (!registro) return null;

      if (registro.datacolocada instanceof Date && !Number.isNaN(registro.datacolocada.getTime())) {
        return new Date(
          registro.datacolocada.getFullYear(),
          registro.datacolocada.getMonth(),
          registro.datacolocada.getDate(),
        );
      }

      const normalizados = [registro.datacolocada, registro.datacolocadaTexto]
        .map((valor) => normalizeDate(valor))
        .filter(Boolean);

      for (const valor of normalizados) {
        const data = new Date(`${valor}T00:00:00`);
        if (!Number.isNaN(data)) {
          return data;
        }
      }

      return null;
    }

    function obterDataRegistroVts(registro) {
      if (!registro) return null;

      const normalizados = [registro.dataEtiqueta, registro.dataEtiquetaTexto]
        .map((valor) => normalizeDate(valor))
        .filter(Boolean);

      for (const valor of normalizados) {
        const data = new Date(`${valor}T00:00:00`);
        if (!Number.isNaN(data)) {
          return data;
        }
      }

      if (registro.importadoEm instanceof Date && !Number.isNaN(registro.importadoEm)) {
        return registro.importadoEm;
      }

      return null;
    }

    function atualizarResumoMensalVts(registrosFiltrados) {
      const tabelaCorpo = document.getElementById('vtsResumoTabelaCorpo');
      const totalVendidoEl = document.getElementById('vtsResumoTotalVendido');
      const totalCanceladoEl = document.getElementById('vtsResumoTotalCancelado');
      const totalEsperadoEl = document.getElementById('vtsResumoTotalEsperado');
      if (!tabelaCorpo || !totalVendidoEl || !totalCanceladoEl || !totalEsperadoEl) return;

      const registros = Array.isArray(registrosFiltrados) ? registrosFiltrados : obterEtiquetasFiltradasVts();

      vtsResumoDadosExportacao = [];
      vtsResumoTotaisExportacao = { vendido: 0, cancelado: 0, esperado: 0 };

      const resumoMapa = new Map();
      let totalVendido = 0;
      let totalCancelado = 0;

      registros.forEach((registro) => {
        const skuOriginal = (registro.sku || '').trim();
        if (!skuOriginal) return;

        const associacao = vtsSkuMapa.get(normalizarComparacaoVts(skuOriginal));
        const chave = associacao?.skuPrincipal || skuOriginal;

        if (!resumoMapa.has(chave)) {
          const considerados = new Set([chave]);
          if (associacao?.todos?.length) {
            associacao.todos.forEach((sku) => considerados.add(sku));
          }
          const sobraEsperadaNumero = Number(associacao?.sobraEsperada ?? 0);
          resumoMapa.set(chave, {
            skuPrincipal: chave,
            considerados,
            vendido: 0,
            cancelado: 0,
            sobraEsperadaCadastro:
              Number.isFinite(sobraEsperadaNumero) && sobraEsperadaNumero >= 0 ? sobraEsperadaNumero : 0,
          });
        }

        const linhaResumo = resumoMapa.get(chave);
        const status = (registro.status || '').toLowerCase();
        if (status === 'cancelado') {
          linhaResumo.cancelado += 1;
          totalCancelado += 1;
        } else {
          linhaResumo.vendido += 1;
          totalVendido += 1;
        }
      });

      const linhasOrdenadas = Array.from(resumoMapa.values()).sort((a, b) =>
        a.skuPrincipal.localeCompare(b.skuPrincipal, 'pt-BR', { sensitivity: 'base' }),
      );

      const dadosExportacao = linhasOrdenadas.map((item) => {
        const consideradosArray = Array.from(item.considerados)
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));
        const vendidoNumero = Number(item.vendido ?? 0);
        const canceladoNumero = Number(item.cancelado ?? 0);
        const sobraCadastro = Number(item.sobraEsperadaCadastro ?? 0);
        const sobraCadastroValida = Number.isFinite(sobraCadastro) && sobraCadastro >= 0 ? sobraCadastro : 0;
        const esperadoNumero = sobraCadastroValida * (Number.isFinite(vendidoNumero) ? vendidoNumero : 0);

        return {
          skuPrincipal: item.skuPrincipal,
          skusConsiderados: consideradosArray.join(', '),
          sobraUnitaria: sobraCadastroValida,
          sobraEstimativa: Number.isFinite(esperadoNumero) ? esperadoNumero : 0,
          totalVendido: Number.isFinite(vendidoNumero) ? vendidoNumero : 0,
          totalCancelado: Number.isFinite(canceladoNumero) ? canceladoNumero : 0,
        };
      });

      tabelaCorpo.innerHTML = '';

      if (!dadosExportacao.length) {
        const linha = document.createElement('tr');
        const coluna = document.createElement('td');
        coluna.colSpan = 5;
        coluna.className = 'px-4 py-4 text-center text-sm text-slate-500';
        coluna.textContent = 'Nenhum registro encontrado para os filtros selecionados.';
        linha.appendChild(coluna);
        tabelaCorpo.appendChild(linha);
      } else {
        dadosExportacao.forEach((item) => {
          const esperadoNumero = Number.isFinite(item.sobraEstimativa) ? item.sobraEstimativa : 0;
          const esperadoTexto = esperadoNumero.toLocaleString('pt-BR', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2,
          });
          const linha = document.createElement('tr');
          linha.className = 'border-b border-slate-100 hover:bg-slate-50 transition-colors';
          linha.innerHTML = `
            <td class="px-4 py-3 font-semibold text-slate-700">${item.skuPrincipal}</td>
            <td class="px-4 py-3 text-slate-600">${item.skusConsiderados}</td>
            <td class="px-4 py-3 text-right text-slate-700 font-semibold">${esperadoTexto}</td>
            <td class="px-4 py-3 text-right text-slate-700 font-semibold">${item.totalVendido}</td>
            <td class="px-4 py-3 text-right text-slate-700 font-semibold">${item.totalCancelado}</td>
          `;
          tabelaCorpo.appendChild(linha);
        });
      }

      totalVendidoEl.textContent = totalVendido.toString();
      totalCanceladoEl.textContent = totalCancelado.toString();
      const totalEsperado = dadosExportacao.reduce(
        (acc, item) => acc + (Number.isFinite(item.sobraEstimativa) ? item.sobraEstimativa : 0),
        0,
      );
      totalEsperadoEl.textContent = Number(totalEsperado).toLocaleString('pt-BR', {
        minimumFractionDigits: 0,
        maximumFractionDigits: 2,
      });

      vtsResumoDadosExportacao = dadosExportacao;
      vtsResumoTotaisExportacao = {
        vendido: totalVendido,
        cancelado: totalCancelado,
        esperado: Number.isFinite(totalEsperado) ? totalEsperado : 0,
      };

      const possuiResultados = dadosExportacao.length > 0;
      const descricaoFiltros = construirDescricaoFiltrosVts();
      aplicarFeedbackGenericoVts(
        'vtsResumoFeedback',
        possuiResultados
          ? `Resumo atualizado. ${descricaoFiltros}`
          : `Não encontramos etiquetas para os filtros selecionados. ${descricaoFiltros}`,
        possuiResultados ? 'info' : 'warning',
      );
    }

    function exportarResumoVtsExcel() {
      if (!vtsResumoDadosExportacao.length) {
        aplicarFeedbackGenericoVts(
          'vtsResumoFeedback',
          'Não há dados para exportar. Ajuste os filtros e tente novamente.',
          'warning',
        );
        return;
      }

      try {
        const cabecalho = [
          'SKU principal',
          'SKUs considerados',
          'Sobra esperada por unidade',
          'Sobra esperada estimada',
          'Total vendido',
          'Total cancelado',
        ];
        const linhas = vtsResumoDadosExportacao.map((item) => [
          item.skuPrincipal,
          item.skusConsiderados,
          Number.isFinite(item.sobraUnitaria) ? item.sobraUnitaria : 0,
          Number.isFinite(item.sobraEstimativa) ? item.sobraEstimativa : 0,
          Number.isFinite(item.totalVendido) ? item.totalVendido : 0,
          Number.isFinite(item.totalCancelado) ? item.totalCancelado : 0,
        ]);
        const totais = [
          'Totais',
          '',
          '',
          Number(vtsResumoTotaisExportacao.esperado || 0),
          Number(vtsResumoTotaisExportacao.vendido || 0),
          Number(vtsResumoTotaisExportacao.cancelado || 0),
        ];

        const worksheet = XLSX.utils.aoa_to_sheet([cabecalho, ...linhas, [], totais]);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Resumo VTS');
        const buffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        const blob = new Blob([buffer], {
          type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        });
        saveAs(blob, `vts-resumo-${gerarTimestampArquivoVts()}.xlsx`);
        aplicarFeedbackGenericoVts('vtsResumoFeedback', 'Resumo exportado em Excel com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao exportar resumo VTS em Excel:', erro);
        aplicarFeedbackGenericoVts(
          'vtsResumoFeedback',
          'Não foi possível exportar o resumo em Excel. Tente novamente mais tarde.',
          'error',
        );
      }
    }

    async function exportarResumoVtsPdf() {
      if (!vtsResumoDadosExportacao.length) {
        aplicarFeedbackGenericoVts(
          'vtsResumoFeedback',
          'Não há dados para exportar. Ajuste os filtros e tente novamente.',
          'warning',
        );
        return;
      }

      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.left = '-9999px';
      container.style.top = '0';
      container.style.padding = '24px';
      container.style.fontFamily = 'Inter, sans-serif';
      container.style.color = '#1f2937';
      container.style.maxWidth = '900px';

      const titulo = document.createElement('h2');
      titulo.textContent = 'Resumo por SKU';
      titulo.style.marginBottom = '8px';
      titulo.style.fontSize = '18px';
      container.appendChild(titulo);

      const descricao = document.createElement('p');
      descricao.textContent = construirDescricaoFiltrosVts();
      descricao.style.marginBottom = '16px';
      descricao.style.fontSize = '12px';
      container.appendChild(descricao);

      const tabela = document.createElement('table');
      tabela.style.width = '100%';
      tabela.style.borderCollapse = 'collapse';
      tabela.style.fontSize = '11px';

      const cabecalho = document.createElement('thead');
      const cabecalhoLinha = document.createElement('tr');
      ['SKU principal', 'SKUs considerados', 'Sobra esperada estimada', 'Total vendido', 'Total cancelado'].forEach((texto, indice) => {
        const th = document.createElement('th');
        th.textContent = texto;
        th.style.border = '1px solid #e2e8f0';
        th.style.backgroundColor = '#f1f5f9';
        th.style.padding = '8px';
        th.style.fontWeight = '600';
        th.style.textAlign = indice <= 1 ? 'left' : 'right';
        cabecalhoLinha.appendChild(th);
      });
      cabecalho.appendChild(cabecalhoLinha);
      tabela.appendChild(cabecalho);

      const corpo = document.createElement('tbody');
      vtsResumoDadosExportacao.forEach((item) => {
        const linha = document.createElement('tr');
        linha.style.borderBottom = '1px solid #e2e8f0';

        const esperadoNumero = Number.isFinite(item.sobraEstimativa) ? item.sobraEstimativa : 0;

        const colunas = [
          { valor: item.skuPrincipal || '', alinhamento: 'left' },
          { valor: item.skusConsiderados || '-', alinhamento: 'left' },
          {
            valor: esperadoNumero.toLocaleString('pt-BR', { minimumFractionDigits: 0, maximumFractionDigits: 2 }),
            alinhamento: 'right',
          },
          {
            valor: Number(item.totalVendido || 0).toLocaleString('pt-BR', {
              minimumFractionDigits: 0,
              maximumFractionDigits: 0,
            }),
            alinhamento: 'right',
          },
          {
            valor: Number(item.totalCancelado || 0).toLocaleString('pt-BR', {
              minimumFractionDigits: 0,
              maximumFractionDigits: 0,
            }),
            alinhamento: 'right',
          },
        ];

        colunas.forEach(({ valor, alinhamento }) => {
          const td = document.createElement('td');
          td.textContent = valor;
          td.style.padding = '8px';
          td.style.border = '1px solid #e2e8f0';
          td.style.textAlign = alinhamento;
          linha.appendChild(td);
        });

        corpo.appendChild(linha);
      });
      tabela.appendChild(corpo);
      container.appendChild(tabela);

      const totais = document.createElement('div');
      totais.style.marginTop = '16px';
      totais.style.fontSize = '12px';
      totais.innerHTML = `
        <p><strong>Total vendido:</strong> ${Number(vtsResumoTotaisExportacao.vendido || 0).toLocaleString('pt-BR')}</p>
        <p><strong>Total cancelado:</strong> ${Number(vtsResumoTotaisExportacao.cancelado || 0).toLocaleString('pt-BR')}</p>
        <p><strong>Sobra esperada estimada:</strong> ${Number(vtsResumoTotaisExportacao.esperado || 0).toLocaleString('pt-BR', {
          minimumFractionDigits: 0,
          maximumFractionDigits: 2,
        })}</p>
      `;
      container.appendChild(totais);

      document.body.appendChild(container);

      try {
        await html2pdf()
          .set({
            margin: 10,
            filename: `vts-resumo-${gerarTimestampArquivoVts()}.pdf`,
            html2canvas: { scale: 2 },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
          })
          .from(container)
          .save();
        aplicarFeedbackGenericoVts('vtsResumoFeedback', 'Resumo exportado em PDF com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao exportar resumo VTS em PDF:', erro);
        aplicarFeedbackGenericoVts(
          'vtsResumoFeedback',
          'Não foi possível exportar o resumo em PDF. Tente novamente mais tarde.',
          'error',
        );
      } finally {
        container.remove();
      }
    }

    function configurarResumoVtsExportacoes() {
      const botaoExcel = document.getElementById('vtsResumoExportarExcel');
      if (botaoExcel && !botaoExcel.dataset.bound) {
        botaoExcel.addEventListener('click', exportarResumoVtsExcel);
        botaoExcel.dataset.bound = 'true';
      }

      const botaoPdf = document.getElementById('vtsResumoExportarPdf');
      if (botaoPdf && !botaoPdf.dataset.bound) {
        botaoPdf.addEventListener('click', () => {
          exportarResumoVtsPdf();
        });
        botaoPdf.dataset.bound = 'true';
      }
    }

    function atualizarResumoEtiquetasVts(totalFiltrado = obterEtiquetasFiltradasVts().length, totalGeral = vtsEtiquetasRegistros.length) {
      const resumo = document.getElementById('vtsResumo');
      if (!resumo) return;

      if (!totalGeral) {
        resumo.textContent = 'Nenhuma etiqueta importada até o momento.';
        return;
      }

      if (filtrosVtsAtivos()) {
        if (!totalFiltrado) {
          resumo.textContent = `Nenhuma etiqueta encontrada com os filtros aplicados. ${totalGeral} registro(s) importados ao todo.`;
        } else if (totalFiltrado === totalGeral) {
          resumo.textContent = `${totalGeral} etiqueta(s) importadas.`;
        } else {
          resumo.textContent = `${totalFiltrado} etiqueta(s) encontradas entre ${totalGeral} importadas.`;
        }
      } else {
        resumo.textContent = `${totalGeral} etiqueta(s) importadas.`;
      }
    }

    async function carregarEtiquetasVts() {
      if (!db || !usuarioLogado?.uid) return;

      const corpoTabela = document.getElementById('vtsTabelaCorpo');
      const indicadorCarregamento = document.getElementById('vtsLoading');

      if (!corpoTabela) return;

      try {
        if (indicadorCarregamento) {
          indicadorCarregamento.classList.remove('hidden');
          indicadorCarregamento.style.display = 'flex';
        }
        const consulta = await db
          .collection('vtsEtiquetas')
          .where('usuarioId', '==', usuarioLogado.uid)
          .orderBy('importadoEm', 'desc')
          .limit(500)
          .get();

        vtsEtiquetasRegistros = consulta.docs.map((doc) => {
          const data = doc.data() || {};
          return {
            id: doc.id,
            sku: data.sku || '',
            pedido: data.pedido || '',
            rastreio: data.rastreio || '',
            loja: data.loja || '',
            dataEtiqueta: data.dataEtiqueta || '',
            dataEtiquetaTexto: data.dataEtiquetaTexto || '',
            datacolocada: data.datacolocada?.toDate?.() || data.datacolocada || '',
            datacolocadaTexto: data.datacolocadaTexto || '',
            buyerUsername: data.buyerUsername || '',
            importadoEm: data.importadoEm?.toDate?.() || null,
            origemArquivo: data.origemArquivo || '',
            paginaArquivo: data.paginaArquivo || null,
            modeloEtiqueta: data.modeloEtiqueta || data.modelo || data.plataforma || '',
            status: data.status || '',
            canceladoEm: data.canceladoEm?.toDate?.() || null,
            canceladoPor: data.canceladoPor || '',
            canceladoMotivo: data.canceladoMotivo || '',
          };
        });

        vtsCarregado = true;
        aplicarFiltrosEtiquetasVts();
      } catch (erro) {
        console.error('Erro ao carregar etiquetas VTS:', erro);
        setVtsFeedback('Não foi possível carregar as etiquetas importadas. Tente novamente mais tarde.', 'error');
      } finally {
        if (indicadorCarregamento) {
          indicadorCarregamento.style.display = 'none';
          indicadorCarregamento.classList.add('hidden');
        }
      }
    }

    function atualizarDatalistLojasVts(registros = []) {
      const lojas = Array.from(
        new Set(
          registros
            .map((item) => (item.loja || '').trim())
            .filter((valor) => valor),
        ),
      ).sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));

      ['vtsDevolucaoLojas', 'vtsManualLojas'].forEach((id) => {
        const datalist = document.getElementById(id);
        if (!datalist) return;

        datalist.innerHTML = '';
        lojas.forEach((loja) => {
          const option = document.createElement('option');
          option.value = loja;
          datalist.appendChild(option);
        });
      });
    }

    function sanitizarSelecaoEtiquetasVts() {
      if (!vtsEtiquetasSelecionadas?.size) return;
      const idsDisponiveis = new Set(vtsEtiquetasRegistros.map((item) => item.id));
      vtsEtiquetasSelecionadas.forEach((id) => {
        if (!idsDisponiveis.has(id)) {
          vtsEtiquetasSelecionadas.delete(id);
        }
      });
    }

    function atualizarControleSelecaoVts(registrosVisiveis = []) {
      const botaoExcluir = document.getElementById('vtsExcluirSelecionados');
      const totalSelecionados = vtsEtiquetasSelecionadas.size;
      if (botaoExcluir) {
        botaoExcluir.disabled = totalSelecionados === 0;
        const textoBotao = botaoExcluir.querySelector('span');
        if (textoBotao) {
          const contador = totalSelecionados > 0 ? ` (${totalSelecionados})` : '';
          textoBotao.textContent = `Excluir selecionados${contador}`;
        }
      }

      const checkboxSelecionarTodos = document.getElementById('vtsSelecionarTodos');
      if (!checkboxSelecionarTodos) return;

      const totalVisiveis = Array.isArray(registrosVisiveis) ? registrosVisiveis.length : 0;
      const totalSelecionadosVisiveis = Array.isArray(registrosVisiveis)
        ? registrosVisiveis.filter((item) => vtsEtiquetasSelecionadas.has(item.id)).length
        : 0;

      checkboxSelecionarTodos.disabled = totalVisiveis === 0;
      checkboxSelecionarTodos.checked = totalVisiveis > 0 && totalSelecionadosVisiveis === totalVisiveis;
      checkboxSelecionarTodos.indeterminate =
        totalVisiveis > 0 && totalSelecionadosVisiveis > 0 && totalSelecionadosVisiveis < totalVisiveis;
    }

    function obterSkuAssociadoTextoVts(registro) {
      const skuOriginal = (registro?.sku || '').trim();
      if (!skuOriginal) {
        return '';
      }

      const chaveMapa = normalizarComparacaoVts(skuOriginal);
      if (!chaveMapa) {
        return skuOriginal;
      }

      const associacao = vtsSkuMapa.get(chaveMapa);
      const principal = ((associacao?.skuPrincipal || '').trim()) || skuOriginal;

      return principal;
    }

    function obterHtmlSkuAssociadoVts(registro) {
      const skuTexto = obterSkuAssociadoTextoVts(registro);
      if (!skuTexto) {
        return '<span class="text-slate-400">-</span>';
      }

      return `<span class="font-semibold text-slate-700">${escapeHtml(skuTexto)}</span>`;
    }

    function renderizarEtiquetasVts(registros = []) {
      const corpoTabela = document.getElementById('vtsTabelaCorpo');
      if (!corpoTabela) return;

      sanitizarSelecaoEtiquetasVts();
      corpoTabela.innerHTML = '';

      if (!registros.length) {
        const linha = document.createElement('tr');
        const coluna = document.createElement('td');
        coluna.colSpan = 10;
        coluna.className = 'px-4 py-4 text-center text-sm text-slate-500';
        coluna.textContent = 'Nenhum registro encontrado.';
        linha.appendChild(coluna);
        corpoTabela.appendChild(linha);
        atualizarControleSelecaoVts(registros);
        return;
      }

      registros.forEach((item) => {
        const linha = document.createElement('tr');
        linha.className = 'border-b border-slate-100 transition-colors hover:bg-slate-50';
        let tituloModelo = '';
        if (item.modeloEtiqueta) {
          linha.dataset.modeloEtiqueta = item.modeloEtiqueta;
          tituloModelo = `Modelo da etiqueta: ${obterNomeModeloVts(item.modeloEtiqueta)}`;
          linha.title = tituloModelo;
        }

        const estaCancelado = (item.status || '').toString().toLowerCase() === 'cancelado';
        linha.dataset.status = item.status || '';
        const dataCancelamento =
          item.canceladoEm instanceof Date && !Number.isNaN(item.canceladoEm.getTime())
            ? item.canceladoEm
            : null;
        if (estaCancelado) {
          linha.classList.add('bg-rose-50/70', 'hover:bg-rose-100');
          linha.classList.remove('hover:bg-slate-50');
          const dataDescricao = dataCancelamento
            ? ` em ${dataCancelamento.toLocaleDateString('pt-BR')} às ${dataCancelamento.toLocaleTimeString('pt-BR')}`
            : '';
          const tituloCancelado = `Pedido cancelado${dataDescricao} (devolução sinalizada)`;
          linha.title = tituloModelo ? `${tituloCancelado}\n${tituloModelo}` : tituloCancelado;
        } else if (tituloModelo) {
          linha.title = tituloModelo;
        }

        const colunaSelecao = document.createElement('td');
        colunaSelecao.className = 'px-4 py-3 text-sm text-slate-700';
        if (estaCancelado) {
          colunaSelecao.classList.add('text-rose-700');
        }
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'form-checkbox h-4 w-4 text-indigo-600';
        checkbox.checked = vtsEtiquetasSelecionadas.has(item.id);
        checkbox.addEventListener('change', (evento) => {
          if (evento.target.checked) {
            vtsEtiquetasSelecionadas.add(item.id);
          } else {
            vtsEtiquetasSelecionadas.delete(item.id);
          }
          atualizarControleSelecaoVts(obterEtiquetasFiltradasVts());
        });
        colunaSelecao.appendChild(checkbox);
        linha.appendChild(colunaSelecao);

        const campos = [
          { valor: obterHtmlSkuAssociadoVts(item), html: true, classeExtra: 'min-w-[200px]' },
          { valor: item.pedido || '-', html: false },
          { valor: item.rastreio || '-', html: false },
          { valor: item.loja || '-', html: false },
          { valor: formatarDataVts(item.dataEtiqueta, item.dataEtiquetaTexto), html: false },
          { valor: formatarDataVts(item.datacolocada, item.datacolocadaTexto), html: false },
          { valor: item.origemArquivo || '-', html: false },
          {
            valor: estaCancelado
              ? '<span class="inline-flex items-center gap-1 rounded-full bg-rose-100 px-2.5 py-1 text-xs font-semibold text-rose-700"><i class="fas fa-exclamation-triangle"></i> Pedido cancelado</span>'
              : item.status
                ? `<span class="inline-flex items-center rounded-full bg-slate-100 px-2.5 py-1 text-xs font-medium text-slate-600">${item.status}</span>`
                : '<span class="text-slate-400">-</span>',
            html: true,
            classeExtra: 'min-w-[160px]',
            titulo: estaCancelado
              ? dataCancelamento
                ? `Pedido cancelado em ${dataCancelamento.toLocaleDateString('pt-BR')} às ${dataCancelamento.toLocaleTimeString('pt-BR')}`
                : 'Pedido cancelado'
              : item.status
                ? `Status: ${item.status}`
                : '',
          },
        ];

        campos.forEach((campo) => {
          const coluna = document.createElement('td');
          coluna.className = 'px-4 py-3 text-sm text-slate-700 break-words max-w-xs';
          if (campo.classeExtra) {
            coluna.classList.add(...campo.classeExtra.split(' '));
          }
          if (estaCancelado) {
            coluna.classList.add('text-rose-700');
          }
          if (campo.titulo) {
            coluna.title = campo.titulo;
          }
          if (campo.html) {
            coluna.innerHTML = campo.valor;
          } else {
            coluna.textContent = campo.valor;
          }
          linha.appendChild(coluna);
        });

        const colunaAcoes = document.createElement('td');
        colunaAcoes.className = 'px-4 py-3 text-sm';
        if (estaCancelado) {
          colunaAcoes.classList.add('text-rose-700');
        }

        const containerAcoes = document.createElement('div');
        containerAcoes.className = 'flex flex-wrap items-center gap-2';

        const botaoEditar = document.createElement('button');
        botaoEditar.type = 'button';
        botaoEditar.className = 'btn btn-sm flex items-center gap-2 text-slate-600 hover:text-slate-700';
        botaoEditar.innerHTML = '<i class="fas fa-edit"></i><span>Editar</span>';
        botaoEditar.addEventListener('click', () => editarEtiquetaVts(item));
        containerAcoes.appendChild(botaoEditar);

        const botaoExcluir = document.createElement('button');
        botaoExcluir.type = 'button';
        botaoExcluir.className = 'btn btn-sm flex items-center gap-2 text-rose-600 hover:text-rose-700';
        botaoExcluir.innerHTML = '<i class="fas fa-trash-alt"></i><span>Excluir</span>';
        botaoExcluir.addEventListener('click', () => excluirEtiquetaVts(item.id, item.pedido));
        containerAcoes.appendChild(botaoExcluir);

        colunaAcoes.appendChild(containerAcoes);
        linha.appendChild(colunaAcoes);

        corpoTabela.appendChild(linha);
      });

      atualizarControleSelecaoVts(registros);
    }

    function aplicarFiltrosEtiquetasVts() {
      atualizarOpcoesFiltroLojaVts(vtsEtiquetasRegistros);
      atualizarDatalistLojasVts(vtsEtiquetasRegistros);

      const registrosFiltrados = obterEtiquetasFiltradasVts();
      renderizarEtiquetasVts(registrosFiltrados);
      atualizarResumoEtiquetasVts(registrosFiltrados.length, vtsEtiquetasRegistros.length);
      atualizarResumoMensalVts(registrosFiltrados);
    }

    async function editarEtiquetaVts(registro) {
      if (!db || !registro?.id) return;

      const valoresIniciais = {
        sku: registro.sku || '',
        pedido: registro.pedido || '',
        rastreio: registro.rastreio || '',
        loja: registro.loja || '',
        dataEtiqueta: registro.dataEtiqueta || '',
        dataEtiquetaTexto: registro.dataEtiquetaTexto || '',
        datacolocada: registro.datacolocada || '',
        datacolocadaTexto: registro.datacolocadaTexto || '',
        origemArquivo: registro.origemArquivo || '',
        buyerUsername: registro.buyerUsername || '',
      };

      let valoresAtualizados = { ...valoresIniciais };

      if (window.Swal?.fire) {
        const { value, isConfirmed } = await window.Swal.fire({
          title: 'Editar registro',
          html: `
            <div class="space-y-3 text-left">
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                SKU
                <input id="vtsEditSku" class="swal2-input" style="margin:0" />
              </label>
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                Número do pedido
                <input id="vtsEditPedido" class="swal2-input" style="margin:0" />
              </label>
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                Código de rastreio
                <input id="vtsEditRastreio" class="swal2-input" style="margin:0" />
              </label>
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                Loja
                <input id="vtsEditLoja" class="swal2-input" style="margin:0" />
              </label>
              <div class="grid grid-cols-1 gap-3 sm:grid-cols-2">
                <label class="flex flex-col text-sm text-slate-700 gap-1">
                  Data (ISO)
                  <input id="vtsEditDataEtiqueta" type="date" class="swal2-input" style="margin:0" />
                </label>
                <label class="flex flex-col text-sm text-slate-700 gap-1">
                  Data original
                  <input id="vtsEditDataEtiquetaTexto" class="swal2-input" style="margin:0" placeholder="Ex: 10/05/2024" />
                </label>
                <label class="flex flex-col text-sm text-slate-700 gap-1">
                  Data colocada (ISO)
                  <input id="vtsEditDataColocada" type="date" class="swal2-input" style="margin:0" />
                </label>
                <label class="flex flex-col text-sm text-slate-700 gap-1">
                  Data colocada original
                  <input id="vtsEditDataColocadaTexto" class="swal2-input" style="margin:0" placeholder="Ex: 10/05/2024" />
                </label>
              </div>
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                Arquivo de origem
                <input id="vtsEditOrigemArquivo" class="swal2-input" style="margin:0" />
              </label>
              <label class="flex flex-col text-sm text-slate-700 gap-1">
                Comprador
                <input id="vtsEditBuyerUsername" class="swal2-input" style="margin:0" />
              </label>
            </div>
          `,
          focusConfirm: false,
          showCancelButton: true,
          confirmButtonText: 'Salvar alterações',
          cancelButtonText: 'Cancelar',
          didOpen: () => {
            const popup = window.Swal.getPopup();
            if (!popup) return;
            popup.querySelector('#vtsEditSku').value = valoresIniciais.sku;
            popup.querySelector('#vtsEditPedido').value = valoresIniciais.pedido;
            popup.querySelector('#vtsEditRastreio').value = valoresIniciais.rastreio;
            popup.querySelector('#vtsEditLoja').value = valoresIniciais.loja;
            popup.querySelector('#vtsEditDataEtiqueta').value = valoresIniciais.dataEtiqueta || '';
            popup.querySelector('#vtsEditDataEtiquetaTexto').value = valoresIniciais.dataEtiquetaTexto;
            popup.querySelector('#vtsEditDataColocada').value = valoresIniciais.datacolocada || '';
            popup.querySelector('#vtsEditDataColocadaTexto').value = valoresIniciais.datacolocadaTexto;
            popup.querySelector('#vtsEditOrigemArquivo').value = valoresIniciais.origemArquivo;
            popup.querySelector('#vtsEditBuyerUsername').value = valoresIniciais.buyerUsername;
          },
          preConfirm: () => {
            const popup = window.Swal.getPopup();
            if (!popup) return null;
            const obterValor = (seletor) => popup.querySelector(seletor)?.value?.trim() || '';
            return {
              sku: obterValor('#vtsEditSku'),
              pedido: obterValor('#vtsEditPedido'),
              rastreio: obterValor('#vtsEditRastreio'),
              loja: obterValor('#vtsEditLoja'),
              dataEtiqueta: popup.querySelector('#vtsEditDataEtiqueta')?.value || '',
              dataEtiquetaTexto: obterValor('#vtsEditDataEtiquetaTexto'),
              datacolocada: popup.querySelector('#vtsEditDataColocada')?.value || '',
              datacolocadaTexto: obterValor('#vtsEditDataColocadaTexto'),
              origemArquivo: obterValor('#vtsEditOrigemArquivo'),
              buyerUsername: obterValor('#vtsEditBuyerUsername'),
            };
          },
        });

        if (!isConfirmed || !value) return;
        valoresAtualizados = value;
      } else {
        const promptValue = (campo, atual) => {
          const resposta = window.prompt(`Informe o novo valor para ${campo}:`, atual);
          if (resposta === null) return null;
          return resposta.trim();
        };

        const sku = promptValue('SKU', valoresIniciais.sku);
        if (sku === null) return;
        const pedido = promptValue('número do pedido', valoresIniciais.pedido);
        if (pedido === null) return;
        const rastreio = promptValue('código de rastreio', valoresIniciais.rastreio);
        if (rastreio === null) return;
        const loja = promptValue('loja', valoresIniciais.loja);
        if (loja === null) return;
        const dataEtiqueta = promptValue('data (AAAA-MM-DD)', valoresIniciais.dataEtiqueta);
        if (dataEtiqueta === null) return;
        const dataEtiquetaTexto = promptValue('data original', valoresIniciais.dataEtiquetaTexto);
        if (dataEtiquetaTexto === null) return;
        const datacolocada = promptValue('data colocada (AAAA-MM-DD)', valoresIniciais.datacolocada);
        if (datacolocada === null) return;
        const datacolocadaTexto = promptValue('data colocada original', valoresIniciais.datacolocadaTexto);
        if (datacolocadaTexto === null) return;
        const origemArquivo = promptValue('arquivo de origem', valoresIniciais.origemArquivo);
        if (origemArquivo === null) return;
        const buyerUsername = promptValue('comprador', valoresIniciais.buyerUsername);
        if (buyerUsername === null) return;

        valoresAtualizados = {
          sku,
          pedido,
          rastreio,
          loja,
          dataEtiqueta,
          dataEtiquetaTexto,
          datacolocada,
          datacolocadaTexto,
          origemArquivo,
          buyerUsername,
        };
      }

      try {
        await db.collection('vtsEtiquetas').doc(registro.id).update({
          sku: valoresAtualizados.sku,
          pedido: valoresAtualizados.pedido,
          rastreio: valoresAtualizados.rastreio,
          loja: valoresAtualizados.loja,
          dataEtiqueta: valoresAtualizados.dataEtiqueta,
          dataEtiquetaTexto: valoresAtualizados.dataEtiquetaTexto,
          datacolocada: valoresAtualizados.datacolocada,
          datacolocadaTexto: valoresAtualizados.datacolocadaTexto,
          origemArquivo: valoresAtualizados.origemArquivo,
          buyerUsername: valoresAtualizados.buyerUsername,
        });

        vtsEtiquetasRegistros = vtsEtiquetasRegistros.map((item) =>
          item.id === registro.id
            ? {
                ...item,
                ...valoresAtualizados,
              }
            : item,
        );

        aplicarFiltrosEtiquetasVts();
        setVtsFeedback('Registro atualizado com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao atualizar etiqueta VTS:', erro);
        setVtsFeedback('Não foi possível atualizar o registro. Tente novamente mais tarde.', 'error');
      }
    }

    async function excluirEtiquetaVts(registroId, numeroPedido) {
      if (!db || !registroId) return;

      let confirmado = true;
      const mensagem = numeroPedido
        ? `Deseja realmente excluir o pedido ${numeroPedido}?`
        : 'Deseja realmente excluir este registro?';

      if (window.Swal?.fire) {
        const resultado = await window.Swal.fire({
          title: 'Excluir registro',
          text: mensagem,
          icon: 'warning',
          showCancelButton: true,
          confirmButtonText: 'Sim, excluir',
          cancelButtonText: 'Cancelar',
          confirmButtonColor: '#ef4444',
        });
        confirmado = resultado.isConfirmed;
      } else {
        confirmado = window.confirm(mensagem);
      }

      if (!confirmado) return;

      try {
        await db.collection('vtsEtiquetas').doc(registroId).delete();
        vtsEtiquetasRegistros = vtsEtiquetasRegistros.filter((item) => item.id !== registroId);
        vtsEtiquetasSelecionadas.delete(registroId);
        aplicarFiltrosEtiquetasVts();
        setVtsFeedback('Registro excluído com sucesso.', 'success');
      } catch (erro) {
        console.error('Erro ao excluir etiqueta VTS:', erro);
        setVtsFeedback('Não foi possível excluir o registro. Tente novamente mais tarde.', 'error');
      }
    }

    async function excluirEtiquetasSelecionadasVts() {
      if (!db || !vtsEtiquetasSelecionadas.size) return;

      const idsSelecionados = Array.from(vtsEtiquetasSelecionadas).filter(Boolean);
      if (!idsSelecionados.length) {
        vtsEtiquetasSelecionadas.clear();
        atualizarControleSelecaoVts(obterEtiquetasFiltradasVts());
        return;
      }

      const registrosSelecionados = vtsEtiquetasRegistros.filter((item) => idsSelecionados.includes(item.id));
      if (!registrosSelecionados.length) {
        vtsEtiquetasSelecionadas.clear();
        atualizarControleSelecaoVts(obterEtiquetasFiltradasVts());
        return;
      }

      const quantidade = registrosSelecionados.length;
      let confirmado = true;
      const exemploPedido = registrosSelecionados[0]?.pedido;
      const mensagem =
        quantidade === 1 && exemploPedido
          ? `Deseja realmente excluir o pedido ${exemploPedido}?`
          : `Deseja realmente excluir ${quantidade} registro(s) selecionado(s)?`;

      if (window.Swal?.fire) {
        const resultado = await window.Swal.fire({
          title: 'Excluir registros selecionados',
          text: mensagem,
          icon: 'warning',
          showCancelButton: true,
          confirmButtonText: 'Sim, excluir',
          cancelButtonText: 'Cancelar',
          confirmButtonColor: '#ef4444',
        });
        confirmado = resultado.isConfirmed;
      } else {
        confirmado = window.confirm(mensagem);
      }

      if (!confirmado) return;

      try {
        setVtsFeedback('Excluindo registros selecionados...', 'info');
        const tarefas = idsSelecionados.map((id) => db.collection('vtsEtiquetas').doc(id).delete());
        await Promise.all(tarefas);

        const idsRemovidos = new Set(idsSelecionados);
        vtsEtiquetasRegistros = vtsEtiquetasRegistros.filter((item) => !idsRemovidos.has(item.id));
        idsRemovidos.forEach((id) => vtsEtiquetasSelecionadas.delete(id));
        aplicarFiltrosEtiquetasVts();
        setVtsFeedback(`${quantidade} registro(s) excluído(s) com sucesso.`, 'success');
      } catch (erro) {
        console.error('Erro ao excluir etiquetas selecionadas VTS:', erro);
        setVtsFeedback('Não foi possível excluir os registros selecionados. Tente novamente mais tarde.', 'error');
      } finally {
        atualizarControleSelecaoVts(obterEtiquetasFiltradasVts());
      }
    }

    async function registrarEntradaManualVts(event) {
      event?.preventDefault?.();

      if (!db || !usuarioLogado?.uid) {
        setVtsFeedback('Não foi possível registrar a etiqueta manualmente no momento. Tente novamente mais tarde.', 'error');
        return;
      }

      const formulario = document.getElementById('vtsEntradaManualForm');
      if (!formulario) return;

      const skuInput = document.getElementById('vtsManualSku');
      const pedidoInput = document.getElementById('vtsManualPedido');
      const rastreioInput = document.getElementById('vtsManualRastreio');
      const lojaInput = document.getElementById('vtsManualLoja');
      const dataInput = document.getElementById('vtsManualData');
      const buyerInput = document.getElementById('vtsManualBuyer');
      const botao = document.getElementById('vtsEntradaManualSubmit');

      const skuValorBruto = skuInput?.value?.trim() || '';
      const skuValorNormalizado = skuValorBruto ? limparValorSkuVts(skuValorBruto) : '';
      const skuValor = skuValorNormalizado || skuValorBruto;

      const pedidoValorBruto = pedidoInput?.value?.trim() || '';
      const pedidoValor = pedidoValorBruto ? normalizarLinhaVts(pedidoValorBruto) : '';

      const rastreioValorBruto = rastreioInput?.value?.trim() || '';
      const rastreioValor = rastreioValorBruto ? normalizarLinhaVts(rastreioValorBruto) : '';

      if (!pedidoValor && !rastreioValor) {
        setVtsFeedback('Informe o número do pedido ou o código de rastreio para registrar a etiqueta manualmente.', 'warning');
        (pedidoInput || rastreioInput)?.focus();
        return;
      }

      let lojaValor = lojaInput?.value?.trim() || '';
      if (lojaValor) {
        const lojaLimpa = limparNomeLojaVts(lojaValor);
        lojaValor = lojaLimpa || lojaValor;
      }

      const dataValor = dataInput?.value?.trim() || '';
      let dataNormalizada = '';
      let dataTexto = '';
      if (dataValor) {
        dataNormalizada = normalizeDate(dataValor);
        if (dataNormalizada) {
          const [ano, mes, dia] = dataNormalizada.split('-');
          if (ano && mes && dia) {
            dataTexto = `${dia}/${mes}/${ano}`;
          }
        }
      }

      const buyerValor = buyerInput?.value?.trim() || '';

      const textoOriginalBotao = botao?.innerHTML;
      if (botao) {
        botao.disabled = true;
        botao.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-2"></i>Registrando etiqueta...';
        botao.classList.add('opacity-70');
      }

      try {
        const etiquetaManual = {
          sku: skuValor,
          pedido: pedidoValor,
          rastreio: rastreioValor,
          loja: lojaValor,
          dataNormalizada,
          dataTexto,
          buyerUsername: buyerValor,
          modelo: 'manual',
        };

        const resultadoSalvamento = await salvarEtiquetasVts([etiquetaManual], null, 'manual');

        if (resultadoSalvamento?.cancelado) {
          setVtsFeedback('Registro cancelado: informe a data em que a etiqueta foi colocada para concluir o cadastro.', 'warning');
          return;
        }

        const { salvos = 0, ignorados = 0 } = resultadoSalvamento || {};

        if (salvos > 0) {
          setVtsFeedback('Etiqueta registrada manualmente com sucesso.', 'success');
          formulario.reset();
          skuInput?.focus();
          await carregarEtiquetasVts();
        } else if (ignorados > 0) {
          setVtsFeedback('O pedido informado já possui uma etiqueta cadastrada anteriormente.', 'warning');
        } else {
          setVtsFeedback('Nenhum registro foi criado. Verifique os dados informados e tente novamente.', 'info');
        }
      } catch (erro) {
        console.error('Erro ao registrar etiqueta manual VTS:', erro);
        setVtsFeedback('Não foi possível registrar a etiqueta manualmente. Tente novamente mais tarde.', 'error');
      } finally {
        if (botao) {
          botao.disabled = false;
          botao.innerHTML = textoOriginalBotao || 'Registrar etiqueta manualmente';
          botao.classList.remove('opacity-70');
        }
      }
    }

    async function marcarEtiquetasComoCanceladasVts(registros = [], motivo = 'devolucao') {
      if (!Array.isArray(registros) || !registros.length) {
        return { atualizados: 0, jaCancelados: 0, pendentes: [], jaCanceladosItens: [] };
      }

      const pendentes = [];
      const jaCancelados = [];
      const idsProcessados = new Set();

      registros.forEach((item) => {
        if (!item || !item.id || idsProcessados.has(item.id)) return;
        idsProcessados.add(item.id);
        if ((item.status || '').toLowerCase() === 'cancelado') {
          jaCancelados.push(item);
        } else {
          pendentes.push(item);
        }
      });

      if (!pendentes.length) {
        if (jaCancelados.length) {
          aplicarFiltrosEtiquetasVts();
        }
        return {
          atualizados: 0,
          jaCancelados: jaCancelados.length,
          pendentes,
          jaCanceladosItens: jaCancelados,
        };
      }

      await Promise.all(
        pendentes.map((item) =>
          db
            .collection('vtsEtiquetas')
            .doc(item.id)
            .set(
              {
                status: 'cancelado',
                canceladoEm: firebase.firestore.FieldValue.serverTimestamp(),
                canceladoPor: usuarioLogado?.uid || '',
                canceladoMotivo: motivo,
              },
              { merge: true },
            ),
        ),
      );

      const agora = new Date();
      pendentes.forEach((item) => {
        item.status = 'cancelado';
        item.canceladoEm = agora;
        item.canceladoPor = usuarioLogado?.uid || '';
        item.canceladoMotivo = motivo;
      });

      aplicarFiltrosEtiquetasVts();

      return {
        atualizados: pendentes.length,
        jaCancelados: jaCancelados.length,
        pendentes,
        jaCanceladosItens: jaCancelados,
      };
    }

    async function registrarDevolucaoVts(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }

      if (!db) {
        setVtsFeedback('Não foi possível registrar a devolução: serviço indisponível.', 'error');
        return;
      }

      const formulario = document.getElementById('vtsDevolucaoForm');
      const pedidoInput = document.getElementById('vtsDevolucaoPedido');
      const rastreioInput = document.getElementById('vtsDevolucaoRastreio');
      const lojaInput = document.getElementById('vtsDevolucaoLoja');
      const botao = document.getElementById('vtsDevolucaoSubmit');

      const pedidoValor = pedidoInput?.value?.trim() || '';
      const rastreioValor = rastreioInput?.value?.trim() || '';
      const lojaValor = lojaInput?.value?.trim() || '';

      if (!pedidoValor && !rastreioValor) {
        setVtsFeedback('Informe o número do pedido ou o código de rastreio para registrar a devolução.', 'warning');
        pedidoInput?.focus();
        return;
      }

      if (!lojaValor) {
        setVtsFeedback('Informe a loja relacionada ao pedido para registrar a devolução.', 'warning');
        lojaInput?.focus();
        return;
      }

      const pedidoNormalizado = normalizarComparacaoVts(pedidoValor);
      const rastreioNormalizado = normalizarComparacaoVts(rastreioValor);
      const lojaNormalizada = normalizarComparacaoVts(lojaValor);

      const correspondencias = vtsEtiquetasRegistros.filter((item) => {
        const pedidoItem = normalizarComparacaoVts(item.pedido);
        const rastreioItem = normalizarComparacaoVts(item.rastreio);
        const lojaItem = normalizarComparacaoVts(item.loja);

        const pedidoConfere = pedidoNormalizado ? pedidoItem === pedidoNormalizado : true;
        const rastreioConfere = rastreioNormalizado ? rastreioItem === rastreioNormalizado : true;
        const lojaConfere = lojaNormalizada ? (lojaItem ? lojaItem === lojaNormalizada : true) : true;

        return pedidoConfere && rastreioConfere && lojaConfere;
      });

      if (!correspondencias.length) {
        setVtsFeedback('Nenhum pedido foi localizado com os dados informados. Verifique os valores e tente novamente.', 'warning');
        return;
      }

      const textoOriginalBotao = botao?.innerHTML;
      if (botao) {
        botao.disabled = true;
        botao.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-2"></i>Registrando devolução...';
        botao.classList.add('opacity-70');
      }

      try {
        const resultado = await marcarEtiquetasComoCanceladasVts(correspondencias, 'devolucao');
        const atualizados = resultado?.atualizados || 0;
        const jaCancelados = resultado?.jaCancelados || 0;

        if (!atualizados) {
          if (jaCancelados) {
            setVtsFeedback('O pedido informado já está marcado como cancelado.', 'info');
          } else {
            setVtsFeedback('Nenhum registro elegível foi encontrado para cancelamento.', 'info');
          }
          return;
        }

        if (formulario) {
          formulario.reset();
          const campoLoja = document.getElementById('vtsDevolucaoLoja');
          campoLoja?.focus();
        } else {
          if (pedidoInput) pedidoInput.value = '';
          if (rastreioInput) rastreioInput.value = '';
          if (lojaInput) {
            lojaInput.value = '';
            lojaInput.focus();
          }
        }

        const partesMensagem = [];
        partesMensagem.push(
          atualizados > 1
            ? `${atualizados} pedidos foram marcados como cancelados e destacados na lista.`
            : 'Pedido marcado como cancelado e destacado na lista.',
        );
        if (jaCancelados) {
          partesMensagem.push('Alguns registros já estavam sinalizados anteriormente.');
        }
        setVtsFeedback(partesMensagem.join(' '), 'warning');
      } catch (erro) {
        console.error('Erro ao registrar devolução VTS:', erro);
        setVtsFeedback('Não foi possível registrar a devolução. Tente novamente mais tarde.', 'error');
      } finally {
        if (botao) {
          botao.disabled = false;
          botao.innerHTML = textoOriginalBotao || 'Registrar devolução';
          botao.classList.remove('opacity-70');
        }
      }
    }

    async function extrairCodigosPlanilhaDevolucaoVts(arquivo) {
      if (!arquivo) {
        return { codigos: new Map(), total: 0, validos: 0, duplicados: 0 };
      }

      if (typeof XLSX === 'undefined') {
        throw new Error('Biblioteca XLSX não disponível para leitura da planilha.');
      }

      const nomeArquivo = (arquivo.name || '').toLowerCase();
      let workbook;

      if (nomeArquivo.endsWith('.csv')) {
        const texto = await arquivo.text();
        workbook = XLSX.read(texto, { type: 'string' });
      } else {
        const arrayBuffer = await arquivo.arrayBuffer();
        workbook = XLSX.read(arrayBuffer, { type: 'array' });
      }

      const primeiraAba = workbook?.SheetNames?.[0];
      if (!primeiraAba) {
        return { codigos: new Map(), total: 0, validos: 0, duplicados: 0 };
      }

      const sheet = workbook.Sheets?.[primeiraAba];
      if (!sheet) {
        return { codigos: new Map(), total: 0, validos: 0, duplicados: 0 };
      }

      const linhas = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
      if (!Array.isArray(linhas) || !linhas.length) {
        return { codigos: new Map(), total: 0, validos: 0, duplicados: 0 };
      }

      const cabecalho = Array.isArray(linhas[0]) ? linhas[0] : [];
      const cabecalhoNormalizado = cabecalho.map((valor) => normalizarCabecalhoPlanilhaVts(valor));
      const candidatos = Array.isArray(VTS_DEVOLUCAO_HEADER_CANDIDATOS)
        ? VTS_DEVOLUCAO_HEADER_CANDIDATOS
        : [];

      let indiceCodigo = cabecalhoNormalizado.findIndex((valor) => {
        if (!valor) return false;
        if (candidatos.includes(valor)) return true;
        return candidatos.some((candidato) => valor.includes(candidato));
      });

      let inicioDados = 0;
      if (indiceCodigo !== -1) {
        inicioDados = 1;
      } else {
        indiceCodigo = 0;
        if (linhas.length > 1) {
          const possivelCabecalho = (linhas[0][0] || '').toString();
          if (/[A-Za-z]/.test(possivelCabecalho)) {
            inicioDados = 1;
          }
        }
      }

      const codigos = new Map();
      let validos = 0;

      for (let i = inicioDados; i < linhas.length; i += 1) {
        const linha = linhas[i];
        if (!linha || typeof linha !== 'object') continue;
        const valor = Array.isArray(linha) ? linha[indiceCodigo] : linha[indiceCodigo] || '';
        const texto = valor != null ? valor.toString().trim() : '';
        if (!texto) continue;
        const normalizado = normalizarCodigoRastreioVts(texto);
        if (!normalizado) continue;
        validos += 1;
        if (!codigos.has(normalizado)) {
          codigos.set(normalizado, texto);
        }
      }

      const totalLinhas = Math.max(0, linhas.length - inicioDados);
      const duplicados = Math.max(0, validos - codigos.size);

      return { codigos, total: totalLinhas, validos, duplicados };
    }

    async function importarDevolucoesPlanilhaVts(event) {
      if (event?.preventDefault) {
        event.preventDefault();
      }

      if (!db) {
        setVtsFeedback('Não foi possível importar as devoluções: serviço indisponível.', 'error');
        return;
      }

      const input = document.getElementById('vtsDevolucaoArquivo');
      const botao = document.getElementById('vtsDevolucaoImportar');

      if (!input) {
        setVtsFeedback('Campo de importação de devoluções não localizado.', 'error');
        return;
      }

      const arquivo = input.files && input.files[0];
      if (!arquivo) {
        setVtsFeedback('Selecione uma planilha com os códigos de rastreio para continuar.', 'warning');
        input.focus();
        return;
      }

      if (typeof XLSX === 'undefined') {
        setVtsFeedback('Biblioteca de planilhas indisponível. Recarregue a página e tente novamente.', 'error');
        return;
      }

      const textoOriginalBotao = botao?.innerHTML;
      if (botao) {
        botao.disabled = true;
        botao.innerHTML = '<i class="fas fa-circle-notch fa-spin mr-2"></i>Importando devoluções...';
        botao.classList.add('opacity-70');
      }

      try {
        const { codigos, total, validos, duplicados } = await extrairCodigosPlanilhaDevolucaoVts(arquivo);

        if (!codigos.size) {
          if (total > 0) {
            setVtsFeedback('Nenhum código de rastreio válido foi identificado na planilha selecionada.', 'warning');
          } else {
            setVtsFeedback('A planilha selecionada está vazia ou não pôde ser lida.', 'warning');
          }
          return;
        }

        const correspondencias = [];
        const naoEncontrados = [];
        const idsProcessados = new Set();

        codigos.forEach((original, normalizado) => {
          const encontrados = vtsEtiquetasRegistros.filter(
            (item) => normalizarCodigoRastreioVts(item?.rastreio) === normalizado,
          );

          if (!encontrados.length) {
            naoEncontrados.push(original || normalizado);
            return;
          }

          encontrados.forEach((item) => {
            if (!item || !item.id || idsProcessados.has(item.id)) return;
            idsProcessados.add(item.id);
            correspondencias.push(item);
          });
        });

        if (!correspondencias.length) {
          const mensagemNaoEncontrado =
            naoEncontrados.length && codigos.size === naoEncontrados.length
              ? 'Nenhum dos rastreios informados foi localizado no sistema.'
              : 'Nenhum pedido com os rastreios informados foi localizado no sistema.';
          setVtsFeedback(mensagemNaoEncontrado, 'warning');
          return;
        }

        const resultado = await marcarEtiquetasComoCanceladasVts(correspondencias, 'devolucao');
        const atualizados = resultado?.atualizados || 0;
        const jaCancelados = resultado?.jaCancelados || 0;

        const mensagens = [];

        mensagens.push(
          codigos.size > 1
            ? `${codigos.size} códigos de rastreio válidos identificados na planilha.`
            : '1 código de rastreio válido identificado na planilha.',
        );

        if (atualizados) {
          mensagens.push(
            atualizados > 1
              ? `${atualizados} pedidos foram marcados como cancelados a partir da planilha importada.`
              : 'Pedido marcado como cancelado a partir da planilha importada.',
          );
        } else if (jaCancelados) {
          mensagens.push('Os pedidos encontrados já estavam marcados como cancelados.');
        }

        if (atualizados && jaCancelados) {
          mensagens.push('Alguns registros já estavam sinalizados anteriormente.');
        }

        if (!atualizados && !jaCancelados) {
          mensagens.push('Nenhum registro elegível foi encontrado para cancelamento.');
        }

        if (naoEncontrados.length) {
          const exemplos = naoEncontrados.slice(0, 5).join(', ');
          const sufixo = naoEncontrados.length > 5 ? ', ...' : '';
          mensagens.push(
            naoEncontrados.length > 1
              ? `Não encontramos ${naoEncontrados.length} rastreios do arquivo no sistema (${exemplos}${sufixo}).`
              : `Não encontramos o rastreio "${exemplos}" no sistema.`,
          );
        }

        if (duplicados > 0) {
          mensagens.push(
            duplicados === 1
              ? '1 código duplicado na planilha foi ignorado.'
              : `${duplicados} códigos duplicados na planilha foram ignorados.`,
          );
        }

        const linhasSemCodigo = Math.max(0, total - validos);
        if (linhasSemCodigo > 0) {
          mensagens.push(
            linhasSemCodigo === 1
              ? '1 linha sem código de rastreio foi ignorada.'
              : `${linhasSemCodigo} linhas sem código de rastreio foram ignoradas.`,
          );
        }

        const tipoFeedback = atualizados ? 'success' : jaCancelados ? 'info' : 'warning';
        setVtsFeedback(mensagens.join(' '), tipoFeedback);

        input.value = '';
      } catch (erro) {
        console.error('Erro ao importar planilha de devoluções VTS:', erro);
        setVtsFeedback(
          'Não foi possível importar a planilha de devoluções. Verifique o arquivo e tente novamente.',
          'error',
        );
      } finally {
        if (botao) {
          botao.disabled = false;
          botao.innerHTML = textoOriginalBotao || '<i class="fas fa-file-import mr-2"></i>Importar planilha';
          botao.classList.remove('opacity-70');
        }
      }
    }

    function construirIdEtiquetaVts(etiqueta, indice, modelo = '') {
      const uidSanitizado = (usuarioLogado?.uid || 'anon')
        .toString()
        .replace(/[^a-zA-Z0-9-]/g, '')
        .toLowerCase();
      const partesBase = [etiqueta.pedido, etiqueta.rastreio, etiqueta.sku, modelo]
        .filter(Boolean)
        .map((parte) =>
          parte
            .toString()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-zA-Z0-9-]/g, '')
            .toLowerCase(),
        )
        .filter(Boolean);

      let base = partesBase.join('-');
      if (!base) {
        base = `etq-${Date.now()}-${indice}`;
      }

      const docId = `${uidSanitizado}-${base}`;
      return docId.slice(0, 180);
    }

    function obterDataAtualIsoVts() {
      try {
        const agora = new Date();
        if (Number.isNaN(agora.getTime())) return '';
        return agora.toISOString().slice(0, 10);
      } catch (erro) {
        console.warn('Não foi possível obter a data atual para VTS:', erro);
        return '';
      }
    }

    async function solicitarDataColocadaVts(dataSugestao = '') {
      const dataInicial = normalizeDate(dataSugestao) || dataSugestao || obterDataAtualIsoVts();

      if (window.Swal?.fire) {
        const resultado = await Swal.fire({
          title: 'Informe a data em que a etiqueta foi colocada',
          text: 'A mesma data será aplicada para todas as etiquetas deste envio.',
          input: 'date',
          inputValue: dataInicial || '',
          inputAttributes: {
            max: obterDataAtualIsoVts() || undefined,
          },
          showCancelButton: true,
          confirmButtonText: 'Confirmar',
          cancelButtonText: 'Cancelar',
          allowOutsideClick: false,
          preConfirm: (valor) => {
            const normalizado = normalizeDate(valor);
            if (!normalizado) {
              Swal.showValidationMessage('Informe uma data válida para continuar.');
              return false;
            }
            return {
              data: normalizado,
              texto: formatarDataVts(normalizado, valor),
            };
          },
        });

        if (!resultado.isConfirmed) {
          return null;
        }

        return resultado.value || null;
      }

      let tentativas = 0;
      while (tentativas < 3) {
        const valor = window.prompt(
          'Informe a data em que a etiqueta foi colocada (AAAA-MM-DD):',
          dataInicial || '',
        );
        if (valor === null) {
          return null;
        }
        const normalizado = normalizeDate(valor);
        if (normalizado) {
          return {
            data: normalizado,
            texto: formatarDataVts(normalizado, valor),
          };
        }
        tentativas += 1;
      }

      return null;
    }

    async function salvarEtiquetasVts(etiquetas, arquivo, modelo = '') {
      if (!db || !usuarioLogado?.uid || !Array.isArray(etiquetas)) {
        return { salvos: 0, ignorados: 0 };
      }

      const usuarioId = usuarioLogado.uid;
      const pedidosExistentesNormalizados = new Set(
        (vtsEtiquetasRegistros || [])
          .map((item) => normalizarComparacaoVts(item?.pedido))
          .filter(Boolean),
      );

      const pedidosParaConsulta = new Map();

      etiquetas.forEach((etiqueta) => {
        const pedidoNormalizado = normalizarComparacaoVts(etiqueta?.pedido);
        if (!pedidoNormalizado || pedidosExistentesNormalizados.has(pedidoNormalizado)) return;

        const pedidoOriginal = normalizarLinhaVts(etiqueta?.pedido);
        if (!pedidoOriginal) return;

        if (!pedidosParaConsulta.has(pedidoNormalizado)) {
          pedidosParaConsulta.set(pedidoNormalizado, new Set());
        }
        pedidosParaConsulta.get(pedidoNormalizado).add(pedidoOriginal);
      });

      for (const [pedidoNormalizado, valores] of pedidosParaConsulta.entries()) {
        for (const pedidoOriginal of valores) {
          try {
            const existenteSnapshot = await db
              .collection('vtsEtiquetas')
              .where('usuarioId', '==', usuarioId)
              .where('pedido', '==', pedidoOriginal)
              .limit(1)
              .get();

            if (!existenteSnapshot.empty) {
              pedidosExistentesNormalizados.add(pedidoNormalizado);
              break;
            }
          } catch (erro) {
            console.warn('Não foi possível verificar pedido existente:', erro);
          }
        }
      }

      let salvos = 0;
      let ignorados = 0;
      let dataColocadaInfo = null;
      let canceladoPorData = false;

      for (let indice = 0; indice < etiquetas.length; indice += 1) {
        const etiqueta = etiquetas[indice];
        const pedidoNormalizado = normalizarComparacaoVts(etiqueta?.pedido);

        if (pedidoNormalizado && pedidosExistentesNormalizados.has(pedidoNormalizado)) {
          ignorados += 1;
          continue;
        }

        if (!dataColocadaInfo) {
          dataColocadaInfo = await solicitarDataColocadaVts(etiqueta?.dataNormalizada || etiqueta?.dataTexto);
          if (!dataColocadaInfo) {
            canceladoPorData = true;
            break;
          }
        }

        const docId = construirIdEtiquetaVts(etiqueta, indice, modelo || etiqueta.modelo);
        const docRef = db.collection('vtsEtiquetas').doc(docId);

        let existente;
        try {
          existente = await docRef.get();
        } catch (erro) {
          console.warn('Não foi possível verificar etiqueta existente:', erro);
        }

        const modeloEtiqueta = etiqueta.modelo || modelo || '';
        const payload = {
          usuarioId,
          sku: etiqueta.sku || '',
          pedido: etiqueta.pedido || '',
          rastreio: etiqueta.rastreio || '',
          loja: etiqueta.loja || '',
          dataEtiqueta: etiqueta.dataNormalizada || '',
          dataEtiquetaTexto: etiqueta.dataTexto || '',
          origemArquivo: arquivo?.name || '',
          paginaArquivo: etiqueta.pagina || indice + 1,
          modeloEtiqueta,
          buyerUsername: etiqueta.buyerUsername || '',
          atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
        };

        if (dataColocadaInfo?.data) {
          payload.datacolocada = dataColocadaInfo.data;
          if (dataColocadaInfo.texto) {
            payload.datacolocadaTexto = dataColocadaInfo.texto;
          }
        }

        if (pedidoNormalizado) {
          payload.pedidoNormalizado = pedidoNormalizado;
        }

        if (!payload.loja && modeloEtiqueta === 'mercadoLivre') {
          payload.loja = 'Mercado livre';
        }

        if (!existente || !existente.exists) {
          payload.importadoEm = firebase.firestore.FieldValue.serverTimestamp();
        }

        try {
          await docRef.set(payload, { merge: true });
          salvos += 1;
          if (pedidoNormalizado) {
            pedidosExistentesNormalizados.add(pedidoNormalizado);
          }
        } catch (erro) {
          console.error('Erro ao salvar etiqueta VTS:', erro);
          throw erro;
        }
      }

      if (canceladoPorData) {
        return { salvos, ignorados, cancelado: true };
      }

      return { salvos, ignorados, cancelado: false };
    }

    function normalizarLinhaVts(texto) {
      return (texto || '')
        .toString()
        .replace(/\s+/g, ' ')
        .trim();
    }

    function sanitizarCodigoVts(texto) {
      return (texto || '')
        .toString()
        .replace(/\s+/g, '')
        .replace(/[^A-Za-z0-9-]/g, '')
        .trim();
    }

    function normalizarComparacaoVts(texto) {
      return (texto || '')
        .toString()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/\s+/g, ' ')
        .trim()
        .toLowerCase();
    }

    function normalizarCodigoRastreioVts(texto) {
      return normalizarComparacaoVts(texto).replace(/[^a-z0-9]/g, '');
    }

    function normalizarCabecalhoPlanilhaVts(texto) {
      return normalizarComparacaoVts(texto).replace(/[^a-z0-9]/g, '');
    }

    function removerAcentosVts(texto) {
      return (texto || '')
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '');
    }

    function ehSkuValidoVts(texto) {
      const normalizado = normalizarLinhaVts(texto);
      if (!normalizado) return false;

      const semAcento = removerAcentosVts(normalizado).toLowerCase();
      const invalido = new Set([
        'variacao',
        'variac',
        'variacao:',
        'varia',
        'descricao',
        'descricao do produto',
        'produto',
        'produtos',
        'sku',
      ]);

      if (invalido.has(semAcento)) return false;

      return normalizado.length > 2;
    }

    function extrairCodigoPackVts(texto) {
      const normalizado = normalizarLinhaVts(texto);
      if (!normalizado) return '';

      const truncado = normalizado.split(/\b(?:recorte|retire|retirar|despachar|despache|nf|nota fiscal|notafiscal|xsp\d+|spa\d+|unidade|sku|pedido|cidade|cep|endere[cç]o|destinat[aá]rio)\b/i)[0];
      const codigo = sanitizarCodigoVts(truncado);

      return codigo;
    }

    function extrairRastreioVts(texto, pedidoAtual) {
      const normalizado = normalizarLinhaVts(texto);
      if (!normalizado) return '';

      const pedidoNumerico = (pedidoAtual || '').replace(/\D/g, '');

      const formatoCorreios = normalizado.match(/\b[A-Z]{2}\d{9}[A-Z]{2}\b/);
      if (formatoCorreios) return formatoCorreios[0];

      const formatoAlfanumerico = normalizado.match(/\b[A-Z]{2}\d{8,}[A-Z]?\b/);
      if (formatoAlfanumerico) return formatoAlfanumerico[0];

      const rastreioHorarioMatch = normalizado.match(/\b\d{1,2}:\d{2}\s*h?\s*(\d{4,7})\s+(\d{4,7})(?!\s*\d{4,})/);
      if (rastreioHorarioMatch) {
        const parte1 = (rastreioHorarioMatch[1] || '').replace(/\D/g, '');
        const parte2 = (rastreioHorarioMatch[2] || '').replace(/\D/g, '');
        const combinado = `${parte1}${parte2}`;
        if (combinado.length >= 10 && combinado.length <= 15) {
          return combinado;
        }
      }

      const candidatosNumericos = normalizado.match(/(\d[\d\s-]{8,}\d)/g);
      if (candidatosNumericos) {
        for (const candidato of candidatosNumericos) {
          const digitos = candidato.replace(/\D/g, '');
          if (digitos.length >= 10 && digitos.length <= 15) {
            const ehSubsequenciaPedido = pedidoNumerico && pedidoNumerico.length > digitos.length && pedidoNumerico.includes(digitos);
            if (!pedidoNumerico || (!ehSubsequenciaPedido && digitos !== pedidoNumerico)) {
              return digitos;
            }
          }
        }
      }

      const partes = normalizado.split(/\s+/);
      for (const parte of partes) {
        const digitos = parte.replace(/\D/g, '');
        if (digitos.length >= 10 && digitos.length <= 15) {
          const ehSubsequenciaPedido = pedidoNumerico && pedidoNumerico.length > digitos.length && pedidoNumerico.includes(digitos);
          if (!pedidoNumerico || (!ehSubsequenciaPedido && digitos !== pedidoNumerico)) {
            return digitos;
          }
        }
      }

      return '';
    }

    function limparNomeLojaVts(valor) {
      let texto = normalizarLinhaVts(valor)
        .replace(/\b(remetente|destinat[aá]rio)\b[:\s-]*/gi, '')
        .replace(/^[:\s-]+/, '');

      if (!texto) return '';

      const termosBloqueados = new Set([
        'cep',
        'bairro',
        'destinatario',
        'destinatário',
        'envio',
        'previsto',
        'coleta',
        'saida',
        'saída',
        'serie',
        'emissao',
        'emissão',
        'package',
        'checklist',
        'produto',
        'quantidade',
        'pedido',
        'sku',
        'remessa',
      ]);

      const limitesEndereco = new Set([
        'av',
        'av.',
        'avenida',
        'rua',
        'rodovia',
        'rod',
        'rod.',
        'travessa',
        'estrada',
        'estr',
        'estr.',
        'alameda',
        'praça',
        'praca',
        'lote',
        'quadra',
        'n',
        'nº',
        'no',
        'numero',
        'km',
      ]);

      const tokens = texto.split(/\s+/);
      const coletados = [];

      for (const tokenOriginal of tokens) {
        let token = tokenOriginal;

        if (!token) continue;

        token = token.replace(/^[^A-Za-z0-9]+/, '').replace(/[,;]+$/, '');
        if (!token) continue;

        const tokenBasico = removerAcentosVts(token).toLowerCase();

        if (!coletados.length && tokenBasico.endsWith(':')) {
          continue;
        }

        if (termosBloqueados.has(tokenBasico.replace(/:$/, ''))) {
          if (!coletados.length) continue;
          break;
        }

        if (limitesEndereco.has(tokenBasico.replace(/:$/, ''))) {
          if (!coletados.length) continue;
          break;
        }

        if (/\d/.test(tokenBasico)) {
          if (!coletados.length) continue;
          break;
        }

        coletados.push(token);
      }

      const resultado = normalizarLinhaVts(coletados.join(' '));
      return resultado;
    }

    function ehLojaValidaVts(valor) {
      const normalizado = normalizarLinhaVts(valor);
      if (!normalizado) return false;

      const semAcento = removerAcentosVts(normalizado).toLowerCase();
      if (!semAcento) return false;

      if (/^(cep|bairro|envio|previsto|destinatario|destinatário|remetente|pedido|sku)$/i.test(semAcento)) {
        return false;
      }

      const primeiroToken = semAcento.split(/\s+/)[0];
      if (
        ['rua', 'avenida', 'av', 'av.', 'travessa', 'estrada', 'estr', 'rodovia', 'rod', 'rod.', 'alameda', 'padre', 'praca', 'praça']
          .includes(primeiroToken)
      ) {
        return false;
      }

      return normalizado.length > 2;
    }

    function extrairLojaAposRastreioVts(linhas, rastreio) {
      const codigo = sanitizarCodigoVts(rastreio);
      if (!codigo) return '';

      for (const linha of linhas) {
        const texto = normalizarLinhaVts(linha);
        if (!texto) continue;

        const textoCompacto = texto.replace(/\s+/g, '');
        const indiceCompacto = textoCompacto.indexOf(codigo);
        if (indiceCompacto === -1) continue;

        const indice = texto.indexOf(rastreio);
        let restante = indice !== -1
          ? texto.slice(indice + rastreio.length)
          : textoCompacto.slice(indiceCompacto + codigo.length);

        restante = normalizarLinhaVts(restante).replace(/^[^A-Za-z]+/, '');
        if (!restante) continue;

        const segmento = restante.split(/\b(?:av\.?|avenida|rua|travessa|estrada|rodovia|cep|bairro|package|checklist|produto|quantidade|pedido|sku|coleta|envio|previsto|destinat[aá]rio)\b/i)[0] || restante;
        const loja = limparNomeLojaVts(segmento);
        if (ehLojaValidaVts(loja)) return loja;
      }

      return '';
    }

    function extrairPedidoGenericoVts(linhas, rastreioAtual) {
      const rastreioSanitizado = sanitizarCodigoVts(rastreioAtual);

      for (const linha of linhas) {
        const tokens = normalizarLinhaVts(linha).split(/\s+/);
        for (const token of tokens) {
          const candidato = sanitizarCodigoVts(token);
          if (!candidato) continue;

          if (/^[A-Z]{2}\d{9}[A-Z]{2}$/i.test(candidato)) continue;
          if (rastreioSanitizado && rastreioSanitizado.includes(candidato)) continue;

          if (candidato.length >= 8 && /[A-Za-z]/.test(candidato) && /\d/.test(candidato)) {
            return candidato;
          }

          if (candidato.length >= 12 && /^\d+$/.test(candidato)) {
            return candidato;
          }
        }
      }

      return '';
    }

    function extrairLojaDeTextoVts(texto) {
      const normalizado = normalizarLinhaVts(texto);
      if (!normalizado) return '';

      if (!/#\d{5,}/.test(normalizado)) return '';

      const tokens = normalizado.split(/\s+/);
      const indiceHash = tokens.findIndex((token) => /#\d{5,}/.test(token));
      if (indiceHash === -1) return normalizado;

      const selecionados = [];
      const conectores = new Set(['de', 'da', 'do', 'dos', 'das', 'e']);

      for (let indice = indiceHash - 1; indice >= 0; indice -= 1) {
        const tokenOriginal = tokens[indice];
        const tokenLimpo = tokenOriginal.replace(/[^A-Za-zÀ-ÿ0-9]/g, '');
        if (!tokenLimpo) continue;

        const tokenMinusculo = tokenLimpo.toLowerCase();

        if (/^(sku|pedido|pack|quantidade|unidade|recorte|remetente|destinatario|destinatário|nf|nota|cnpj|cpf|produto|produtos|kit|puxador|espelho|oferta|ofert)$/i.test(tokenLimpo)) {
          if (!selecionados.length) continue;
          break;
        }

        if (tokenOriginal.includes('-') && selecionados.length) break;

        if (tokenLimpo.length <= 1 && !conectores.has(tokenMinusculo)) {
          if (selecionados.length) break;
          continue;
        }

        if (conectores.has(tokenMinusculo) && !selecionados.length) continue;

        selecionados.unshift(tokenOriginal);

        if (selecionados.length >= 5) break;
      }

      if (!selecionados.length) {
        const anterior = tokens[indiceHash - 1];
        if (anterior) selecionados.push(normalizarLinhaVts(anterior));
      }

      selecionados.push(tokens[indiceHash]);

      return normalizarLinhaVts(selecionados.join(' '));
    }

    function obterProximaLinhaVts(linhas, indiceAtual) {
      for (let indice = indiceAtual + 1; indice < linhas.length; indice += 1) {
        const valor = normalizarLinhaVts(linhas[indice]);
        if (!valor) continue;
        if (/^(SKU|Pedido|Pack ID|Remetente|Loja|Quantidade)$/i.test(valor)) continue;
        return valor;
      }
      return '';
    }

    function limparValorSkuVts(texto) {
      if (!texto) return '';

      return normalizarLinhaVts(texto)
        .replace(/^SKU[:\s-]*/i, '')
        .replace(/\b(quantidade|qtd)\b.*$/i, '')
        .replace(/\bloja\b.*$/i, '')
        .replace(/\betiqueta\b.*$/i, '')
        .trim();
    }

    function possuiInformacoesEtiquetaVts(dados) {
      if (!dados) return false;
      return [
        dados.sku,
        dados.pedido,
        dados.rastreio,
        dados.loja,
        dados.dataTexto,
        dados.dataNormalizada,
      ].some(Boolean);
    }

    function extrairAwbMercadoLivreVts(texto) {
      if (!texto) return '';

      const primeiraOcorrencia = texto.match(/(?:Venda|Pack)\s*ID:\s*\d+\s+(\d{10,14})/);
      if (primeiraOcorrencia && primeiraOcorrencia[1]) {
        return primeiraOcorrencia[1].replace(/\s+/g, '');
      }

      const fallback = texto.match(/(?:Venda|Pack)\s*ID:\s*(\d{6,})(?:\s+|\n|$)/);
      if (fallback && fallback[1]) {
        const sequencia = fallback[1].replace(/\s+/g, '');
        const tail = sequencia.match(/(\d{10,14})$/);
        return (tail ? tail[1] : sequencia).replace(/\s+/g, '');
      }

      return '';
    }

    function extrairSkuMercadoLivreVts(texto) {
      if (!texto) return '';

      const match = texto.match(/^.*SKU:\s*(.+)$/im);
      if (!match || !match[1]) return '';

      const conteudo = match[1].replace(/…/g, '').trim();
      if (!conteudo) return '';

      const skuLimpo = limparValorSkuVts(conteudo);
      if (ehSkuValidoVts(skuLimpo)) return skuLimpo;

      const normalizado = normalizarLinhaVts(conteudo);
      if (ehSkuValidoVts(normalizado)) return normalizado;

      return skuLimpo || normalizado;
    }

    function extrairLojaMercadoLivreVts(texto) {
      if (!texto) return '';
      return /Diogo de Almeida Chagas/.test(texto) ? 'Diogo de Almeida Chagas' : '';
    }

    function extrairBuyerUsernameMercadoLivreVts(texto) {
      if (!texto) return '';
      const match = texto.match(/\(([A-Z0-9._-]{4,})\)/i);
      return match && match[1] ? match[1] : '';
    }

    function extrairDataMercadoLivreVts(texto) {
      if (!texto) {
        return { texto: '', normalizada: '' };
      }

      const match = texto.match(/(\d{2})\/(\d{2})\/(\d{4})/);
      if (!match) {
        return { texto: '', normalizada: '' };
      }

      const [, dd, mm, yyyy] = match;
      const dataTexto = `${dd}/${mm}/${yyyy}`;
      return {
        texto: dataTexto,
        normalizada: `${yyyy}-${mm}-${dd}`,
      };
    }

    function buscarSegmentosRastreioMercadoLivreVts(texto) {
      if (!texto) return [];

      const normalizado = texto.replace(/\s+/g, ' ');
      const resultados = [];
      const regex = /(\d{4,7})\s+(\d{4,7})/g;
      let match;

      while ((match = regex.exec(normalizado))) {
        const indice = match.index;
        const bruto = match[0];
        const digitos = bruto.replace(/\D/g, '');
        if (digitos.length < 10 || digitos.length > 15) continue;

        const contextoAntes = normalizado.slice(Math.max(0, indice - 30), indice).toLowerCase();
        if (/\b(pack|venda)\s*id\b/.test(contextoAntes)) continue;

        const contextoDepois = normalizado
          .slice(indice + bruto.length, indice + bruto.length + 30)
          .toLowerCase();
        const contexto = removerAcentosVts(`${contextoAntes} ${contextoDepois}`);
        const prioridade = /\b(despach|despache|despachar|antes das|ate as|horario)\b/.test(contexto)
          ? 0
          : 1;

        resultados.push({
          digitos,
          formatado: `${match[1]} ${match[2]}`.trim(),
          indice,
          prioridade,
        });
      }

      resultados.sort((a, b) => a.prioridade - b.prioridade || a.indice - b.indice);
      return resultados;
    }

    function extrairRastreioSegmentadoMercadoLivreVts(texto, pedidoAtual) {
      if (!texto) return '';

      const pedidoNumerico = (pedidoAtual || '').replace(/\D/g, '');
      const candidatos = buscarSegmentosRastreioMercadoLivreVts(texto);

      for (const candidato of candidatos) {
        if (pedidoNumerico && (candidato.digitos === pedidoNumerico || pedidoNumerico.includes(candidato.digitos))) {
          continue;
        }
        return candidato.formatado;
      }

      return '';
    }

    function formatarRastreioMercadoLivreVts(texto, rastreioAtual) {
      if (!texto || !rastreioAtual) return '';

      const alvo = rastreioAtual.replace(/\D/g, '');
      if (!alvo) return '';

      const candidatos = buscarSegmentosRastreioMercadoLivreVts(texto);
      const encontrado = candidatos.find((candidato) => candidato.digitos === alvo);
      return encontrado ? encontrado.formatado : '';
    }

    function interpretarEtiquetaMercadoLivre(linhas, pagina) {
      const dados = {
        pagina,
        sku: '',
        pedido: '',
        rastreio: '',
        loja: '',
        dataTexto: '',
        dataNormalizada: '',
        buyerUsername: '',
      };

      let indiceUltimoRemetente = -1;

      linhas.forEach((linhaOriginal, indice) => {
        const linha = normalizarLinhaVts(linhaOriginal);
        if (!linha) return;

        if (!dados.pedido) {
          const pedidoMatch = linha.match(/pedido\s*(?:n[úu]mero|n[úu]m|n[ºo°\.]|nº|n°|#)?\s*(?:do)?\s*[:\-]*\s*([A-Z0-9-]+)/i);

          if (pedidoMatch) {
            const pedidoValor = sanitizarCodigoVts(pedidoMatch[1]);
            if (pedidoValor) {
              dados.pedido = pedidoValor;
            }
          } else if (/^pedido$/i.test(linha) || /n[úu]mero do pedido/i.test(linha)) {
            const prox = obterProximaLinhaVts(linhas, indice);
            if (prox) {
              const extraido = sanitizarCodigoVts(prox);
              if (extraido) dados.pedido = extraido;
            }
          }
        }

        if (!dados.pedido) {
          const packMatch = linha.match(/pack\s*id[:\s-]*([A-Z0-9\s-]+)/i);
          if (packMatch) {
            const packValor = extrairCodigoPackVts(packMatch[1]);
            if (packValor) {
              dados.pedido = packValor;

              if (!dados.rastreio) {
                const restanteLinha = linha.replace(packMatch[0], '').trim();
                const rastreioPackLinha = extrairRastreioVts(restanteLinha, dados.pedido);
                if (rastreioPackLinha) dados.rastreio = rastreioPackLinha;
              }
            }
          }
        }

        if (!dados.rastreio) {
          const rastreioExtraido = extrairRastreioVts(linha, dados.pedido);
          if (rastreioExtraido) dados.rastreio = rastreioExtraido;
        }

        if (!dados.sku) {
          if (/sku[:\s-]/i.test(linha)) {
            const segmentoSku = linha.replace(/.*sku[:\s-]*/i, '');
            const valorSku = limparValorSkuVts(segmentoSku);
            if (ehSkuValidoVts(valorSku)) {
              dados.sku = valorSku;

              if (!dados.loja) {
                const resto = normalizarLinhaVts(segmentoSku.replace(valorSku, ''));
                const lojaInline = extrairLojaDeTextoVts(resto);
                const lojaLimpa = limparNomeLojaVts(lojaInline);
                if (ehLojaValidaVts(lojaLimpa)) dados.loja = lojaLimpa;
              }
            }
          } else if (/^sku$/i.test(linha)) {
            const prox = obterProximaLinhaVts(linhas, indice);
            const valorSku = limparValorSkuVts(prox);
            if (ehSkuValidoVts(valorSku)) dados.sku = valorSku;
          }
        }

        if (!dados.sku) {
          const skuInline = linha.match(/\bSKU\b[:\s-]*(.+)/i);
          if (skuInline) {
            const valorSku = limparValorSkuVts(skuInline[1]);
            if (ehSkuValidoVts(valorSku)) {
              dados.sku = valorSku;

              if (!dados.loja) {
                const resto = normalizarLinhaVts(skuInline[1].replace(valorSku, ''));
                const lojaInline = extrairLojaDeTextoVts(resto);
                const lojaLimpa = limparNomeLojaVts(lojaInline);
                if (ehLojaValidaVts(lojaLimpa)) dados.loja = lojaLimpa;
              }
            }
          }
        }

        if (!dados.loja && /#\d{5,}/.test(linha)) {
          const lojaHash = extrairLojaDeTextoVts(linha);
          const lojaLimpa = limparNomeLojaVts(lojaHash);
          if (ehLojaValidaVts(lojaLimpa)) dados.loja = lojaLimpa;
        }

        if (!dados.loja && /remetente/i.test(linha)) {
          indiceUltimoRemetente = indice;
          const nome = linha.replace(/remetente[:\s-]*/i, '').trim();
          const nomeLimpo = limparNomeLojaVts(nome);
          if (ehLojaValidaVts(nomeLimpo)) {
            dados.loja = nomeLimpo;
          } else {
            const prox = obterProximaLinhaVts(linhas, indice);
            const proxLimpo = limparNomeLojaVts(prox);
            if (ehLojaValidaVts(proxLimpo)) dados.loja = proxLimpo;
          }
        }

        if (!dados.loja && /loja/i.test(linha) && !/lojamento/i.test(linha)) {
          const nomeLoja = linha.replace(/loja[:\s-]*/i, '').trim();
          const lojaLimpa = limparNomeLojaVts(nomeLoja);
          if (ehLojaValidaVts(lojaLimpa)) dados.loja = lojaLimpa;
        }

        if (!dados.dataTexto) {
          const dataMatch = linha.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
          if (dataMatch) {
            dados.dataTexto = dataMatch[1];
            dados.dataNormalizada = normalizeDate(dataMatch[1]);
          }
        }
      });

      const textoCompleto = (linhas || [])
        .map((valor) => (valor == null ? '' : String(valor)))
        .join('\n');

      const awb = extrairAwbMercadoLivreVts(textoCompleto);
      if (awb) {
        dados.pedido = awb;
        if (!dados.rastreio && /[A-Za-z]/.test(awb)) dados.rastreio = awb;
      }

      const skuHeuristico = extrairSkuMercadoLivreVts(textoCompleto);
      if (skuHeuristico) {
        dados.sku = skuHeuristico;
      }

      const lojaHeuristica = extrairLojaMercadoLivreVts(textoCompleto);
      if (lojaHeuristica) {
        dados.loja = lojaHeuristica;
      }

      const buyer = extrairBuyerUsernameMercadoLivreVts(textoCompleto);
      if (buyer) {
        dados.buyerUsername = buyer;
      }

      const dataHeuristica = extrairDataMercadoLivreVts(textoCompleto);
      if (dataHeuristica.texto) {
        dados.dataTexto = dataHeuristica.texto;
        dados.dataNormalizada = dataHeuristica.normalizada;
      }

      const rastreioSegmentado = extrairRastreioSegmentadoMercadoLivreVts(textoCompleto, dados.pedido);
      if (rastreioSegmentado) {
        dados.rastreio = rastreioSegmentado;
      } else if (dados.rastreio) {
        const rastreioFormatado = formatarRastreioMercadoLivreVts(textoCompleto, dados.rastreio);
        if (rastreioFormatado) dados.rastreio = rastreioFormatado;
      }

      if (!ehSkuValidoVts(dados.sku)) dados.sku = '';

      if (!dados.sku) {
        const indiceQuantidade = linhas.findIndex((texto) => /quantidade/i.test(texto));
        if (indiceQuantidade > 0) {
          const possivelSku = limparValorSkuVts(linhas[indiceQuantidade - 1]);
          if (ehSkuValidoVts(possivelSku)) dados.sku = possivelSku;
        }
      }

      if (!ehLojaValidaVts(dados.loja) && indiceUltimoRemetente >= 0) {
        for (let i = indiceUltimoRemetente + 1; i < linhas.length; i += 1) {
          const candidato = limparNomeLojaVts(linhas[i]);
          if (ehLojaValidaVts(candidato)) {
            dados.loja = candidato;
            break;
          }
        }
      }

      if (!ehLojaValidaVts(dados.loja)) dados.loja = '';

      if (!dados.loja) {
        for (let i = 0; i < linhas.length; i += 1) {
          const valor = normalizarLinhaVts(linhas[i]);
          if (!valor) continue;
          if (!/#\d{5,}/.test(valor)) continue;
          if (/pedido|pack|sku|quantidade|cep|cnpj|cpf/i.test(valor)) continue;

          const lojaHash = extrairLojaDeTextoVts(valor);
          const lojaLimpa = limparNomeLojaVts(lojaHash);
          if (ehLojaValidaVts(lojaLimpa)) {
            dados.loja = lojaLimpa;
            break;
          }

          const anterior = normalizarLinhaVts(linhas[i - 1] || '');
          const anteriorLimpo = limparNomeLojaVts(anterior);
          if (ehLojaValidaVts(anteriorLimpo)) {
            dados.loja = anteriorLimpo;
            break;
          }
        }
      }

      if (!ehLojaValidaVts(dados.loja)) {
        for (let i = 0; i < linhas.length; i += 1) {
          const candidato = limparNomeLojaVts(linhas[i]);
          if (ehLojaValidaVts(candidato)) {
            dados.loja = candidato;
            break;
          }
        }
      }

      if (!ehLojaValidaVts(dados.loja)) {
        const lojaRastreio = extrairLojaAposRastreioVts(linhas, dados.rastreio);
        if (ehLojaValidaVts(lojaRastreio)) dados.loja = lojaRastreio;
      }

      if (!dados.pedido) {
        const sequencia = linhas
          .map((texto) => normalizarLinhaVts(texto))
          .map((valor) => valor.replace(/\s+/g, ''))
          .find((valor) => /^\d{10,}$/.test(valor));
        if (sequencia) dados.pedido = sequencia;
      }

      if (!dados.pedido || dados.pedido.length < 8) {
        const pedidoGenerico = extrairPedidoGenericoVts(linhas, dados.rastreio);
        if (pedidoGenerico) dados.pedido = pedidoGenerico;
      }

      const possuiInformacoes = [
        dados.sku,
        dados.pedido,
        dados.rastreio,
        dados.loja,
        dados.dataTexto,
        dados.dataNormalizada,
      ].some(Boolean);

      if (!possuiInformacoes) return null;

      return dados;
    }

    function interpretarEtiquetaGenerica(linhas, pagina, opcoes = {}) {
      const dados = {
        pagina,
        sku: '',
        pedido: '',
        rastreio: '',
        loja: '',
        dataTexto: '',
        dataNormalizada: '',
      };

      const pedidoPadroes = opcoes.pedidoPadroes || [
        /pedido\s*(?:n[úu]mero|n[úu]m|n[ºo°\.]|nº|n°|no|#)?\s*(?:do)?\s*[:\-]*\s*([A-Z0-9-]+)/i,
        /order\s*(?:number|no|#)?\s*[:\-]*\s*([A-Z0-9-]+)/i,
        /id\s*(?:pedido|order)\s*[:\-]*\s*([A-Z0-9-]+)/i,
      ];

      const skuPadroes = opcoes.skuPadroes || [
        /sku\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
        /c[oó]digo\s*(?:do\s*produto|produto)?\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
        /refer[eê]ncia\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
      ];

      const lojaPadroes = opcoes.lojaPadroes || [
        /loja\s*(?:de origem|origem)?\s*[:\-]*\s*(.+)/i,
        /vendedor\s*[:\-]*\s*(.+)/i,
        /seller\s*[:\-]*\s*(.+)/i,
        /remetente\s*[:\-]*\s*(.+)/i,
      ];

      linhas.forEach((linhaOriginal, indice) => {
        const linha = normalizarLinhaVts(linhaOriginal);
        if (!linha) return;

        if (!dados.pedido) {
          for (const regex of pedidoPadroes) {
            const match = linha.match(regex);
            if (match && match[1]) {
              const valor = sanitizarCodigoVts(match[1]);
              if (valor) {
                dados.pedido = valor;
                break;
              }
            }
          }

          if (!dados.pedido && /pedido/i.test(linha)) {
            const prox = obterProximaLinhaVts(linhas, indice);
            const valor = sanitizarCodigoVts(prox);
            if (valor) dados.pedido = valor;
          }
        }

        if (!dados.rastreio) {
          const rastreioExtraido = extrairRastreioVts(linha, dados.pedido);
          if (rastreioExtraido) dados.rastreio = rastreioExtraido;
        }

        if (!dados.sku) {
          for (const regex of skuPadroes) {
            const match = linha.match(regex);
            if (match && match[1]) {
              const valorSku = limparValorSkuVts(match[1]);
              if (ehSkuValidoVts(valorSku)) {
                dados.sku = valorSku;
                break;
              }
            }
          }

          if (!dados.sku && /sku/i.test(linha)) {
            const prox = obterProximaLinhaVts(linhas, indice);
            const valorSku = limparValorSkuVts(prox);
            if (ehSkuValidoVts(valorSku)) dados.sku = valorSku;
          }
        }

        if (!dados.loja) {
          for (const regex of lojaPadroes) {
            const match = linha.match(regex);
            if (match && match[1]) {
              const loja = limparNomeLojaVts(match[1]);
              if (ehLojaValidaVts(loja)) {
                dados.loja = loja;
                break;
              }
            }
          }

          if (!dados.loja && /#\d{5,}/.test(linha)) {
            const lojaHash = extrairLojaDeTextoVts(linha);
            const lojaLimpa = limparNomeLojaVts(lojaHash);
            if (ehLojaValidaVts(lojaLimpa)) dados.loja = lojaLimpa;
          }
        }

        if (!dados.dataTexto) {
          const dataMatch = linha.match(/(\d{1,2}\/\d{1,2}\/\d{2,4})/);
          if (dataMatch) {
            dados.dataTexto = dataMatch[1];
            dados.dataNormalizada = normalizeDate(dataMatch[1]);
          }
        }
      });

      if (!dados.loja && dados.rastreio) {
        const lojaAposRastreio = extrairLojaAposRastreioVts(linhas, dados.rastreio);
        if (ehLojaValidaVts(lojaAposRastreio)) dados.loja = lojaAposRastreio;
      }

      if (!ehLojaValidaVts(dados.loja)) dados.loja = '';
      if (!ehSkuValidoVts(dados.sku)) dados.sku = '';

      if (!dados.pedido) {
        const sequencia = linhas
          .map((texto) => normalizarLinhaVts(texto))
          .map((valor) => valor.replace(/\s+/g, ''))
          .find((valor) => /^\d{8,}$/.test(valor));
        if (sequencia) dados.pedido = sequencia;
      }

      if (!dados.rastreio) {
        const fallback = linhas
          .map((texto) => normalizarLinhaVts(texto))
          .map((valor) => extrairRastreioVts(valor, dados.pedido))
          .find((valor) => Boolean(valor));
        if (fallback) dados.rastreio = fallback;
      }

      const possuiInformacoes = possuiInformacoesEtiquetaVts(dados);
      if (!possuiInformacoes) return null;

      return dados;
    }

    function interpretarEtiquetaShopee(linhas, pagina) {
      const textoCompleto = (linhas || [])
        .map((valor) => (valor == null ? '' : String(valor)))
        .join('\n');

      const parsed = parseShopeePage({ text: textoCompleto, pagina }) || {};

      const dadosShopee = {
        pagina,
        modelo: 'shopee',
        sku: parsed.sku || '',
        pedido: parsed.pedido || '',
        rastreio: parsed.rastreio ? parsed.rastreio.toUpperCase() : '',
        loja: parsed.loja || '',
        dataTexto: parsed.dataPrevistaEnvio || '',
        dataNormalizada: parsed.dataPrevistaEnvioISO || '',
        produto: parsed.produto || '',
        qtd: parsed.qtd || '',
        nfeChave: parsed.nfeChave || '',
        emissaoNFe: parsed.emissaoNFe || '',
        emissaoNFeISO: parsed.emissaoNFeISO || '',
        dataPrevistaEnvio: parsed.dataPrevistaEnvio || '',
        dataPrevistaEnvioISO: parsed.dataPrevistaEnvioISO || '',
      };

      if (!dadosShopee.dataTexto && parsed.emissaoNFe) {
        dadosShopee.dataTexto = parsed.emissaoNFe;
        dadosShopee.dataNormalizada = parsed.emissaoNFeISO
          ? parsed.emissaoNFeISO.split('T')[0]
          : '';
      }

      if (!dadosShopee.sku && parsed.produto) {
        dadosShopee.sku = parsed.produto;
      }

      if (!dadosShopee.qtd) {
        dadosShopee.qtd = '1';
      }

      if (possuiInformacoesEtiquetaVts(dadosShopee)) {
        return dadosShopee;
      }

      const resultadoGenerico = interpretarEtiquetaGenerica(linhas, pagina, {
        pedidoPadroes: [
          /pedido\s*(?:n[úu]mero|n[ºo°]|nº|n°|#)?\s*[:\-]*\s*([A-Z0-9-]+)/i,
          /order\s*(?:id|number|no)?\s*[:\-]*\s*([A-Z0-9-]+)/i,
          /refer[eê]ncia\s*(?:do)?\s*pedido\s*[:\-]*\s*([A-Z0-9-]+)/i,
        ],
        skuPadroes: [
          /sku\s*(?:principal|produto)?\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
          /varia[cç][aã]o\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
          /item\s*id\s*[:\-]*\s*([A-Z0-9\-]+)/i,
        ],
        lojaPadroes: [
          /loja\s*(?:oficial|origem)?\s*[:\-]*\s*(.+)/i,
          /vendedor\s*[:\-]*\s*(.+)/i,
          /seller\s*[:\-]*\s*(.+)/i,
        ],
      });

      if (possuiInformacoesEtiquetaVts(resultadoGenerico)) {
        return resultadoGenerico;
      }

      const resultadoMercadoLivre = interpretarEtiquetaMercadoLivre(linhas, pagina);
      if (possuiInformacoesEtiquetaVts(resultadoMercadoLivre)) {
        return resultadoMercadoLivre;
      }

      return null;
    }

    function interpretarEtiquetaMagalu(linhas, pagina) {
      const resultadoGenerico = interpretarEtiquetaGenerica(linhas, pagina, {
        pedidoPadroes: [
          /pedido\s*(?:magalu|marketplace)?\s*[:\-]*\s*([A-Z0-9-]+)/i,
          /numero\s*do\s*pedido\s*[:\-]*\s*([A-Z0-9-]+)/i,
          /ordem\s*[:\-]*\s*([A-Z0-9-]+)/i,
        ],
        skuPadroes: [
          /sku\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
          /c[oó]digo\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
          /refer[eê]ncia\s*[:\-]*\s*([A-Z0-9\-\.\/]+)/i,
        ],
        lojaPadroes: [
          /loja\s*(?:magalu)?\s*[:\-]*\s*(.+)/i,
          /seller\s*[:\-]*\s*(.+)/i,
          /remetente\s*[:\-]*\s*(.+)/i,
        ],
      });

      if (possuiInformacoesEtiquetaVts(resultadoGenerico)) {
        return resultadoGenerico;
      }

      return interpretarEtiquetaMercadoLivre(linhas, pagina);
    }

    function obterInterpretadorPorModeloVts(modelo) {
      switch (modelo) {
        case 'shopee':
          return interpretarEtiquetaShopee;
        case 'magalu':
          return interpretarEtiquetaMagalu;
        case 'mercadoLivre':
        default:
          return interpretarEtiquetaMercadoLivre;
      }
    }

    async function extrairEtiquetasDePdf(arquivo, modelo = 'mercadoLivre') {
      if (!window.pdfjsLib) {
        throw new Error('Biblioteca PDF.js não carregada.');
      }

      const interpretador = obterInterpretadorPorModeloVts(modelo);
      const arrayBuffer = await arquivo.arrayBuffer();
      const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      const resultados = [];
      const diagnostico = [];
      const paginasMagalu = [];

      for (let pagina = 1; pagina <= pdf.numPages; pagina += 1) {
        const paginaPdf = await pdf.getPage(pagina);
        const conteudo = await paginaPdf.getTextContent();

        const linhas = [];
        let atual = '';

        conteudo.items.forEach((item) => {
          const texto = normalizarLinhaVts(item.str);
          if (!texto) return;

          if (atual) {
            atual += ` ${texto}`;
          } else {
            atual = texto;
          }

          if (item.hasEOL) {
            linhas.push(atual);
            atual = '';
          }
        });

        if (atual) {
          linhas.push(atual);
        }

        if (modelo === 'magalu') {
          paginasMagalu.push({
            pagina,
            linhas: linhas.slice(),
            texto: linhas.join('\n'),
          });
        } else {
          const interpretadoBase = interpretador(linhas, pagina);
          const interpretado = interpretadoBase
            ? { ...interpretadoBase, modelo }
            : null;
          diagnostico.push({
            pagina,
            modelo,
            linhas: linhas.slice(),
            interpretado: interpretado ? { ...interpretado } : null,
          });
          if (interpretado) {
            resultados.push(interpretado);
          }
        }
      }

      if (modelo === 'magalu') {
        for (let indice = 0; indice < paginasMagalu.length; indice += 2) {
          const atual = paginasMagalu[indice] || null;
          const proxima = paginasMagalu[indice + 1] || null;

          const paginasParaParser = [];
          if (atual) paginasParaParser.push({ pagina: 1, text: atual.texto });
          if (proxima) {
            paginasParaParser.push({
              pagina: paginasParaParser.length ? 2 : 1,
              text: proxima.texto,
            });
          }

          const interpretadoBase = parseMagalu(paginasParaParser);
          const interpretadoValido =
            interpretadoBase && possuiInformacoesEtiquetaVts(interpretadoBase)
              ? {
                  ...interpretadoBase,
                  modelo,
                  pagina: proxima?.pagina ?? atual?.pagina ?? indice + 1,
                }
              : null;

          if (atual) {
            diagnostico.push({
              pagina: atual.pagina,
              modelo,
              linhas: atual.linhas.slice(),
              interpretado: interpretadoValido ? { ...interpretadoValido } : null,
            });
          }
          if (proxima) {
            diagnostico.push({
              pagina: proxima.pagina,
              modelo,
              linhas: proxima.linhas.slice(),
              interpretado: interpretadoValido ? { ...interpretadoValido } : null,
            });
          }

          if (interpretadoValido) {
            resultados.push(interpretadoValido);
          }
        }
      }

      return { registros: resultados, diagnostico };
    }

    async function processarPdfVts(modelo = 'mercadoLivre') {
      const config = VTS_MODELOS_CONFIG[modelo];
      if (!config) return;

      const input = document.getElementById(config.inputId);
      const botao = document.getElementById(config.buttonId);
      const indicador = document.getElementById('vtsLoading');

      if (!input || !botao) return;

      const arquivo = input.files && input.files[0];
      if (!arquivo) {
        setVtsFeedback(
          `Selecione um arquivo PDF de etiquetas ${obterNomeModeloVts(modelo)} para continuar.`,
          'warning',
          modelo,
        );
        return;
      }

      try {
        botao.disabled = true;
        if (indicador) {
          indicador.classList.remove('hidden');
          indicador.style.display = 'flex';
        }
        setVtsFeedback(
          `Processando etiquetas ${obterNomeModeloVts(modelo)}, aguarde...`,
          'info',
          modelo,
        );

        const { registros: etiquetas, diagnostico } = await extrairEtiquetasDePdf(arquivo, modelo);
        atualizarDiagnosticoVts(diagnostico, arquivo.name, modelo);

        if (!etiquetas.length) {
          setVtsFeedback(
            `Nenhuma etiqueta ${obterNomeModeloVts(modelo)} reconhecida no PDF. Verifique o modelo e tente novamente.`,
            'warning',
            modelo,
          );
          return;
        }

        const resultadoSalvamento = await salvarEtiquetasVts(etiquetas, arquivo, modelo);

        if (resultadoSalvamento?.cancelado) {
          setVtsFeedback(
            `Importação cancelada: informe a data em que as etiquetas ${obterNomeModeloVts(modelo)} foram colocadas para continuar.`,
            'warning',
            modelo,
          );
          return;
        }

        const { salvos = 0, ignorados = 0 } = resultadoSalvamento || {};

        const mensagens = [];
        if (salvos > 0) {
          mensagens.push(`${salvos} etiqueta(s) ${obterNomeModeloVts(modelo)} registrada(s) com sucesso.`);
        }
        if (ignorados > 0) {
          mensagens.push(
            `${ignorados} etiqueta(s) ignorada(s) porque o pedido já estava cadastrado anteriormente.`,
          );
        }
        if (!mensagens.length) {
          mensagens.push('Nenhuma etiqueta nova foi registrada.');
        }

        const tipoFeedback = salvos > 0 ? 'success' : ignorados > 0 ? 'warning' : 'info';
        setVtsFeedback(mensagens.join(' '), tipoFeedback, modelo);
        input.value = '';
        await carregarEtiquetasVts();
      } catch (erro) {
        console.error('Erro ao processar PDF de etiquetas VTS:', erro);
        setVtsFeedback(
          'Não foi possível processar o arquivo. Confirme se o PDF está legível e tente novamente.',
          'error',
          modelo,
        );
        atualizarDiagnosticoVts([], '', modelo);
      } finally {
        botao.disabled = false;
        if (indicador) {
          indicador.style.display = 'none';
          indicador.classList.add('hidden');
        }
      }
    }

    async function inicializarAbaVts() {
      const container = document.getElementById('vts');
      if (!container) return;

      const toggle = document.getElementById('vtsToggleDebug');
      const debugContainer = document.getElementById('vtsDebugContainer');

      if (!container.dataset.initialized) {
        Object.entries(VTS_MODELOS_CONFIG).forEach(([modelo, config]) => {
          const botaoModelo = document.getElementById(config.buttonId);
          const inputModelo = document.getElementById(config.inputId);

          if (botaoModelo && !botaoModelo.dataset.bound) {
            botaoModelo.addEventListener('click', () => processarPdfVts(modelo));
            botaoModelo.dataset.bound = 'true';
          }

          if (inputModelo && !inputModelo.dataset.bound) {
            inputModelo.addEventListener('change', () => {
              if (inputModelo.files && inputModelo.files[0]) {
                setVtsFeedback(
                  `Arquivo "${inputModelo.files[0].name}" selecionado para ${obterNomeModeloVts(modelo)}. Clique em "Processar etiquetas" para continuar.`,
                  'info',
                  modelo,
                );
              } else {
                setVtsFeedback('', 'info', modelo);
              }
            });
            inputModelo.dataset.bound = 'true';
          }
        });
        const formularioManual = document.getElementById('vtsEntradaManualForm');
        if (formularioManual && !formularioManual.dataset.bound) {
          formularioManual.addEventListener('submit', registrarEntradaManualVts);
          formularioManual.dataset.bound = 'true';
        }
        const formularioDevolucao = document.getElementById('vtsDevolucaoForm');
        if (formularioDevolucao && !formularioDevolucao.dataset.bound) {
          formularioDevolucao.addEventListener('submit', registrarDevolucaoVts);
          formularioDevolucao.dataset.bound = 'true';
        }
        const botaoImportarDevolucao = document.getElementById('vtsDevolucaoImportar');
        if (botaoImportarDevolucao && !botaoImportarDevolucao.dataset.bound) {
          botaoImportarDevolucao.addEventListener('click', importarDevolucoesPlanilhaVts);
          botaoImportarDevolucao.dataset.bound = 'true';
        }
        if (toggle && debugContainer && !toggle.dataset.bound) {
          toggle.addEventListener('click', () => {
            const estaOculto = debugContainer.classList.contains('hidden');
            if (estaOculto) {
              debugContainer.classList.remove('hidden');
              toggle.textContent = 'Ocultar diagnóstico';
              if (!vtsUltimoDiagnostico.length) {
                atualizarDiagnosticoVts(vtsUltimoDiagnostico, vtsUltimoArquivo, vtsUltimoModelo);
              }
            } else {
              debugContainer.classList.add('hidden');
              toggle.textContent = 'Mostrar diagnóstico';
            }
          });
          toggle.dataset.bound = 'true';
        }
        const botaoExportar = document.getElementById('vtsExportarExcel');
        if (botaoExportar && !botaoExportar.dataset.bound) {
          botaoExportar.addEventListener('click', exportarEtiquetasVtsExcel);
          botaoExportar.dataset.bound = 'true';
        }
        const botaoExportarPdf = document.getElementById('vtsExportarPdf');
        if (botaoExportarPdf && !botaoExportarPdf.dataset.bound) {
          botaoExportarPdf.addEventListener('click', exportarEtiquetasVtsPdf);
          botaoExportarPdf.dataset.bound = 'true';
        }
        const botaoExcluirSelecionados = document.getElementById('vtsExcluirSelecionados');
        if (botaoExcluirSelecionados && !botaoExcluirSelecionados.dataset.bound) {
          botaoExcluirSelecionados.addEventListener('click', excluirEtiquetasSelecionadasVts);
          botaoExcluirSelecionados.dataset.bound = 'true';
        }
        const inputImportar = document.getElementById('vtsImportarExcel');
        if (inputImportar && !inputImportar.dataset.bound) {
          inputImportar.addEventListener('change', importarEtiquetasVtsExcel);
          inputImportar.dataset.bound = 'true';
        }
        const selecionarTodos = document.getElementById('vtsSelecionarTodos');
        if (selecionarTodos && !selecionarTodos.dataset.bound) {
          selecionarTodos.addEventListener('change', (evento) => {
            const registrosVisiveis = obterEtiquetasFiltradasVts();
            if (evento.target.checked) {
              registrosVisiveis.forEach((item) => {
                if (item?.id) {
                  vtsEtiquetasSelecionadas.add(item.id);
                }
              });
            } else {
              registrosVisiveis.forEach((item) => {
                if (item?.id) {
                  vtsEtiquetasSelecionadas.delete(item.id);
                }
              });
            }
            renderizarEtiquetasVts(registrosVisiveis);
          });
          selecionarTodos.dataset.bound = 'true';
        }
        configurarSubtabsVts();
        configurarAssociacoesVts();
        configurarFiltrosVts();
        configurarResumoVtsExportacoes();
        container.dataset.initialized = 'true';
      }

      await carregarAssociacoesSkuVts();
      await carregarEtiquetasVts();
      atualizarDiagnosticoVts(vtsUltimoDiagnostico, vtsUltimoArquivo, vtsUltimoModelo);
    }


    // =============================================
    // FUNÇÕES DE GERENCIAMENTO DE METAS
    // =============================================
    function extrairInfoCustoProduto(entrada) {
      if (entrada === undefined || entrada === null) {
        return { valor: null, comissao: null };
      }
      if (typeof entrada === 'object') {
        const valor = normalizarNumeroMeta(
          entrada.valor ?? entrada.custo ?? entrada.preco ?? entrada.base ?? null,
          null
        );
        const comissao = normalizarNumeroMeta(
          entrada.comissao ?? entrada.percentual ?? entrada.comissaoPercentual ?? entrada.taxa ?? null,
          null
        );
        return {
          valor: numeroValido(valor) ? valor : null,
          comissao: numeroValido(comissao) ? comissao : (comissao === 0 ? 0 : null)
        };
      }
      const valorNormalizado = normalizarNumeroMeta(entrada, null);
      return {
        valor: numeroValido(valorNormalizado) ? valorNormalizado : null,
        comissao: null
      };
    }

    function selecionarPrimeiroNumeroValido(...valores) {
      for (const valor of valores) {
        if (numeroValido(valor) || valor === 0) {
          return valor;
        }
      }
      return null;
    }

    function calcularValorTotalComComissao(info) {
      if (!info || !numeroValido(info.valor)) {
        return null;
      }

      const percentualComissao =
        numeroValido(info.comissao) || info.comissao === 0
          ? Number(info.comissao)
          : null;

      if (percentualComissao === null) {
        return info.valor;
      }

      return info.valor + (info.valor * percentualComissao) / 100;
    }

    async function obterSnapshotProdutosUsuario(uid) {
      if (!db || !uid) {
        return null;
      }

      const baseCollection = db.collection('uid');
      const directRef = baseCollection.doc(uid).collection('produtos');
      let directSnapshot = null;

      try {
        directSnapshot = await directRef.get();
      } catch (error) {
        console.error('Erro ao buscar produtos no caminho padrão:', error);
      }

      if (directSnapshot && !directSnapshot.empty) {
        return directSnapshot;
      }

      if (!(firebase && firebase.firestore && firebase.firestore.FieldPath)) {
        return directSnapshot;
      }

      try {
        const docIdField = firebase.firestore.FieldPath.documentId();
        const prefix = `${uid} (`;
        const possiveisDocs = await baseCollection
          .where(docIdField, '>=', prefix)
          .where(docIdField, '<', prefix + '')
          .limit(1)
          .get();

        if (!possiveisDocs.empty) {
          const alternativaSnapshot = await possiveisDocs.docs[0].ref
            .collection('produtos')
            .get();

          if (alternativaSnapshot && !alternativaSnapshot.empty) {
            return alternativaSnapshot;
          }

          if (!directSnapshot) {
            directSnapshot = alternativaSnapshot;
          }
        }
      } catch (error) {
        console.error('Erro ao localizar coleção alternativa de produtos:', error);
      }

      return directSnapshot;
    }

    async function carregarProdutos() {
      try {
        const snapshot = await obterSnapshotProdutosUsuario(usuarioLogado.uid);
        produtos = {};
        const datalist = document.getElementById('listaSkus');
        if (datalist) datalist.innerHTML = '';

        if (!snapshot) {
          return;
        }

        snapshot.forEach(doc => {
          const data = doc.data() || {};
          const sku = (data.sku || '').toString().trim();
          if (!sku) return;

          const custosBrutos = data.custos || {};
          const calculosTaxas = data.calculosTaxas || {};
          const minimoInfo = extrairInfoCustoProduto(custosBrutos.minimo);
          const medioInfo = extrairInfoCustoProduto(custosBrutos.medio);
          const maximoInfo = extrairInfoCustoProduto(custosBrutos.maximo);
          const minimoTaxaInfo = extrairInfoCustoProduto(calculosTaxas.minimo);
          const medioTaxaInfo = extrairInfoCustoProduto(calculosTaxas.medio);
          const maximoTaxaInfo = extrairInfoCustoProduto(calculosTaxas.maximo);
          const minimoTotal = selecionarPrimeiroNumeroValido(
            minimoInfo.valor,
            calcularValorTotalComComissao(minimoInfo),
            minimoTaxaInfo.valor
          );
          const medioTotal = selecionarPrimeiroNumeroValido(
            medioInfo.valor,
            calcularValorTotalComComissao(medioInfo),
            medioTaxaInfo.valor,
            minimoTotal
          );
          const maximoTotal = selecionarPrimeiroNumeroValido(
            maximoInfo.valor,
            calcularValorTotalComComissao(maximoInfo),
            maximoTaxaInfo.valor,
            medioTotal,
            minimoTotal
          );
          const custoFallback = normalizarNumeroMeta(data.custo, null);
          const custoParaMeta = selecionarPrimeiroNumeroValido(
            minimoInfo.valor,
            minimoTotal,
            medioInfo.valor,
            medioTotal,
            maximoInfo.valor,
            maximoTotal,
            custoFallback
          );

          produtos[sku] = numeroValido(custoParaMeta) ? custoParaMeta : 0;

          if (datalist) {
            const opt = document.createElement('option');
            const preco = Number(produtos[sku] || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
            opt.value = sku;
            opt.label = `${sku} - R$ ${preco}`;
            datalist.appendChild(opt);
          }
        });
      } catch (error) {
        console.error('Erro ao carregar produtos:', error);
      }
    }

    async function carregarMetas(opcoes = {}) {
      const {
        atualizarDatalist = true,
        renderizarInterface = true,
        mostrarLoading = true
      } = opcoes;

      try {
        if (mostrarLoading) {
          toggleLoading(
            document.getElementById('btnAdicionarMeta'),
            '<i class="fas fa-plus"></i> Adicionar Meta'
          );
        }

        return await executarComRetry(async () => {
          metas = {};
          metasNormalizadas = {};
          // Carrega SKUs e custo dos produtos cadastrados
          const produtosSnap = await obterSnapshotProdutosUsuario(usuarioLogado.uid);
          produtos = {};
          const datalist = atualizarDatalist ? document.getElementById('listaSkus') : null;
          if (datalist) datalist.innerHTML = '';

          if (produtosSnap) {
            produtosSnap.forEach((doc) => {
              const data = doc.data() || {};
              const sku = (data.sku || '').toString().trim();
              if (!sku) return;

              const custosBrutos = data.custos || {};
              const calculosTaxas = data.calculosTaxas || {};
              const minimoInfo = extrairInfoCustoProduto(custosBrutos.minimo);
              const medioInfo = extrairInfoCustoProduto(custosBrutos.medio);
              const maximoInfo = extrairInfoCustoProduto(custosBrutos.maximo);
              const minimoTaxaInfo = extrairInfoCustoProduto(calculosTaxas.minimo);
              const medioTaxaInfo = extrairInfoCustoProduto(calculosTaxas.medio);
              const maximoTaxaInfo = extrairInfoCustoProduto(calculosTaxas.maximo);
              const custoFallback = normalizarNumeroMeta(data.custo, null);

              const minimoTotal = selecionarPrimeiroNumeroValido(
                minimoTaxaInfo.valor,
                calcularValorTotalComComissao(minimoInfo),
                minimoInfo.valor
              );

              const medioTotal = selecionarPrimeiroNumeroValido(
                medioTaxaInfo.valor,
                calcularValorTotalComComissao(medioInfo),
                medioInfo.valor,
                minimoTotal
              );

              const maximoTotal = selecionarPrimeiroNumeroValido(
                maximoTaxaInfo.valor,
                calcularValorTotalComComissao(maximoInfo),
                maximoInfo.valor,
                medioTotal,
                minimoTotal,
                custoFallback
              );

              const comissoesPorFaixa = {
                minimo: selecionarPrimeiroNumeroValido(minimoTaxaInfo.comissao, minimoInfo.comissao),
                medio: selecionarPrimeiroNumeroValido(medioTaxaInfo.comissao, medioInfo.comissao),
                maximo: selecionarPrimeiroNumeroValido(maximoTaxaInfo.comissao, maximoInfo.comissao)
              };

              const custoMinimoParaMeta = selecionarPrimeiroNumeroValido(
                minimoInfo.valor,
                minimoTotal,
                medioInfo.valor,
                medioTotal,
                maximoInfo.valor,
                maximoTotal,
                custoFallback
              );

              metas[sku] = {
                valor: numeroValido(custoMinimoParaMeta) ? custoMinimoParaMeta : 0,
                minimo: numeroValido(minimoTotal) ? minimoTotal : null,
                medio: numeroValido(medioTotal) ? medioTotal : null,
                maximo: numeroValido(maximoTotal)
                  ? maximoTotal
                  : (numeroValido(medioTotal) ? medioTotal : null),
                comissaoPercentual: selecionarPrimeiroNumeroValido(
                  maximoTaxaInfo.comissao,
                  maximoInfo.comissao
                ),
                comissaoFixa: null,
                comissoes: comissoesPorFaixa,
                atualizadoEm: new Date()
              };

              registrarMetaNormalizada(sku, metas[sku]);

              produtos[sku] = numeroValido(custoMinimoParaMeta) ? custoMinimoParaMeta : 0;

              if (datalist) {
                const opt = document.createElement('option');
                opt.value = sku;
                const preco = Number(produtos[sku] || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
                opt.label = `${sku} - R$ ${preco}`;
                datalist.appendChild(opt);
              }
            });
          }

          // Sobrepõe com metas salvas manualmente se existirem
          let metasSnapQuery = db.collection("metasSKU");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            metasSnapQuery = metasSnapQuery.where('uid', '==', usuarioLogado.uid);
          }
          const metasSnap = await metasSnapQuery.get();
          metasSnap.forEach((doc) => {
            const originalSku = doc.id.replaceAll('__', '/');
            const metaDoc = doc.data() || {};
            const metaAtual = obterMetaSku(originalSku) || {};
            const valorDoc = normalizarNumeroMeta(metaDoc.valor, metaAtual.valor ?? 0);
            const minimoDoc = normalizarNumeroMeta(
              metaDoc.minimo ?? metaDoc.valorMinimo ?? metaDoc.sobraMinimo ?? metaDoc.faixaMinima,
              metaAtual.minimo ?? null
            );
            const medioDoc = normalizarNumeroMeta(
              metaDoc.medio ?? metaDoc.valorMedio ?? metaDoc.sobraMedio ?? metaDoc.faixaMedia,
              metaAtual.medio ?? null
            );
            const maximoDoc = normalizarNumeroMeta(
              metaDoc.maximo ?? metaDoc.valorMaximo ?? metaDoc.sobraMaximo ?? metaDoc.faixaMaxima,
              metaAtual.maximo ?? null
            );
            const comissaoPercentualDoc = normalizarNumeroMeta(
              metaDoc.comissaoPercentual ?? metaDoc.percentualComissao ?? metaDoc.comissao,
              metaAtual.comissaoPercentual ?? null
            );
            const comissaoFixaDoc = normalizarNumeroMeta(
              metaDoc.comissaoFixa ?? metaDoc.comissaoValor ?? metaDoc.valorComissao ?? metaDoc.comissaoFixaReais,
              metaAtual.comissaoFixa ?? null
            );

            const comissoesExistentes = metaAtual.comissoes || {};
            const extrairComissaoNivel = (nivel, ...campos) => {
              for (const campo of campos) {
                if (metaDoc[campo] !== undefined) {
                  const valorCampo = normalizarNumeroMeta(metaDoc[campo], comissoesExistentes[nivel] ?? null);
                  if (numeroValido(valorCampo) || valorCampo === 0) return valorCampo;
                }
              }
              const infoCustos = metaDoc.custos && metaDoc.custos[nivel];
              if (infoCustos) {
                const infoNormalizada = extrairInfoCustoProduto(infoCustos);
                if (numeroValido(infoNormalizada.comissao) || infoNormalizada.comissao === 0) {
                  return infoNormalizada.comissao;
                }
              }
              const existente = comissoesExistentes[nivel];
              if (numeroValido(existente) || existente === 0) return existente;
              return null;
            };

            const comissoesAtualizadas = {
              minimo: extrairComissaoNivel('minimo', 'comissaoMinimo', 'percentualMinimo'),
              medio: extrairComissaoNivel('medio', 'comissaoMedio', 'percentualMedio'),
              maximo: extrairComissaoNivel('maximo', 'comissaoMaximo', 'percentualMaximo')
            };

            let atualizadoEm = new Date();
            if (metaDoc.atualizadoEm) {
              if (typeof metaDoc.atualizadoEm.toDate === 'function') {
                atualizadoEm = metaDoc.atualizadoEm.toDate();
              } else {
                const dataConvertida = new Date(metaDoc.atualizadoEm);
                if (!Number.isNaN(dataConvertida.getTime())) {
                  atualizadoEm = dataConvertida;
                }
              }
            }

            metas[originalSku] = {
              valor: numeroValido(valorDoc)
                ? valorDoc
                : numeroValido(metaAtual.valor)
                  ? metaAtual.valor
                  : 0,
              minimo: numeroValido(minimoDoc) ? minimoDoc : null,
              medio: numeroValido(medioDoc) ? medioDoc : null,
              maximo: numeroValido(maximoDoc) ? maximoDoc : null,
              comissaoPercentual: numeroValido(comissaoPercentualDoc)
                ? comissaoPercentualDoc
                : (numeroValido(comissoesAtualizadas.medio) || comissoesAtualizadas.medio === 0)
                  ? comissoesAtualizadas.medio
                  : numeroValido(metaAtual.comissaoPercentual)
                    ? metaAtual.comissaoPercentual
                    : null,
              comissaoFixa: numeroValido(comissaoFixaDoc) ? comissaoFixaDoc : null,
              comissoes: comissoesAtualizadas,
              atualizadoEm
            };

            registrarMetaNormalizada(originalSku, metas[originalSku]);
          });

          if (renderizarInterface) {
            renderizarMetas();
          }
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar metas: ${error.message}`);
        console.error("Erro ao carregar metas:", error);
        return false;
      } finally {
        if (mostrarLoading) {
          toggleLoading(
            document.getElementById('btnAdicionarMeta'),
            '<i class="fas fa-plus"></i> Adicionar Meta'
          );
        }
      }
    }

    async function carregarHistorico() {
      try {
        return await executarComRetry(async () => {
          historico = [];
          let histQuery = db.collection("historicoMetas");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            histQuery = histQuery.where('uid', '==', usuarioLogado.uid);
          }
          const snapshot = await histQuery.orderBy("data", "desc").limit(50).get();          
          snapshot.forEach((doc) => {
            historico.push({
              sku: doc.data().sku,
              acao: doc.data().acao,
              valorAnterior: doc.data().valorAnterior,
              valorNovo: doc.data().valorNovo,
              data: doc.data().data.toDate(),
              usuario: doc.data().usuario || 'Sistema'
            });
          });
          
          renderizarHistorico();
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar histórico: ${error.message}`);
        console.error("Erro ao carregar histórico:", error);
        return false;
      }
    }

    async function registrarHistorico(sku, acao, valorAnterior, valorNovo) {
      try {
        await executarComRetry(async () => {
          await db.collection("historicoMetas").add({
            sku: sku,
            acao: acao,
            valorAnterior: valorAnterior,
            valorNovo: valorNovo,
            data: new Date(),
            usuario: "Usuário", // Em um sistema real, pegaria do auth
            uid: usuarioLogado.uid
          });
          
          // Recarregar histórico após adicionar novo registro
          await carregarHistorico();
          return true;
        });
      } catch (error) {
        console.error("Erro ao registrar histórico:", error);
        throw error;
      }
    }

    function renderizarMetas() {
      const tbody = document.querySelector('#tabelaMetas tbody');
      tbody.innerHTML = '';
      
      if (Object.keys(metas).length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Nenhuma meta cadastrada</td></tr>';
        return;
      }
      
      for (let sku in metas) {
        const meta = metas[sku];
        const precoProduto = produtos[sku];
        const dataFormatada = meta.atualizadoEm ? meta.atualizadoEm.toLocaleDateString('pt-BR') : 'N/A';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${sku}</td>
          <td>${precoProduto ? 'R$ ' + parseFloat(precoProduto).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) : '-'}</td>
          <td>
            <span class="valorMeta">R$ ${meta.valor.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</span>
            <input class="editInput" type="number" value="${meta.valor}" step="0.01" />
          </td>
          <td>${dataFormatada}</td>
          <td>
            <button onclick="editarMeta(this, '${sku}')" class="btn btn-sm" style="background: rgba(99, 102, 241, 0.1); color: var(--primary);">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="excluirMeta('${sku}', this)" class="btn btn-sm" style="background: rgba(239, 71, 111, 0.1); color: var(--error);">
              <i class="fas fa-trash-alt"></i>
            </button>
          </td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderizarHistorico() {
      const lista = document.getElementById('listaHistorico');
      lista.innerHTML = '';
      
      if (historico.length === 0) {
        lista.innerHTML = '<div class="history-item" style="text-align: center;">Nenhum registro histórico encontrado</div>';
        return;
      }
      
      historico.forEach(item => {
        const div = document.createElement('div');
        div.className = 'history-item';
        
        let acaoTexto = '';
        let valorTexto = '';
        
        if (item.acao === 'adicionar') {
          acaoTexto = `<span class="badge badge-success">Adicionado</span>`;
          valorTexto = `Novo valor: R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'editar') {
          acaoTexto = `<span class="badge badge-warning">Editado</span>`;
          valorTexto = `De R$ ${item.valorAnterior?.toFixed(2) || '0.00'} para R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'remover') {
          acaoTexto = `<span class="badge badge-danger">Removido</span>`;
          valorTexto = `Valor anterior: R$ ${item.valorAnterior?.toFixed(2) || '0.00'}`;
        }
        
        div.innerHTML = `
          <div class="flex justify-between items-start flex-wrap gap-4 p-4 rounded-lg shadow transition hover:shadow-xl border border-gray-200 bg-white">
            <div>
              <div class="flex items-center gap-2 mb-2">
                <strong class="text-blue-800">${item.sku}</strong>
                ${acaoTexto}
              </div>
              <div class="text-sm text-gray-600">${valorTexto}</div>
              <div class="text-sm text-gray-500 mt-1">👤 Por: ${item.usuario}</div>
            </div>
            <div class="text-sm text-gray-500 text-right">
              <i class="fas fa-clock"></i>
              ${item.data.toLocaleDateString('pt-BR')}<br>${item.data.toLocaleTimeString('pt-BR')}
            </div>
          </div>
        `;
        
        lista.appendChild(div);
      });
    }

    function filtrarHistorico() {
      const filtro = document.getElementById('filtroHistorico').value.toLowerCase();
      const itens = document.querySelectorAll('#listaHistorico .history-item');
      
      itens.forEach(item => {
        const sku = item.querySelector('strong')?.textContent.toLowerCase() || '';
        item.style.display = sku.includes(filtro) ? '' : 'none';
      });
    }

    async function adicionarMeta() {
      const skuInput = document.getElementById('metaSku');
      const valorInput = document.getElementById('metaValor');
      
      const sku = skuInput.value.trim();
      const valor = parseFloat(valorInput.value);
      
      if (!sku) {
        mostrarErro('Por favor, informe o SKU do produto.');
        skuInput.focus();
        return;
      }
      
      if (isNaN(valor) || valor <= 0) {
        mostrarErro('Por favor, informe um valor válido para a meta (maior que zero).');
        valorInput.focus();
        return;
      }
      if (!produtos[sku]) {
        const usarIA = confirm("SKU não cadastrado. Deseja uma sugestão de meta via IA?");
        
        if (usarIA) {
            try {
                const categoria = prompt("Informe a categoria do produto:");
                if (categoria === null) return;
                
                const custo = prompt("Informe o custo do produto:");
                if (custo === null) return;
                
                const margem = prompt("Informe a margem esperada (%):");
                if (margem === null) return;
                
                const concorrentes = prompt("Informe o preço médio dos concorrentes:");
                if (concorrentes === null) return;

                const promptText = `Sugira uma meta de sobra para: ${categoria} | Custo: R$${custo} | Margem: ${margem}% | Concorrentes: ${concorrentes}`;
                
                const resposta = await consultarDeepSeek(promptText);
                const match = resposta.match(/R\$\s*([\d.,]+)/);
                const valorSugerido = match ? parseFloat(match[1].replace('.', '').replace(',', '.')) : null;
                
                if (valorSugerido && !isNaN(valorSugerido)) {
                    valorInput.value = valorSugerido.toFixed(2);
                    mostrarSucesso(`Sugestão da IA: R$ ${valorSugerido.toFixed(2)}`);
                } else {
                    mostrarErro("Não consegui extrair o valor. Resposta completa: " + resposta);
                }
            } catch (error) {
                mostrarErro(`Erro na consulta: ${error.message}`);
            }
            return;
        }
        }
      try {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
        
        const safeSku = sku.replaceAll('/', '__');
        const metaAtual = obterMetaSku(sku) || {};
        const minimoExistente = numeroValido(metaAtual.minimo) ? metaAtual.minimo : null;
        const medioExistente = numeroValido(metaAtual.medio) ? metaAtual.medio : null;
        const maximoExistente = numeroValido(metaAtual.maximo) ? metaAtual.maximo : null;
        const comissaoPercentualExistente = numeroValido(metaAtual.comissaoPercentual)
          ? metaAtual.comissaoPercentual
          : null;
        const comissaoFixaExistente = numeroValido(metaAtual.comissaoFixa)
          ? metaAtual.comissaoFixa
          : null;

        const metaData = {
          valor: valor,
          minimo: minimoExistente,
          medio: medioExistente,
          maximo: maximoExistente,
          comissaoPercentual: comissaoPercentualExistente,
          comissaoFixa: comissaoFixaExistente,
          atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
          uid: usuarioLogado.uid
        };
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).set(metaData);
          return true;
        });
        
        // Atualizar localmente
        metas[sku] = {
          ...metaAtual,
          valor: valor,
          minimo: minimoExistente,
          medio: medioExistente,
          maximo: maximoExistente,
          comissaoPercentual: comissaoPercentualExistente,
          comissaoFixa: comissaoFixaExistente,
          atualizadoEm: new Date()
        };

        registrarMetaNormalizada(sku, metas[sku]);
        
        // Registrar no histórico
        await registrarHistorico(sku, 'adicionar', null, valor);
        
        renderizarMetas();
        
        skuInput.value = '';
        valorInput.value = '';
        document.getElementById('custoProdutoInfo').textContent = '';
        
        mostrarSucesso(`Meta para o SKU ${sku} adicionada com sucesso!`);
        
        // Atualizar gráficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao adicionar meta: ${error.message}`);
        console.error("Erro ao adicionar meta:", error);
      } finally {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
      }
    }

    async function editarMeta(botao, sku) {
      const tr = botao.closest('tr');
      const span = tr.querySelector('.valorMeta');
      const input = tr.querySelector('.editInput');
      const icon = botao.querySelector('i');
      
      if (input.style.display === 'none') {
        // Iniciar edição
        input.style.display = 'inline-block';
        span.style.display = 'none';
        icon.className = 'fas fa-save';
        input.focus();
      } else {
        // Salvar edição
        const novoValor = parseFloat(input.value);
        
        if (isNaN(novoValor) || novoValor <= 0) {
          mostrarErro('Por favor, informe um valor válido para a meta (maior que zero).');
          input.focus();
          return;
        }
        
        try {
          icon.className = 'fas fa-spinner fa-spin';
          
          const metaAnterior = obterMetaSku(sku);
          const valorAnterior = metaAnterior?.valor ?? null;
          const safeSku = sku.replaceAll('/', '__');
          const metaAtual = metaAnterior || {};
          const minimoExistente = numeroValido(metaAtual.minimo) ? metaAtual.minimo : null;
          const medioExistente = numeroValido(metaAtual.medio) ? metaAtual.medio : null;
          const maximoExistente = numeroValido(metaAtual.maximo) ? metaAtual.maximo : null;
          const comissaoPercentualExistente = numeroValido(metaAtual.comissaoPercentual)
            ? metaAtual.comissaoPercentual
            : null;
          const comissaoFixaExistente = numeroValido(metaAtual.comissaoFixa)
            ? metaAtual.comissaoFixa
            : null;

          const metaData = {
            valor: novoValor,
            minimo: minimoExistente,
            medio: medioExistente,
            maximo: maximoExistente,
            comissaoPercentual: comissaoPercentualExistente,
            comissaoFixa: comissaoFixaExistente,
            atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
            uid: usuarioLogado.uid
          };
          
          await executarComRetry(async () => {
            await db.collection("metasSKU").doc(safeSku).set(metaData);
            return true;
          });
          
          // Atualizar localmente
          metas[sku] = {
            ...metaAtual,
            valor: novoValor,
            minimo: minimoExistente,
            medio: medioExistente,
            maximo: maximoExistente,
            comissaoPercentual: comissaoPercentualExistente,
            comissaoFixa: comissaoFixaExistente,
            atualizadoEm: new Date()
          };

          registrarMetaNormalizada(sku, metas[sku]);
          
          // Registrar no histórico
          await registrarHistorico(sku, 'editar', valorAnterior, novoValor);
          
          renderizarMetas();
          mostrarSucesso(`Meta para o SKU ${sku} atualizada com sucesso!`);
          
          // Atualizar gráficos se estiver na aba
          if (document.getElementById('graficos').classList.contains('active')) {
            atualizarGraficos();
          }
        } catch (error) {
          mostrarErro(`Erro ao editar meta: ${error.message}`);
          console.error("Erro ao editar meta:", error);
          // Reverter visualmente
          input.value = obterMetaSku(sku)?.valor ?? '';
        } finally {
          input.style.display = 'none';
          span.style.display = 'inline-block';
          icon.className = 'fas fa-edit';
        }
      }
    }

    async function excluirMeta(sku, botao) {
      if (!confirm(`Tem certeza que deseja excluir a meta do SKU ${sku}?`)) {
        return;
      }
      
      try {
        const icon = botao.querySelector('i');
        icon.className = 'fas fa-spinner fa-spin';
        
        const metaAnterior = obterMetaSku(sku);
        const valorAnterior = metaAnterior?.valor ?? null;
        const safeSku = sku.replaceAll('/', '__');
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).delete();
          return true;
        });
        
        // Remover localmente
        delete metas[sku];
        removerMetaNormalizada(sku);
        
        // Registrar no histórico
        await registrarHistorico(sku, 'remover', valorAnterior, null);
        
        renderizarMetas();
        mostrarSucesso(`Meta para o SKU ${sku} removida com sucesso!`);
        
        // Atualizar gráficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao excluir meta: ${error.message}`);
        console.error("Erro ao excluir meta:", error);
      }
    }

    // =============================================
    // FUNÇÕES DE PROCESSAMENTO DE PEDIDOS
    // =============================================
    
    function normalizarNumeroMeta(valor, fallback = null) {
      if (valor === undefined || valor === null) return fallback;
      if (typeof valor === 'number') {
        return Number.isFinite(valor) ? valor : fallback;
      }
      const textoBruto = valor.toString().trim();
      if (!textoBruto) return fallback;
      let texto = textoBruto.replace(/\s+/g, '');
      const temVirgula = texto.includes(',');
      const temPonto = texto.includes('.');
      if (temVirgula && temPonto) {
        texto = texto.replace(/\./g, '').replace(/,/g, '.');
      } else if (temVirgula) {
        texto = texto.replace(/,/g, '.');
      }
      const numero = Number.parseFloat(texto);
      return Number.isFinite(numero) ? numero : fallback;
    }

    function numeroValido(valor) {
      return typeof valor === 'number' && Number.isFinite(valor);
    }

    function formatarMoedaBR(valor) {
      const numero = Number(valor);
      if (!Number.isFinite(numero)) return 'R$ 0,00';
      return `R$ ${numero.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
    }

    function normalizarQuantidadePedido(valor) {
      if (valor === undefined || valor === null) return 1;
      if (typeof valor === 'number') {
        return Number.isFinite(valor) && valor > 0 ? valor : 1;
      }
      const texto = String(valor).trim();
      if (!texto) return 1;
      const numerico = texto
        .replace(/\s+/g, '')
        .replace(/x/gi, '')
        .replace(/[a-zA-Z]+/g, '')
        .replace(/\./g, '')
        .replace(/,/g, '.');
      const numero = Number.parseFloat(numerico);
      if (!Number.isFinite(numero) || numero <= 0) return 1;
      return numero;
    }

    function ajustarMetaPorQuantidade(metaInfo, quantidade) {
      if (!metaInfo) return null;
      const escala = Number.isFinite(quantidade) ? quantidade : 1;
      if (escala === 1) return metaInfo;
      const ajustada = { ...metaInfo };
      const camposParaMultiplicar = ['valor', 'minimo', 'medio', 'maximo', 'comissaoFixa'];
      camposParaMultiplicar.forEach(campo => {
        if (numeroValido(metaInfo[campo]) || metaInfo[campo] === 0) {
          ajustada[campo] = metaInfo[campo] * escala;
        }
      });
      if (metaInfo.comissoes && typeof metaInfo.comissoes === 'object') {
        ajustada.comissoes = Object.fromEntries(
          Object.entries(metaInfo.comissoes).map(([nivel, valor]) => {
            if (numeroValido(valor) || valor === 0) {
              return [nivel, valor * escala];
            }
            return [nivel, valor];
          })
        );
      }
      return ajustada;
    }

    function classificarSobraPorFaixa(metaInfo, sobra) {
      const resultadoPadrao = {
        label: 'Sem meta',
        detalhe: 'Cadastre uma meta para este SKU',
        situacao: 'sem-meta',
        diferenca: 0,
        comissao: null,
        comissaoTexto: '',
        comissaoDescricao: '',
        valorApresentacao: null,
        excedenteMaximo: 0,
        excedenteAcimaLimite: 0,
        excedenteTexto: '',
        classeFaixa: ''
      };

      if (!metaInfo) {
        return resultadoPadrao;
      }

      const minimo = numeroValido(metaInfo.minimo) ? metaInfo.minimo : null;
      const maximo = numeroValido(metaInfo.maximo) ? metaInfo.maximo : null;
      const medio = numeroValido(metaInfo.medio) ? metaInfo.medio : null;
      const comissoesPorFaixa = metaInfo.comissoes || {};

      const comissaoPercentualPadrao = (numeroValido(metaInfo.comissaoPercentual) || metaInfo.comissaoPercentual === 0)
        ? metaInfo.comissaoPercentual
        : null;
      const comissaoFixaPadrao = (numeroValido(metaInfo.comissaoFixa) || metaInfo.comissaoFixa === 0)
        ? metaInfo.comissaoFixa
        : null;

      const faixaConfigurada =
        numeroValido(minimo) || numeroValido(medio) || numeroValido(maximo);

      const selecionarComissaoNivel = (nivel) => {
        if (!nivel) return null;
        const valor = comissoesPorFaixa?.[nivel];
        if (numeroValido(valor) || valor === 0) return valor;
        return null;
      };

      const nomeNivelMap = {
        minimo: 'mínima',
        medio: 'média',
        maximo: 'máxima'
      };

      const calcularComissao = (nivel) => {
        if (comissaoFixaPadrao !== null) {
          const descricao = 'Comissão fixa configurada';
          return {
            valor: comissaoFixaPadrao,
            descricao,
            texto: `${descricao}: ${formatarMoedaBR(comissaoFixaPadrao)}`
          };
        }

        let percentual = nivel ? selecionarComissaoNivel(nivel) : null;
        if (percentual === null) {
          percentual = comissaoPercentualPadrao;
        }

        if (percentual === null) {
          const descricao = nivel
            ? `Sem comissão ${nomeNivelMap[nivel]} configurada`
            : 'Sem comissão configurada';
          return { valor: null, descricao, texto: descricao };
        }

        const percentualDecimal = percentual > 1 ? percentual / 100 : percentual;
        const percentualDisplay = percentual > 1 ? percentual : percentual * 100;
        const valor = sobra * percentualDecimal;
        const nivelNome = nivel ? nomeNivelMap[nivel] : 'padrão';
        const descricao = `Comissão ${nivelNome} (${percentualDisplay.toFixed(2)}%)`;
        return {
          valor,
          descricao,
          texto: `${descricao}: ${formatarMoedaBR(valor)}`
        };
      };

      if (!faixaConfigurada) {
        return {
          label: 'Sem faixa configurada',
          detalhe: 'Configure mínimo, médio ou máximo para este SKU',
          situacao: 'sem-faixa',
          diferenca: 0,
          comissao: null,
          comissaoTexto: '',
          comissaoDescricao: 'Sem faixa configurada',
          valorApresentacao: null,
          excedenteMaximo: 0,
          excedenteAcimaLimite: 0,
          excedenteTexto: '',
          classeFaixa: ''
        };
      }

      const referencias = [];
      if (minimo !== null) referencias.push({ nivel: 'minimo', valor: minimo, titulo: 'mínima' });
      if (medio !== null) referencias.push({ nivel: 'medio', valor: medio, titulo: 'média' });
      if (maximo !== null) referencias.push({ nivel: 'maximo', valor: maximo, titulo: 'máxima' });

      const referenciaMaisProxima = referencias.reduce((melhor, atual) => {
        if (!melhor) return atual;
        const diffAtual = Math.abs(sobra - atual.valor);
        const diffMelhor = Math.abs(sobra - melhor.valor);
        if (diffAtual < diffMelhor) return atual;
        if (diffAtual === diffMelhor) {
          const prioridade = { minimo: 1, medio: 2, maximo: 3 };
          return (prioridade[atual.nivel] || 99) < (prioridade[melhor.nivel] || 99) ? atual : melhor;
        }
        return melhor;
      }, null);

      if (!referenciaMaisProxima) {
        return resultadoPadrao;
      }

      const comissaoInfo = calcularComissao(referenciaMaisProxima.nivel);
      const diferencaAbsoluta = Math.abs(sobra - referenciaMaisProxima.valor);
      const situacao = sobra > referenciaMaisProxima.valor ? 'acima' : (sobra < referenciaMaisProxima.valor ? 'abaixo' : 'dentro');
      const excedenteMaximo = referenciaMaisProxima.nivel === 'maximo' && numeroValido(maximo)
        ? Math.max(0, sobra - maximo)
        : 0;
      const limiteTresPorCento = numeroValido(maximo) ? maximo * 1.03 : null;
      const excedenteAcimaLimite = limiteTresPorCento ? Math.max(0, sobra - limiteTresPorCento) : 0;
      const classePorNivel = {
        minimo: 'referencia-minima',
        medio: 'referencia-media',
        maximo: 'referencia-maxima'
      };

      return {
        label: `Referência ${referenciaMaisProxima.titulo} mais próxima`,
        detalhe: `Usando ${formatarMoedaBR(referenciaMaisProxima.valor)} (diferença de ${formatarMoedaBR(diferencaAbsoluta)})`,
        situacao,
        diferenca: diferencaAbsoluta,
        comissao: comissaoInfo.valor,
        comissaoTexto: comissaoInfo.texto,
        comissaoDescricao: comissaoInfo.descricao,
        valorApresentacao: comissaoInfo.valor,
        excedenteMaximo,
        excedenteAcimaLimite,
        excedenteTexto: excedenteAcimaLimite > 0
          ? `Excedeu o limite de 3% em ${formatarMoedaBR(excedenteAcimaLimite)}`
          : '',
        classeFaixa: classePorNivel[referenciaMaisProxima.nivel] || ''
      };
    }

    function extrairCampoPlanilha(row, headerMap, opcoes) {
      for (const chave of opcoes) {
        const normalizada = normalizeHeaderKey(chave);
        if (headerMap[normalizada] !== undefined) {
          return row[headerMap[normalizada]];
        }
      }
      return undefined;
    }

    function lerPlanilhaBasica(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            resolve(XLSX.utils.sheet_to_json(sheet));
          } catch (error) {
            reject(error);
          }
        };
        reader.onerror = () => reject(new Error('Não foi possível ler o arquivo.'));
        reader.readAsArrayBuffer(file);
      });
    }

    async function processarPlanilha() {
      const fileInput = document.getElementById('inputExcel');
      const file = fileInput.files[0];
      const feedback = document.getElementById('feedbackImportacao');
      feedback.innerHTML = '';

      if (!file) {
        feedback.innerHTML = '<span class="badge badge-warning">⚠️ Selecione um arquivo</span>';
        return;
      }

      try {
        const metasSincronizadas = await carregarMetas({
          atualizarDatalist: false,
          renderizarInterface: false,
          mostrarLoading: false
        });

        const semMetasDisponiveis = Object.keys(metas).length === 0;
        if (metasSincronizadas === false) {
          feedback.innerHTML = '<span class="badge badge-danger">⚠️ Não foi possível carregar as metas dos produtos.</span>';
          return;
        }

        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            const pedidos = XLSX.utils.sheet_to_json(sheet);

            processarPedidos(pedidos);
            if (semMetasDisponiveis) {
              feedback.innerHTML = '<span class="badge badge-warning">⚠️ Planilha importada, mas nenhum custo cadastrado foi encontrado para cruzamento.</span>';
            } else {
              feedback.innerHTML = '<span class="badge badge-success">✔️ Importado com sucesso</span>';
            }
          } catch (error) {
            feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
            console.error("Erro ao ler arquivo:", error);
          } finally {
            toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
          }
        };

        reader.onerror = function() {
          feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
          toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
        };

        reader.readAsArrayBuffer(file);
      } catch (error) {
        feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
        console.error("Erro ao processar arquivo:", error);
        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
      }
    }

    function processarPedidos(pedidos) {
      const contagem = {};
      pedidos.forEach(p => {
        const id = String(p['ID do pedido'] ?? '').trim();
        if (id) contagem[id] = (contagem[id] || 0) + 1;
      });

      const tbody = document.querySelector('#resultado tbody');
      tbody.innerHTML = '';
      let totalSobra = 0, totalPercentual = 0, totalPedidos = 0, totalComissao = 0;
      let esperadoTotal = 0;
      let quantidadeTotal = 0;

      pedidosProcessados = [];

      pedidos.forEach(p => {
        const id = String(p['ID do pedido'] ?? '').trim();
        if (!id || contagem[id] > 1) return;

        const sku = String(p['Número de referência SKU'] ?? '').trim();
        const status = String(p['Status do pedido'] ?? '').toLowerCase();
        if (!sku || status.includes('cancelado') || status.includes('não pago')) return;

        const comprador = String(p['Nome de usuário (comprador)'] ?? '').trim();
        const quantidade = normalizarQuantidadePedido(p['Quantidade']);

        const subtotal = parseFloat(p['Subtotal do produto']) || 0;
        const reembolso = parseFloat(p['Reembolso Shopee']) || 0;
        const cupom = parseFloat(p['Cupom do vendedor']) || 0;
        const comissao = parseFloat(p['Taxa de comissão']) || 0;
        const servico = parseFloat(p['Taxa de serviço']) || 0;
        const sobra = subtotal + reembolso - cupom - comissao - servico;
        const metaInfoOriginal = obterMetaSku(sku);
        const metaInfo = ajustarMetaPorQuantidade(metaInfoOriginal, quantidade) || metaInfoOriginal;
        const metaValor = numeroValido(metaInfo?.valor) ? metaInfo.valor : (numeroValido(metaInfoOriginal?.valor) ? metaInfoOriginal.valor * quantidade : 0);
        const meta = metaValor || 0;
        const percentual = meta ? ((sobra - meta) / meta) * 100 : 0;
        const metaMinimo = numeroValido(metaInfo?.minimo)
          ? metaInfo.minimo
          : (numeroValido(metaInfoOriginal?.minimo) ? metaInfoOriginal.minimo * quantidade : null);
        const metaMedio = numeroValido(metaInfo?.medio)
          ? metaInfo.medio
          : (numeroValido(metaInfoOriginal?.medio) ? metaInfoOriginal.medio * quantidade : null);
        const metaMaximo = numeroValido(metaInfo?.maximo)
          ? metaInfo.maximo
          : (numeroValido(metaInfoOriginal?.maximo) ? metaInfoOriginal.maximo * quantidade : null);
        const prazo = p['Prazo de coleta'] || p['Prazo de Coleta'] || '';
        const faixaInfo = classificarSobraPorFaixa(metaInfo, sobra);
        const valorComissaoDesvio = numeroValido(faixaInfo.valorApresentacao)
          ? faixaInfo.valorApresentacao
          : null;

        let faixaClasse = faixaInfo?.classeFaixa || '';
        if (!faixaClasse && metaInfo) {
          const minimoMeta = numeroValido(metaInfo.minimo) ? metaInfo.minimo : null;
          const medioMeta = numeroValido(metaInfo.medio) ? metaInfo.medio : null;
          const maximoMeta = numeroValido(metaInfo.maximo) ? metaInfo.maximo : null;

          if (minimoMeta !== null && sobra < minimoMeta) {
            faixaClasse = 'faixa-abaixo-minimo';
          } else if (maximoMeta !== null && sobra > maximoMeta) {
            faixaClasse = 'faixa-acima-maximo';
          } else if (medioMeta !== null && sobra < medioMeta) {
            faixaClasse = 'faixa-entre-minimo-medio';
          } else if (
            medioMeta !== null &&
            maximoMeta !== null &&
            sobra >= medioMeta &&
            sobra <= maximoMeta
          ) {
            faixaClasse = 'faixa-entre-medio-maximo';
          } else if (
            medioMeta === null &&
            maximoMeta !== null &&
            sobra <= maximoMeta &&
            (minimoMeta === null || sobra >= minimoMeta)
          ) {
            faixaClasse = 'faixa-entre-medio-maximo';
          }
        }

        const pedidoData = {
          id,
          sku,
          subtotal,
          reembolso,
          cupom,
          comissao,
          servico,
          sobra,
          meta,
          percentual,
          status,
          prazo,
          faixa: faixaInfo.label,
          detalheFaixa: faixaInfo.detalhe,
          situacaoFaixa: faixaInfo.situacao,
          diferencaFaixa: faixaInfo.diferenca,
          comissaoFaixa: faixaInfo.comissao,
          comissaoTexto: faixaInfo.comissaoTexto,
          comissaoDescricao: faixaInfo.comissaoDescricao,
          comissaoValorDisplay: valorComissaoDesvio,
          excedenteMaximo: faixaInfo.excedenteMaximo,
          excedenteAcimaLimite: faixaInfo.excedenteAcimaLimite,
          excedenteTexto: faixaInfo.excedenteTexto,
          comprador,
          quantidade,
          custoMinimo: metaMinimo,
          custoMedio: metaMedio,
          custoMaximo: metaMaximo,
          sobraEsperadaPercentual: null
        };

        pedidoData.sobraEsperadaPercentual = obterSobraEsperadaPorPercentual(pedidoData);

        pedidosProcessados.push(pedidoData);

        const tr = document.createElement('tr');
        
        // Determinar status e ícones
        let statusText = '';
        let statusIcon = '';
        let rowClass = '';

        if (meta) {
          if (percentual <= -10) {
            statusText = 'Crítico';
            statusIcon = '❌';
            rowClass = 'status-critico';
          } else if (percentual <= -5) {
            statusText = 'Atenção';
            statusIcon = '⚠️';
          } else if (percentual >= 5) {
            statusText = 'Bom';
            statusIcon = '✔️';
            rowClass = 'status-correto';
          } else {
            statusText = 'Normal';
            statusIcon = '✔️';
          }
        } else {
          statusText = 'Sem meta';
          statusIcon = '⚠️';
        }

        const classificacaoHTML = `
          <strong>${faixaInfo.label}</strong>
          ${faixaInfo.detalhe ? `<br><small>${faixaInfo.detalhe}</small>` : ''}
        `;

        let comissaoColumn = '';
        if (valorComissaoDesvio !== null && valorComissaoDesvio !== undefined) {
          const sinal = valorComissaoDesvio < 0 ? '-' : '';
          const valorFormatado = Math.abs(valorComissaoDesvio).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
          comissaoColumn = `<strong>${sinal}R$ ${valorFormatado}</strong>`;
        }
        if (faixaInfo.comissaoTexto) {
          comissaoColumn += `${comissaoColumn ? '<br>' : ''}<small>${faixaInfo.comissaoTexto}</small>`;
        }
        if (!comissaoColumn) {
          comissaoColumn = '<span class="text-muted">-</span>';
        }

        let excedenteColumn = '<span class="text-muted">-</span>';
        if (faixaInfo.excedenteAcimaLimite > 0) {
          const excedenteFormatado = faixaInfo.excedenteAcimaLimite.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
          excedenteColumn = `<span class="text-danger">R$ ${excedenteFormatado}</span>`;
          if (faixaInfo.excedenteTexto) {
            excedenteColumn += `<br><small>${faixaInfo.excedenteTexto}</small>`;
          }
        }

        tr.className = [rowClass, faixaClasse].filter(Boolean).join(' ');
        const quantidadeFormatada = Number.isFinite(quantidade)
          ? quantidade.toLocaleString('pt-BR', {
              minimumFractionDigits: Number.isInteger(quantidade) ? 0 : 2,
              maximumFractionDigits: 2
            })
          : '-';
        tr.innerHTML = `
          <td>${id}</td>
          <td>${sku}</td>
          <td>${comprador || '-'}</td>
          <td class="text-right">${quantidadeFormatada}</td>
          <td>R$ ${subtotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${reembolso.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${cupom.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${comissao.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${servico.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td><strong>R$ ${sobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</strong><br><small>Meta: R$ ${meta.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</small></td>
          <td>${classificacaoHTML}</td>
          <td>${comissaoColumn}</td>
          <td>${excedenteColumn}</td>
          <td>${percentual.toFixed(2)}%</td>
          <td class="status-only" data-status="${statusText}">${statusIcon} ${statusText}</td>
        `;

        tbody.appendChild(tr);

        totalSobra += sobra;
        totalPercentual += percentual;
        totalPedidos++;
        if (valorComissaoDesvio !== null && valorComissaoDesvio !== undefined) {
          totalComissao += valorComissaoDesvio;
        }
        esperadoTotal += meta;
        quantidadeTotal += quantidade;
      });

      const media = totalPedidos ? (totalPercentual / totalPedidos).toFixed(2) : '0.00';
      const diferencaTotal = totalSobra - esperadoTotal;
      const diferencaPercentual = esperadoTotal ? (diferencaTotal / esperadoTotal) * 100 : 0;

      let diferencaHTML = '';
      if (esperadoTotal > 0) {
        const diferencaClass = diferencaTotal >= 0 ? 'success' : 'danger';
        diferencaHTML = `
          <div style="margin-top: 1rem; padding: 1rem; background: rgba(6, 214, 160, 0.05); border-radius: 12px; border-left: 4px solid var(--${diferencaClass});">
            <h4>
              <span class="badge badge-${diferencaClass}">
                Diferença Total: R$ ${Math.abs(diferencaTotal).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} 
                (${diferencaPercentual.toFixed(2)}%)
                ${diferencaTotal >= 0 ? 'acima' : 'abaixo'} da meta
              </span>
            </h4>
          </div>
        `;
      }

      document.getElementById('totalSobra').innerHTML = `
        <div class="card">
          <div class="card-header">
            <i class="fas fa-coins"></i>
            <h3>Resumo Financeiro</h3>
          </div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
            <div style="background: rgba(99, 102, 241, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--primary);">
              <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Sobra Total</h4>
              <h2>R$ ${totalSobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>

            <div style="background: rgba(249, 115, 22, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid #f97316;">
              <h4 style="color: #f97316; margin-bottom: 0.5rem;">Comissão Total</h4>
              <h2>R$ ${totalComissao.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>

            <div style="background: rgba(6, 214, 160, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--success);">
              <h4 style="color: var(--success); margin-bottom: 0.5rem;">Sobra Esperada</h4>
              <h2>R$ ${esperadoTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>

            <div style="background: rgba(108, 117, 125, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--secondary);">
              <h4 style="color: var(--secondary); margin-bottom: 0.5rem;">Média de Desempenho</h4>
              <h2>${media}%</h2>
            </div>
          </div>
          ${diferencaHTML}
        </div>
      `;
        document.getElementById('totalSobra').innerHTML += `
        <div style="margin-top: 1.5rem;">
           
        </div>
    `;
    
    // Salvar dados para análise posterior
    window.dadosParaAnalise = {
        pedidos: pedidosProcessados,
        resumo: {
            totalSobra,
            esperadoTotal,
            media,
            totalComissao,
            quantidadeTotal
        }
    };
      const sobras = pedidosProcessados.map(p => ({
        sku: p.sku,
        vendido: p.subtotal,
        sobra: p.sobra,
        meta: p.meta,
        quantidade: p.quantidade,
        faixa: p.faixa,
        detalheFaixa: p.detalheFaixa,
        comissaoFaixa: p.comissaoFaixa,
        comissaoValorDisplay: p.comissaoValorDisplay,
        comissaoTexto: p.comissaoTexto,
        excedenteAcimaLimite: p.excedenteAcimaLimite,
        data: new Date().toLocaleDateString()
      }));

      document.getElementById("dadosSobrasIA").value = sobras
        .map(s => {
          const comissaoTexto = typeof s.comissaoValorDisplay === 'number'
            ? `, Comissão/Desvio: R$ ${s.comissaoValorDisplay.toFixed(2)}`
            : (s.comissaoTexto ? `, Comissão/Desvio: ${s.comissaoTexto}` : '');
          const excedenteTexto = s.excedenteAcimaLimite > 0
            ? `, Excedente >3%: R$ ${s.excedenteAcimaLimite.toFixed(2)}`
            : '';
          const detalheFaixa = s.detalheFaixa ? `, Detalhe: ${s.detalheFaixa}` : '';
          const quantidadeTexto = Number.isFinite(s.quantidade)
            ? Number(s.quantidade).toLocaleString('pt-BR', {
                minimumFractionDigits: Number.isInteger(s.quantidade) ? 0 : 2,
                maximumFractionDigits: 2
              })
            : '0';
          return `SKU: ${s.sku}, Quantidade: ${quantidadeTexto}, Vendido: R$ ${s.vendido.toFixed(2)}, Sobra: R$ ${s.sobra.toFixed(2)}, Meta: R$ ${s.meta?.toFixed(2) || 0}, Faixa: ${s.faixa || 'Não definida'}${detalheFaixa}${comissaoTexto}${excedenteTexto}, Data: ${s.data}`;
        })
        .join("\n");
        renderizarTabelaLogistica();
}

      // Atualizar gráficos se estiver na aba
      if (document.getElementById('graficos').classList.contains('active')) {
        atualizarGraficos();
      }


      async function processarConferenciaComissao() {
        const input = document.getElementById('inputConferenciaComissao');
        const feedback = document.getElementById('feedbackConferenciaComissao');
        const tbody = document.querySelector('#resultadoConferenciaComissao tbody');
        const resumo = document.getElementById('resumoConferenciaComissao');
        const cardResultado = document.getElementById('conferenciaComissaoResultados');
        const botao = document.getElementById('btnProcessarConferencia');

        if (!input || !feedback || !tbody || !resumo || !cardResultado || !botao) return;

        feedback.innerHTML = '';
        resumo.innerHTML = '';
        tbody.innerHTML = '';
        cardResultado.style.display = 'none';
        resultadosConferenciaComissao = [];

        const file = input.files?.[0];
        if (!file) {
          feedback.innerHTML = '<span class="badge badge-warning">⚠️ Selecione um arquivo</span>';
          return;
        }

        try {
          toggleLoading(botao, '<i class="fas fa-upload"></i> Processar Comissão');

          const metasSincronizadas = await carregarMetas({
            atualizarDatalist: false,
            renderizarInterface: false,
            mostrarLoading: false
          });

          if (metasSincronizadas === false) {
            feedback.innerHTML = '<span class="badge badge-danger">⚠️ Não foi possível carregar as metas dos produtos.</span>';
            return;
          }

          const linhas = await lerPlanilhaBasica(file);
          if (!linhas.length) {
            feedback.innerHTML = '<span class="badge badge-warning">⚠️ Arquivo sem dados para processar.</span>';
            return;
          }

          const headerMap = buildHeaderMap(linhas[0]);
          let totalItens = 0;
          let semMeta = 0;
          let totalComissao = 0;
          let faixasIdentificadas = 0;

          linhas.forEach((row) => {
            const sku = String(extrairCampoPlanilha(row, headerMap, ['sku', 'número de referência sku', 'sku produto']) || '').trim();
            if (!sku) return;

            const sobraValor = parseNumber(extrairCampoPlanilha(row, headerMap, ['sobra']));
            const numeroVenda = extrairCampoPlanilha(row, headerMap, ['nº da venda', 'numero da venda', 'pedido', 'id', 'id do pedido']) || '';
            const dataVenda = extrairCampoPlanilha(row, headerMap, ['data', 'data da venda']) || '';

            const metaInfo = obterMetaSku(sku);
            const faixaInfo = classificarSobraPorFaixa(metaInfo, sobraValor);
            const metaValor = numeroValido(metaInfo?.valor) ? metaInfo.valor : null;
            const comissaoValor = numeroValido(faixaInfo.valorApresentacao) ? faixaInfo.valorApresentacao : null;

            const comissaoHtml = comissaoValor !== null
              ? `<strong>R$ ${Math.abs(comissaoValor).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</strong>${faixaInfo.comissaoTexto ? `<br><small>${faixaInfo.comissaoTexto}</small>` : ''}`
              : (faixaInfo.comissaoTexto ? `<small>${faixaInfo.comissaoTexto}</small>` : '<span class="text-muted">-</span>');

            const metaTexto = metaValor !== null ? `Meta: ${formatarMoedaBR(metaValor)}` : 'Sem meta';
            const situacao = metaInfo
              ? (faixaInfo.situacao === 'sem-meta' ? 'Sem meta configurada' : 'Comissão encontrada')
              : 'SKU não cadastrado';

            if (metaInfo) {
              faixasIdentificadas += faixaInfo.situacao === 'sem-meta' ? 0 : 1;
            } else {
              semMeta += 1;
            }

            if (comissaoValor !== null) {
              totalComissao += comissaoValor;
            }

            const tr = document.createElement('tr');
            const referenciaTipo = identificarTipoReferenciaFaixa(faixaInfo.label);
            const referenciaConfig = obterConfiguracaoReferenciaFaixa(faixaInfo.label, referenciaTipo);
            tr.innerHTML = `
              <td>${dataVenda || '-'}</td>
              <td>${numeroVenda || '-'}</td>
              <td>${sku}</td>
              <td><strong>${formatarMoedaBR(sobraValor)}</strong></td>
              <td>${metaInfo ? `<strong>${metaTexto}</strong>` : '<span class="text-muted">SKU não cadastrado</span>'}</td>
              <td><strong>${faixaInfo.label}</strong>${faixaInfo.detalhe ? `<br><small>${faixaInfo.detalhe}</small>` : ''}</td>
              <td>${comissaoHtml}</td>
              <td>${situacao}</td>
            `;
            if (referenciaConfig?.cssClass) {
              tr.classList.add(referenciaConfig.cssClass);
            }
            tbody.appendChild(tr);
            resultadosConferenciaComissao.push({
              data: dataVenda || '-',
              numeroVenda: numeroVenda || '-',
              sku,
              sobra: Number.isFinite(sobraValor) ? Number(sobraValor) : null,
              meta: metaValor,
              faixa: faixaInfo.label,
              comissaoCalculada: comissaoValor,
              referenciaTipo,
              situacao
            });
            totalItens += 1;
          });

          if (totalItens === 0) {
            feedback.innerHTML = '<span class="badge badge-warning">⚠️ Nenhuma linha válida encontrada.</span>';
            return;
          }

          cardResultado.style.display = '';
          window.resultadosConferenciaComissao = resultadosConferenciaComissao;
          resumo.innerHTML = `
            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
              <span class="badge badge-primary">Itens avaliados: ${totalItens}</span>
              <span class="badge badge-success">Faixas com comissão: ${faixasIdentificadas}</span>
              <span class="badge badge-warning">SKUs sem cadastro/meta: ${semMeta}</span>
              <span class="badge badge-secondary">Comissão total: ${formatarMoedaBR(totalComissao)}</span>
            </div>
          `;
          feedback.innerHTML = '<span class="badge badge-success">✔️ Comissão conferida com sucesso</span>';
        } catch (error) {
          console.error('Erro ao processar conferência de comissão:', error);
          feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
        } finally {
          toggleLoading(botao, '<i class="fas fa-upload"></i> Processar Comissão');
        }
      }


    function colorirLinhasConferenciaExcel(worksheet) {
      if (!worksheet || !worksheet['!ref'] || !Array.isArray(resultadosConferenciaComissao)) return;
      const range = XLSX.utils.decode_range(worksheet['!ref']);
      for (let row = range.s.r + 1; row <= range.e.r; row++) {
        const resultado = resultadosConferenciaComissao[row - range.s.r - 1];
        if (!resultado) continue;
        const config = obterConfiguracaoReferenciaFaixa(resultado.faixa, resultado.referenciaTipo);
        if (!config?.excelColor) continue;
        for (let col = range.s.c; col <= range.e.c; col++) {
          const cellAddress = XLSX.utils.encode_cell({ c: col, r: row });
          const cell = worksheet[cellAddress];
          if (!cell) continue;
          cell.s = cell.s || {};
          cell.s.fill = {
            patternType: 'solid',
            fgColor: { rgb: config.excelColor },
            bgColor: { rgb: config.excelColor }
          };
        }
      }
    }

    function exportarConferenciaComissaoExcel() {
      if (!resultadosConferenciaComissao || resultadosConferenciaComissao.length === 0) {
        mostrarErro('Nenhum resultado da conferência para exportar.');
        return;
      }

      const linhas = resultadosConferenciaComissao.map((item) => ({
        'Data': item.data || '-',
        'Nº da Venda': item.numeroVenda || '-',
        'SKU': item.sku,
        'Sobra (R$)': Number.isFinite(item.sobra) ? Number(item.sobra.toFixed(2)) : '',
        'Meta (R$)': Number.isFinite(item.meta) ? Number(item.meta.toFixed(2)) : '',
        'Faixa de Comissão': item.faixa || '',
        'Comissão Calculada (R$)': Number.isFinite(item.comissaoCalculada)
          ? Number(item.comissaoCalculada.toFixed(2))
          : (item.comissaoCalculada || ''),
        'Situação': item.situacao || ''
      }));

      const worksheet = XLSX.utils.json_to_sheet(linhas);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Conferência');
      colorirLinhasConferenciaExcel(worksheet);
      XLSX.writeFile(workbook, `conferencia_comissao_${new Date().toISOString().slice(0,10)}.xlsx`, { cellStyles: true });

      if (typeof mostrarSucesso === 'function') {
        mostrarSucesso('Resultado da conferência exportado em Excel.');
      }
    }

    function exportarConferenciaComissaoPDF() {
      if (!resultadosConferenciaComissao || resultadosConferenciaComissao.length === 0) {
        mostrarErro('Nenhum resultado da conferência para exportar.');
        return;
      }

      if (!window.jspdf || typeof window.jspdf.jsPDF !== 'function') {
        mostrarErro('Biblioteca jsPDF não carregada para exportação em PDF.');
        return;
      }

      const doc = new window.jspdf.jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
      doc.setFontSize(14);
      doc.text('Resultado da Conferência de Comissão', 14, 15);

      const corpo = resultadosConferenciaComissao.map((item) => [
        item.data || '-',
        item.numeroVenda || '-',
        item.sku,
        Number.isFinite(item.sobra) ? formatarMoedaBR(item.sobra) : '-',
        Number.isFinite(item.meta) ? formatarMoedaBR(item.meta) : 'Sem meta',
        item.faixa || '-',
        Number.isFinite(item.comissaoCalculada)
          ? formatarMoedaBR(item.comissaoCalculada)
          : (item.comissaoCalculada || '-'),
        item.situacao || '-'
      ]);

      if (typeof doc.autoTable !== 'function') {
        mostrarErro('Recurso de tabela do PDF indisponível.');
        return;
      }

      doc.autoTable({
        head: [['Data', 'Nº da Venda', 'SKU', 'Sobra', 'Meta', 'Faixa de Comissão', 'Comissão Calculada', 'Situação']],
        body: corpo,
        startY: 22,
        styles: { fontSize: 9 },
        headStyles: { fillColor: [52, 58, 64] },
        willDrawCell: (data) => {
          if (data.section !== 'body') return;

          const resultado = resultadosConferenciaComissao[data.row.index];
          const config = obterConfiguracaoReferenciaFaixa(resultado?.faixa, resultado?.referenciaTipo);
          const cor = config?.pdfColor;
          if (!cor) return;

          if (data.row && data.row.cells) {
            Object.values(data.row.cells).forEach((cell) => {
              cell.styles.fillColor = cor;
              cell.styles.textColor = [0, 0, 0];
            });
          }

          if (data.row && data.row.styles) {
            data.row.styles.fillColor = cor;
            data.row.styles.textColor = [0, 0, 0];
          }
        }
      });

      doc.save(`conferencia_comissao_${new Date().toISOString().slice(0,10)}.pdf`);
    }


    function limparFiltros() {
      document.getElementById("filtroSKU").value = "";
      document.getElementById("filtroStatus").value = "";
      document.getElementById("tipoFiltro").value = "exata";
      filtrarPorSKU();
    }
// =============================================
    // CONTROLE LOGÍSTICO DE PEDIDOS
    // =============================================

    let logistica = {};

    function carregarLogistica() {
      try {
        const armazenado = localStorage.getItem('controleLogistica');
        if (armazenado) {
          const parsed = JSON.parse(armazenado);
          if (parsed && typeof parsed === 'object') {
            logistica = parsed;
          }
        }
      } catch (error) {
        console.warn('Não foi possível carregar o controle logístico salvo:', error);
        logistica = {};
      }
    }

    carregarLogistica();

    function salvarLogistica() {
      localStorage.setItem('controleLogistica', JSON.stringify(logistica));
    }

    function renderizarTabelaLogistica() {
      const tbody = document.querySelector('#tabelaLogistica tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const hoje = new Date();

      pedidosProcessados.forEach(p => {
        if (!logistica[p.id]) {
          logistica[p.id] = {
            status: 'pendente',
            rastreio: '',
            checklist: { itens: false, etiqueta: false, lacre: false },
            prazo: p.prazo || '',
            dataPostagem: null
          };
        }
        const item = logistica[p.id];
        const prazoData = item.prazo ? new Date(item.prazo) : null;
        const prazoProximo = prazoData && (prazoData - hoje) / (1000 * 60 * 60 * 24) <= 1 && item.status !== 'postado';
        const statusLinha = prazoProximo ? 'prazo' : item.status;
        const postadoPrazo = item.status === 'postado' && item.dataPostagem && prazoData ? new Date(item.dataPostagem) <= prazoData : null;

        const tr = document.createElement('tr');
        tr.dataset.status = statusLinha;

        const progresso = (item.status === 'postado' ? 1 : 0) + (item.checklist.itens ? 1 : 0) + (item.checklist.etiqueta ? 1 : 0) + (item.checklist.lacre ? 1 : 0);
        const progressoPercent = (progresso / 4) * 100;
        const corProgresso = progressoPercent === 100 ? 'var(--success)' : (progressoPercent >= 50 ? '#f59e0b' : 'var(--error)');

        tr.innerHTML = `
          <td>${p.id}</td>
          <td class="${statusLinha !== 'postado' ? 'text-red-600 font-bold' : ''}">
            <select onchange="atualizarStatusLogistica('${p.id}', this.value)" class="form-control">
              <option value="pendente"${item.status === 'pendente' ? ' selected' : ''}>Pendente</option>
              <option value="postado"${item.status === 'postado' ? ' selected' : ''}>Postado</option>
            </select>
          </td>
          <td><input type="text" class="form-control" value="${item.rastreio}" onchange="atualizarRastreio('${p.id}', this.value)" placeholder="Código" /></td>
          <td>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','itens', this.checked)" ${item.checklist.itens ? 'checked' : ''}/> Itens</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','etiqueta', this.checked)" ${item.checklist.etiqueta ? 'checked' : ''}/> Etiqueta</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','lacre', this.checked)" ${item.checklist.lacre ? 'checked' : ''}/> Lacre</label>
          </td>
          <td><div class="progress"><div class="progress-bar" style="width:${progressoPercent}%; background:${corProgresso};"></div></div></td>
          <td>${postadoPrazo === null ? '-' : postadoPrazo ? 'Sim' : 'Não'}</td>
        `;
        tbody.appendChild(tr);
      });

      salvarLogistica();
      verificarAlertasLogistica();
      aplicarFiltroLogistica();
    }

    function atualizarStatusLogistica(id, status) {
      if (!logistica[id]) return;
      logistica[id].status = status;
      if (status === 'postado') {
        logistica[id].dataPostagem = new Date().toISOString().split('T')[0];
      }
      salvarLogistica();
      renderizarTabelaLogistica();
    }

    function atualizarRastreio(id, codigo) {
      if (!logistica[id]) return;
      logistica[id].rastreio = codigo;
      salvarLogistica();
    }

    function atualizarChecklist(id, campo, valor) {
      if (!logistica[id]) return;
      logistica[id].checklist[campo] = valor;
      salvarLogistica();
    }

    function aplicarFiltroLogistica() {
      const filtro = document.getElementById('filtroStatusLogistica')?.value;
      document.querySelectorAll('#tabelaLogistica tbody tr').forEach(tr => {
        tr.style.display = !filtro || tr.dataset.status === filtro ? '' : 'none';
      });
    }

    function verificarAlertasLogistica() {
      const valores = Object.values(logistica);
      const pendentes = valores.filter(v => v.status !== 'postado').length;
      const prazoProximo = valores.filter(v => {
        if (!v.prazo || v.status === 'postado') return false;
        const diff = (new Date(v.prazo) - new Date()) / (1000 * 60 * 60 * 24);
        return diff <= 1;
      }).length;

      const mensagens = [];
      if (pendentes) mensagens.push(`${pendentes} pedidos pendentes de envio`);
      if (prazoProximo) mensagens.push(`${prazoProximo} com prazo de coleta próximo`);
      const alertaEl = document.getElementById('alertasLogistica');
      if (alertaEl) alertaEl.textContent = mensagens.join(' | ');
    }
    // =============================================
    // FUNÇÕES DE GRÁFICOS
    // =============================================
    
    function atualizarGraficos() {
        // Elemento do cabeçalho
        const chartHeader = document.querySelector('.chart-header');
        
        // Limpa o conteúdo anterior
        chartHeader.innerHTML = '<div class="chart-title">Comparação entre Sobra Real e Meta por SKU</div>';
        
        // Verificação de dados
        if (pedidosProcessados.length === 0) {
            document.querySelectorAll('.chart-container').forEach(container => {
                container.innerHTML = '<p style="text-align: center; color: var(--gray); padding: 2rem;">Nenhum dado disponível para exibir gráficos. Processe um arquivo primeiro.</p>';
            });
            
            // Adiciona botão mesmo sem dados (opcional)
            chartHeader.innerHTML += `
                <button onclick="analisarTendenciasIA()" class="btn btn-outline" disabled>
                    <i class="fas fa-chart-line"></i> Analisar Tendências com IA
                </button>
            `;
            return;
        }
        
        // Adiciona botão funcional quando há dados
        chartHeader.innerHTML += `
            <button onclick="analisarTendenciasIA()" class="btn btn-outline">
                <i class="fas fa-chart-line"></i> Analisar Tendências com IA
            </button>
        `;
        
        // Processamento dos dados
        const tipoFiltro = document.getElementById('filtroGrafico').value;
        let dados = agruparPorSKU(pedidosProcessados);
        
        // Aplicar filtro
        if (tipoFiltro === 'top10') {
            dados.sort((a, b) => b.diferencaPercentual - a.diferencaPercentual);
            dados = dados.slice(0, 10);
        } else if (tipoFiltro === 'bottom10') {
            dados.sort((a, b) => a.diferencaPercentual - b.diferencaPercentual);
            dados = dados.slice(0, 10);
        }
        
        // Criar gráficos
        criarGraficoBarras(dados);
        criarGraficoPizza(dados);
    }

    function agruparPorSKU(pedidos) {
      const agrupados = {};
      
      pedidos.forEach(pedido => {
        if (!agrupados[pedido.sku]) {
          agrupados[pedido.sku] = {
            sku: pedido.sku,
            totalSobra: 0,
            totalMeta: 0,
            quantidade: 0
          };
        }
        
        agrupados[pedido.sku].totalSobra += pedido.sobra;
        agrupados[pedido.sku].totalMeta += pedido.meta || 0;
        agrupados[pedido.sku].quantidade += 1;
      });
      
      // Converter para array e calcular diferenças
      return Object.values(agrupados).map(item => {
        const diferenca = item.totalSobra - item.totalMeta;
        const diferencaPercentual = item.totalMeta ? (diferenca / item.totalMeta) * 100 : 0;
        
        return {
          ...item,
          diferenca,
          diferencaPercentual
        };
      });
    } // ← Fechamento correto da função
    async function analisarTendenciasIA() {
        try {
            const prompt = `Analise estes dados de desempenho de produtos:
    ${JSON.stringify(pedidosProcessados.slice(0, 50), null, 2)}

    Identifique:
    1. Tendências sazonais
    2. Produtos com crescimento/declínio consistente
    3. Sugestões de ajuste de estoque
    4. Previsão para próxima semana

    Responda em tópicos curtos e diretos.`;

            const resposta = await consultarDeepSeek(prompt);
            
            // Exibir resultado
            document.querySelector('.chart-header').innerHTML += `
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <i class="fas fa-lightbulb"></i>
                        <h3>Análise de Tendências</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <pre style="white-space: pre-wrap;">${resposta}</pre>
                    </div>
                </div>
            `;
        } catch (error) {
            mostrarErro(`Erro na análise de tendências: ${error.message}`);
        }
    }
    function criarGraficoBarras(dados) {
      const ctx = document.getElementById('graficoBarras').getContext('2d');
      
      // Destruir gráfico anterior se existir
      if (graficoBarras) {
        graficoBarras.destroy();
      }
      
      // Preparar dados
      const labels = dados.map(item => item.sku);
      const sobras = dados.map(item => item.totalSobra);
      const metas = dados.map(item => item.totalMeta);
      
      graficoBarras = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Sobra Real (R$)',
              data: sobras,
              backgroundColor: 'rgba(249, 115, 22, 0.7)',
              borderColor: 'rgba(249, 115, 22, 1)',
              borderWidth: 1
            },
            {
              label: 'Meta Esperada (R$)',
              data: metas,
              backgroundColor: 'rgba(34, 197, 94, 0.7)',
              borderColor: 'rgba(34, 197, 94, 1)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Valor (R$)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'SKU'
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: 'Comparação entre Sobra Real e Meta por SKU'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  label += 'R$ ' + context.raw.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
                  return label;
                }
              }
            }
          }
        }
      });
    }

    function criarGraficoPizza(dados) {
      const ctx = document.getElementById('graficoPizza').getContext('2d');
      
      // Destruir gráfico anterior se existir
      if (graficoPizza) {
        graficoPizza.destroy();
      }
      
      // Preparar dados - vamos mostrar a diferença percentual
      const labels = dados.map(item => item.sku);
      const diferencas = dados.map(item => item.diferencaPercentual);
      
      // Criar cores baseadas no desempenho
      const backgroundColors = diferencas.map(val => {
        if (val >= 5) return 'rgba(76, 175, 80, 0.7)'; // Verde - acima
        if (val <= -5) return 'rgba(244, 67, 54, 0.7)'; // Vermelho - abaixo
        return 'rgba(255, 193, 7, 0.7)'; // Amarelo - dentro do esperado
      });
      
      graficoPizza = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: diferencas,
            backgroundColor: backgroundColors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Desempenho vs Meta por SKU (%)'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.raw || 0;
                  return `${label}: ${value.toFixed(2)}%`;
                }
              }
            }
          }
        }
      });
    }
    window.importarVendasML = async function () {
      const input = document.getElementById('inputVendasML');
      const file = input?.files?.[0];
      if (!file) return mostrarErro('Selecione um arquivo do Mercado Livre para importar.');

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Faturamento Mercado Livre',
        html: `
          <input type="date" id="swal-data-ml" class="swal2-input" />
          <input type="text" id="swal-loja-ml" class="swal2-input" placeholder="Nome da Loja" />
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const data = document.getElementById('swal-data-ml').value;
          const lojaNome = document.getElementById('swal-loja-ml').value.trim();
          if (!data || !/^\d{4}-\d{2}-\d{2}$/.test(data) || lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma data e uma loja válidas.');
          }
          return { data, loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;

      const dataReferencia = form.data;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { range: 5, defval: '' });
          if (!rows.length) {
            mostrarErro('Nenhum dado encontrado na planilha do Mercado Livre.');
            const progressContainer = document.getElementById('progressContainerML');
            if (progressContainer) progressContainer.classList.add('hidden');
            return;
          }

          const resultadoProcessamento = await processarPlanilhaVendas({
            rows,
            dataReferencia,
            loja,
            plataforma: 'Mercado Livre',
            resultadoId: 'resultadoVendasML',
            progressIds: {
              containerId: 'progressContainerML',
              barId: 'progressBarVendasML',
              textId: 'progressTextVendasML'
            },
            rowParser: (row, contexto) => extrairLinhaMercadoLivre(row, contexto),
            datasInformadas: [dataReferencia]
          });

          if (resultadoProcessamento) {
            input.value = '';
          }
        } catch (err) {
          console.error('Erro ao importar planilha Mercado Livre', err);
          mostrarErro('Erro ao importar planilha do Mercado Livre: ' + err.message);
        }
      };
      reader.readAsArrayBuffer(file);
    };

    window.importarVendasTiny = async function () {
      const input = document.getElementById('inputVendasTiny');
      const file = input?.files?.[0];
      if (!file) return mostrarErro('Selecione um arquivo do Tiny para importar.');

    let diasSelecionadosTiny = [];
    const { value: form, isConfirmed } = await Swal.fire({
      title: 'Pedidos Tiny',
      html: `
        <div class="swal2-field" style="text-align: left">
          <label class="swal2-label" style="margin-bottom: 0.5rem; display: block">Período da planilha</label>
          <div class="swal2-radio-group" style="display: flex; gap: 1rem; flex-wrap: wrap">
            <label class="swal2-radio" style="display: flex; align-items: center; gap: 0.35rem">
              <input type="radio" name="swal-periodo-tiny" value="unico" checked />
              <span>Um único dia</span>
            </label>
            <label class="swal2-radio" style="display: flex; align-items: center; gap: 0.35rem">
              <input type="radio" name="swal-periodo-tiny" value="multiplos" />
              <span>Vários dias</span>
            </label>
          </div>
        </div>
        <div id="swal-dia-unico-container" style="width: 100%;">
          <input type="date" id="swal-data-tiny" class="swal2-input" />
        </div>
        <div id="swal-multiplos-container" class="swal2-field" style="display: none; text-align: left; gap: 0.75rem; width: 100%;">
          <label class="swal2-label" style="margin-bottom: 0.5rem; display: block">Selecione os dias da planilha</label>
          <div class="swal2-field" style="display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
              <input type="date" id="swal-dia-unico-tiny" class="swal2-input" style="width: auto; min-width: 12rem;" />
              <button type="button" id="swal-add-dia-tiny" class="swal2-styled" style="margin: 0; padding: 0.5rem 1rem;">Adicionar dia</button>
            </div>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center;">
              <input type="date" id="swal-intervalo-inicio-tiny" class="swal2-input" style="width: auto; min-width: 10rem;" placeholder="Início" />
              <span style="font-size: 0.85rem; color: #4b5563;">até</span>
              <input type="date" id="swal-intervalo-fim-tiny" class="swal2-input" style="width: auto; min-width: 10rem;" placeholder="Fim" />
              <button type="button" id="swal-add-intervalo-tiny" class="swal2-styled" style="margin: 0; padding: 0.5rem 1rem;">Adicionar intervalo</button>
            </div>
          </div>
          <div id="swal-lista-dias-tiny" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.75rem;"></div>
          <div id="swal-dias-erro" class="swal2-validation-message" style="display: none;"></div>
        </div>
        <input type="text" id="swal-loja-tiny" class="swal2-input" placeholder="Nome da Loja" />
      `,
      focusConfirm: false,
      showCancelButton: true,
      confirmButtonText: 'Continuar',
      didOpen: () => {
        const popup = Swal.getPopup();
        const dataInput = popup.querySelector('#swal-data-tiny');
        const containerUnico = popup.querySelector('#swal-dia-unico-container');
        const containerMultiplos = popup.querySelector('#swal-multiplos-container');
        const inputDiaUnico = popup.querySelector('#swal-dia-unico-tiny');
        const inputIntervaloInicio = popup.querySelector('#swal-intervalo-inicio-tiny');
        const inputIntervaloFim = popup.querySelector('#swal-intervalo-fim-tiny');
        const botaoAdicionarDia = popup.querySelector('#swal-add-dia-tiny');
        const botaoAdicionarIntervalo = popup.querySelector('#swal-add-intervalo-tiny');
        const listaDias = popup.querySelector('#swal-lista-dias-tiny');
        const erroDias = popup.querySelector('#swal-dias-erro');

        const formatarDataBr = (iso) => {
          if (!iso || typeof iso !== 'string') return iso || '';
          const partes = iso.split('-');
          if (partes.length !== 3) return iso;
          return `${partes[2]}/${partes[1]}/${partes[0]}`;
        };

        const exibirErroDias = (mensagem) => {
          if (!erroDias) return;
          if (mensagem) {
            erroDias.style.display = 'block';
            erroDias.textContent = mensagem;
          } else {
            erroDias.style.display = 'none';
            erroDias.textContent = '';
          }
        };

        const atualizarListaDias = () => {
          if (!listaDias) return;
          if (!diasSelecionadosTiny.length) {
            listaDias.innerHTML = '<span style="font-size: 0.85rem; color: #6b7280;">Nenhum dia selecionado ainda.</span>';
            return;
          }
          const itens = diasSelecionadosTiny
            .slice()
            .sort()
            .map(
              dia => `
                <span data-dia="${dia}" style="display: inline-flex; align-items: center; gap: 0.35rem; padding: 0.35rem 0.75rem; border-radius: 9999px; background: #e5e7eb; color: #1f2937; font-size: 0.85rem;">
                  ${formatarDataBr(dia)}
                  <button type="button" data-remover-dia="${dia}" style="border: none; background: transparent; cursor: pointer; color: #ef4444; font-weight: 700;">&times;</button>
                </span>
              `
            )
            .join('');
          listaDias.innerHTML = itens;
        };

        const adicionarDia = (valor) => {
          exibirErroDias('');
          const normalizado = normalizeDate(valor);
          if (!normalizado) {
            exibirErroDias('Informe um dia válido.');
            return;
          }
          if (!diasSelecionadosTiny.includes(normalizado)) {
            diasSelecionadosTiny.push(normalizado);
            atualizarListaDias();
          }
        };

        const adicionarIntervalo = (inicio, fim) => {
          exibirErroDias('');
          const inicioNormalizado = normalizeDate(inicio);
          const fimNormalizado = normalizeDate(fim);
          if (!inicioNormalizado || !fimNormalizado) {
            exibirErroDias('Informe datas de início e fim válidas.');
            return;
          }
          if (inicioNormalizado > fimNormalizado) {
            exibirErroDias('A data inicial não pode ser posterior à final.');
            return;
          }
          const inicioDate = new Date(`${inicioNormalizado}T00:00:00`);
          const fimDate = new Date(`${fimNormalizado}T00:00:00`);
          for (let cursor = new Date(inicioDate); cursor <= fimDate; cursor.setDate(cursor.getDate() + 1)) {
            const iso = cursor.toISOString().split('T')[0];
            if (!diasSelecionadosTiny.includes(iso)) {
              diasSelecionadosTiny.push(iso);
            }
          }
          atualizarListaDias();
        };

        const toggleCampos = () => {
          const selecionado = popup.querySelector('input[name="swal-periodo-tiny"]:checked')?.value;
          if (selecionado === 'multiplos') {
            containerUnico.style.display = 'none';
            containerMultiplos.style.display = 'flex';
            atualizarListaDias();
          } else {
            containerUnico.style.display = 'block';
            containerMultiplos.style.display = 'none';
          }
        };

        popup
          .querySelectorAll('input[name="swal-periodo-tiny"]')
          .forEach(radio => radio.addEventListener('change', toggleCampos));

        if (botaoAdicionarDia) {
          botaoAdicionarDia.addEventListener('click', () => {
            adicionarDia(inputDiaUnico?.value);
            if (inputDiaUnico) inputDiaUnico.value = '';
          });
        }

        if (botaoAdicionarIntervalo) {
          botaoAdicionarIntervalo.addEventListener('click', () => {
            adicionarIntervalo(inputIntervaloInicio?.value, inputIntervaloFim?.value);
            if (inputIntervaloInicio) inputIntervaloInicio.value = '';
            if (inputIntervaloFim) inputIntervaloFim.value = '';
          });
        }

        if (listaDias) {
          listaDias.addEventListener('click', (event) => {
            const alvo = event.target;
            if (!alvo || typeof alvo.getAttribute !== 'function') return;
            const diaRemover = alvo.getAttribute('data-remover-dia');
            if (!diaRemover) return;
            diasSelecionadosTiny = diasSelecionadosTiny.filter(dia => dia !== diaRemover);
            atualizarListaDias();
          });
        }

        toggleCampos();
      },
      preConfirm: () => {
        const popup = Swal.getPopup();
        const tipoPeriodo = popup.querySelector('input[name="swal-periodo-tiny"]:checked')?.value || 'unico';
        const dataSelecionada = popup.querySelector('#swal-data-tiny').value;
        const lojaNome = popup.querySelector('#swal-loja-tiny').value.trim();
        if (lojaNome.length < 2) {
          Swal.showValidationMessage('Informe uma loja válida.');
          return false;
        }

        let datasPlanilha = [];
        let dataReferencia = '';
        if (tipoPeriodo === 'multiplos') {
          const diasNormalizados = parseDiasInformados(diasSelecionadosTiny);
          if (!diasNormalizados.length) {
            Swal.showValidationMessage('Adicione ao menos um dia válido da planilha.');
            return false;
          }
          datasPlanilha = diasNormalizados.sort();
          dataReferencia = datasPlanilha[0];
        } else {
          if (!dataSelecionada || !/^\d{4}-\d{2}-\d{2}$/.test(dataSelecionada)) {
            Swal.showValidationMessage('Informe uma data válida.');
            return false;
          }
          dataReferencia = dataSelecionada;
          datasPlanilha = [dataSelecionada];
        }

        return { dataReferencia, loja: lojaNome, datasPlanilha, tipoPeriodo };
      }
    });
    if (!isConfirmed || !form) return;

    const dataReferencia = form.dataReferencia;
    const loja = form.loja;
    const datasPlanilha = Array.isArray(form.datasPlanilha) ? form.datasPlanilha : [dataReferencia];

    const reader = new FileReader();
    reader.onload = async function (e) {
      try {
        const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
          if (!rows.length) {
            mostrarErro('Nenhum dado encontrado na planilha do Tiny.');
            const progressContainer = document.getElementById('progressContainerTiny');
            if (progressContainer) progressContainer.classList.add('hidden');
            return;
          }

          const resultadoProcessamento = await processarPlanilhaVendas({
            rows,
            dataReferencia,
            loja,
            plataforma: 'Tiny',
            resultadoId: 'resultadoVendasTiny',
            progressIds: {
              containerId: 'progressContainerTiny',
              barId: 'progressBarVendasTiny',
              textId: 'progressTextVendasTiny'
            },
            rowParser: (row, contexto) => extrairLinhaTiny(row, contexto),
            datasInformadas: datasPlanilha
          });

          if (resultadoProcessamento) {
            input.value = '';
          }
        } catch (err) {
          console.error('Erro ao importar planilha Tiny', err);
          mostrarErro('Erro ao importar planilha do Tiny: ' + err.message);
        }
      };
      reader.readAsArrayBuffer(file);
    };

    window.importarFaturamento = async function () {
      const input = document.getElementById("inputFaturamento");
      const file = input.files[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

    const { value: form, isConfirmed } = await Swal.fire({
      title: 'Informações de Faturamento',
      html: `
        <input type="date" id="swal-data" class="swal2-input" />
        <input type="text" id="swal-loja" class="swal2-input" placeholder="Nome da Loja" />
        <textarea id="swal-dias-planilha" class="swal2-textarea" placeholder="Quais dias constam na planilha importada? (ex: 2024-05-01, 2024-05-02)"></textarea>
      `,
      focusConfirm: false,
      showCancelButton: true,
      confirmButtonText: 'Continuar',
      preConfirm: () => {
        const popup = Swal.getPopup();
        const data = popup.querySelector('#swal-data').value;
        const lojaNome = popup.querySelector('#swal-loja').value.trim();
        const diasTexto = popup.querySelector('#swal-dias-planilha').value;
        if (lojaNome.length < 2) {
          Swal.showValidationMessage('Informe uma loja válida.');
          return false;
        }
        if (data && !/^\d{4}-\d{2}-\d{2}$/.test(data)) {
          Swal.showValidationMessage('Informe a data no formato AAAA-MM-DD.');
          return false;
        }

        let datasPlanilha = parseDiasInformados(diasTexto);
        let dataReferencia = data;

        if (!dataReferencia && datasPlanilha.length) {
          dataReferencia = [...datasPlanilha].sort()[0];
        }

        if (!dataReferencia) {
          Swal.showValidationMessage('Informe ao menos uma data ou os dias presentes na planilha.');
          return false;
        }

        if (!datasPlanilha.length) {
          datasPlanilha = [dataReferencia];
        }

        return { dataReferencia, loja: lojaNome, datasPlanilha };
      }
    });
    if (!isConfirmed || !form) return;
    const dataReferencia = form.dataReferencia;
    const loja = form.loja;
    const datasPlanilha = Array.isArray(form.datasPlanilha) ? form.datasPlanilha : [dataReferencia];

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const ref = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .collection('lojas')
            .doc(loja);
          const doc = await ref.get();

          let operacao = "salvar";
          if (doc.exists) {
            const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
              title: 'Registro existente',
              text: 'Já existe um registro para esta loja e data. O que deseja fazer?',
              showDenyButton: true,
              showCancelButton: true,
              confirmButtonText: 'Substituir',
              denyButtonText: 'Somar',
              cancelButtonText: 'Cancelar'
            });
            if (!substituir && !somar) return;
            operacao = somar ? "somar" : "substituir";
          }

            let bruto = 0, taxas = 0, qtdVendas = 0;
            const skusVendidos = {};
            const pedidosErrados = [];

            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('faturamentoProgressBar');
            const progressText = document.getElementById('faturamentoProgressText');
            if (progressContainer && progressBar && progressText) {
              progressContainer.classList.remove('hidden');
              progressBar.style.width = '0%';
              progressText.textContent = '0%';
            }
            const totalRows = rows.length;
            let processedRows = 0;
            const updateProgress = async () => {
              if (progressBar && progressText) {
                const pct = Math.round((processedRows / totalRows) * 100);
                progressBar.style.width = pct + '%';
                progressText.textContent = pct + '%';
                if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
              }
            };

            for (const row of rows) {
            const status = (row['Status do pedido'] || '').toLowerCase();
            if (status.includes('cancelado') || status.includes('não pago')) {
              processedRows++;
              await updateProgress();
              continue;
            }

            const subtotal = parseFloat(row['Subtotal do produto']) || 0;
            const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
            const cupom = parseFloat(row['Cupom do vendedor']) || 0;
            const comissao = parseFloat(row['Taxa de comissão']) || 0;
            const servico = parseFloat(row['Taxa de serviço']) || 0;

            const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

            bruto += subtotal + reembolso;
            taxas += cupom + comissao + servico;
            qtdVendas++;

              const headers = Object.keys(row);
              const headerSKU = headers.find(h => h.trim() === 'Número de referência SKU'); // pega o nome exato
              const skuValor = headerSKU ? row[headerSKU] : null;
              const sku = String(skuValor ?? '').trim();
              if (!sku) {
                processedRows++;
                await updateProgress();
                continue;
              }

              if (!skusVendidos[sku]) skusVendidos[sku] = { total: 0, valorLiquido: 0 };
              skusVendidos[sku].total++;
              skusVendidos[sku].valorLiquido += liquidoLinha;

              const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
              const pedidoId = headerPedido ? row[headerPedido] : null;
              const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
              const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
              const metaUnit = obterMetaSku(sku)?.valor || 0;
              const metaEsperada = metaUnit * (quantidade || 1);
              const sobraReal = liquidoLinha;

              if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                pedidosErrados.push({
                  dia: dataReferencia,
                  loja: loja,
                  pedido: pedidoId,
                  sku: sku,
                  quantidade: quantidade,
                  subtotal: subtotal,
                  sobraReal: sobraReal,
                  totalLiquido: sobraReal,
                  sobraEsperada: metaEsperada,
                  uid: usuarioLogado.uid,
                  critico: true
                });
              }

              processedRows++;
              await updateProgress();
            }
            if (progressBar && progressText) {
              progressBar.style.width = '100%';
              progressText.textContent = '100%';
            }
            if (pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = bruto - taxas;

          if (operacao === "somar" && doc.exists) {
            const anterior = doc.data();
            bruto += anterior.valorBruto || 0;
            taxas += anterior.taxasPlataforma || 0;
            qtdVendas += anterior.qtdVendas || 0;
          }

          // Salvar SKUs vendidos
 const refSku = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('skusVendidos')
            .doc(dataReferencia);
          await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true }); // garante doc pai e marca usuário
          if (baseResp) {
            await baseResp
              .collection('skusVendidos')
              .doc(dataReferencia)
              .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          for (const [sku, dadosSku] of Object.entries(skusVendidos)) {
            const skuId = makeSkuDocId(sku);
            const legacySkuId = makeLegacySkuDocId(sku);
            const listaCollection = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia)
              .collection('lista');
            const docRef = listaCollection.doc(skuId);
            const docSnap = await docRef.get();

            let totalFinal = dadosSku.total;
            let valorLiquidoFinal = dadosSku.valorLiquido;
            if (docSnap.exists) {
              const dadosAnteriores = docSnap.data();
              totalFinal += dadosAnteriores.total || 0;
              valorLiquidoFinal += dadosAnteriores.valorLiquido || 0;
            } else if (legacySkuId !== skuId) {
              const legacyDocRef = listaCollection.doc(legacySkuId);
              const legacySnap = await legacyDocRef.get();
              if (legacySnap.exists) {
                const dadosAnteriores = legacySnap.data();
                totalFinal += dadosAnteriores.total || 0;
                valorLiquidoFinal += dadosAnteriores.valorLiquido || 0;
                try {
                  await legacyDocRef.delete();
                } catch (err) {
                  console.warn('Não foi possível remover SKU legado', legacySkuId, err);
                }
              }
            }

            await docRef.set({
              sku: sku,
              total: totalFinal,
              valorLiquido: valorLiquidoFinal,
              data: dataReferencia,
              loja: loja,
              uid: usuarioLogado.uid
            });

            if (legacySkuId !== skuId) {
              listaCollection.doc(legacySkuId).delete().catch(() => {});
            }

            if (baseResp && respEmail) {
              const skuPayload = {
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              };
              const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
              const baseRespLista = baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista');
              await baseRespLista
                .doc(skuId)
                .set({ encrypted: encSku, uid: usuarioLogado.uid });
              if (legacySkuId !== skuId) {
                baseRespLista.doc(legacySkuId).delete().catch(() => {});
              }
            }
          }
          
          const pass = getPassphrase() || usuarioLogado.uid;

          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          for (const row of rows) {
            const statusPedido = row['Status do pedido'] || '';
            const headersPedido = Object.keys(row);
            const headerSku = headersPedido.find(h => h.trim() === 'Número de referência SKU');
            const skuPedido = headerSku ? row[headerSku] : null;
           const headerPedidoId = headersPedido.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
           const pedidoId = headerPedidoId ? row[headerPedidoId] : null;
           const headerPagamento = headersPedido.find(h => h.toLowerCase().includes('hora do pagamento'));
           const horaPagamento = headerPagamento ? row[headerPagamento] : null;
           const headerPrevEnvio = headersPedido.find(h => h.toLowerCase().includes('data prevista') && h.toLowerCase().includes('envio'));
           let dataPrevistaEnvio = headerPrevEnvio ? row[headerPrevEnvio] : null;
           dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);
           const headerRastreamento = headersPedido.find(h => h.toLowerCase().includes('rastreamento'));
           const numeroRastreamento = headerRastreamento ? String(row[headerRastreamento]).trim() : '';
            const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
            const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
            const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
            const comissaoPedido = parseFloat(row['Taxa de comissão']) || 0;
            const servicoPedido = parseFloat(row['Taxa de serviço']) || 0;
            const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
            const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;
            if (!pedidoId) continue;
            const pedidoPayload = {
              pedidoId,
              status: statusPedido,
              sku: skuPedido,
              loja,
              data: dataReferencia,
              horaPagamento,
              subtotal: subtotalPedido,
              taxas: taxasPedido,
              liquido: liquidoPedido,
              reembolso: reembolsoPedido
            };
            if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
            if (numeroRastreamento) {
              pedidoPayload.numeroRastreamento = numeroRastreamento;
              pedidoPayload.etiquetaImpressa = true;
            }

            const pedidoDocRef = pedidosRef
              .doc(dataReferencia)
              .collection('lista')
              .doc(pedidoId);
            const pedidoDoc = await pedidoDocRef.get();
            let needsUpdate = true;
            if (pedidoDoc.exists) {
              try {
                const atual = JSON.parse(
                  await decryptString(pedidoDoc.data().encrypted, pass)
                );
                if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                  needsUpdate = false;
                }
              } catch (e) {
                console.error('Erro ao comparar pedido existente', e);
              }
            }
            if (needsUpdate) {
              const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
              await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
              if (baseResp && respEmail) {
                const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                await baseResp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
              }
              if (baseExp && gestorEmail) {
                const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                await baseExp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
              }
            }
          }

          const lojaPayload = {
            valorBruto: bruto,
            taxasPlataforma: taxas,
            valorLiquido: liquido,
            qtdVendas: qtdVendas,
            loja: loja,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid,
            diasInformados: datasPlanilha
         };
          const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
          await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
          if (baseResp && respEmail) {
            const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja)
              .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
          }

          const resumoPayload = {
            valorBruto: bruto,
            valorLiquido: liquido,
            taxasPlataforma: taxas,
            vendas: qtdVendas,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid,
            diasInformados: datasPlanilha
        };
          const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
await db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
          if (baseResp && respEmail) {
            const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
          }
          const diasInformadosFormatados = datasPlanilha
            .map(dia => {
              if (typeof dia !== 'string') return '';
              const partes = dia.split('-');
              if (partes.length === 3) {
                return `${partes[2]}/${partes[1]}/${partes[0]}`;
              }
              return dia;
            })
            .filter(Boolean)
            .join(', ');
          document.getElementById("resultadoFaturamento").innerHTML = `
            <div class="alert alert-success">
              <i class="fas fa-check-circle"></i>
              Faturamento de <strong>${dataReferencia}</strong> da loja <strong>${loja}</strong> registrado com sucesso.<br>
              ${diasInformadosFormatados ? `<strong>Dias na planilha:</strong> ${diasInformadosFormatados}<br>` : ''}
              <strong>Bruto:</strong> R$ ${bruto.toFixed(2)}<br>
              <strong>Taxas:</strong> R$ ${taxas.toFixed(2)}<br>
              <strong>Líquido:</strong> R$ ${liquido.toFixed(2)}<br>
              <strong>Qtd. Vendas:</strong> ${qtdVendas}
            </div>
          `;
          await notificarResponsavelFinanceiro(dataReferencia, loja, bruto, liquido, qtdVendas);

        } catch (err) {
          mostrarErro("Erro ao importar: " + err.message);
          console.error(err);
        }
      };

      reader.readAsArrayBuffer(file);
    };

    window.importarFaturamentoMassa = async function () {
      const input = document.getElementById("inputFaturamentoMassa");
      const file = input?.files?.[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

    const { value: form, isConfirmed } = await Swal.fire({
      title: 'Importação em Massa',
      html: `
        <input type="text" id="swal-loja-massa" class="swal2-input" placeholder="Nome da Loja" />
        <div id="swal-dias-massa-container" class="swal2-field" style="display:flex; flex-direction:column; gap:0.75rem;">
          <label for="swal-dia-massa" style="font-size:0.85rem; text-align:left;">Selecione os dias presentes na planilha</label>
          <input
            type="text"
            id="swal-dia-massa"
            class="swal2-input"
            style="margin:0;"
            placeholder="Escolha um ou mais dias"
            readonly
          />
          <small style="text-align:left; font-size:0.75rem; color:#6b7280;">Clique nos dias desejados diretamente no calendário. Para remover uma data, clique nela novamente.</small>
        </div>
      `,
      focusConfirm: false,
      showCancelButton: true,
      confirmButtonText: 'Continuar',
      didOpen: () => {
        const popup = Swal.getPopup();
        const diasInput = popup.querySelector('#swal-dia-massa');
        const locale = (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.pt) || undefined;
        popup.flatpickrInstance = flatpickr(diasInput, {
          mode: 'multiple',
          dateFormat: 'Y-m-d',
          altInput: true,
          altFormat: 'd/m/Y',
          conjunction: ', ',
          locale,
          onChange: () => Swal.resetValidationMessage()
        });
        diasInput.addEventListener('keydown', event => event.preventDefault());
      },
      preConfirm: () => {
        const popup = Swal.getPopup();
        const lojaNome = popup.querySelector('#swal-loja-massa').value.trim();
        const flatpickrInstance = popup.flatpickrInstance;
        const diasSelecionados = flatpickrInstance
          ? flatpickrInstance.selectedDates.map(data => flatpickrInstance.formatDate(data, 'Y-m-d'))
          : [];
        if (lojaNome.length < 2) {
          Swal.showValidationMessage('Informe uma loja válida.');
          return false;
        }
        const diasPlanilha = parseDiasInformados(diasSelecionados);
        if (!diasPlanilha.length) {
          Swal.showValidationMessage('Selecione ao menos um dia no calendário.');
          return false;
        }
        return { loja: lojaNome, diasPlanilha };
      }
    });
    if (!isConfirmed || !form) return;
    const loja = form.loja;
    const diasPlanilhaInformados = Array.isArray(form.diasPlanilha) ? form.diasPlanilha : [];

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          if (!rows.length) {
            mostrarErro("A planilha está vazia.");
            return;
          }

          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const progressContainer = document.getElementById('progressContainer');
          const progressBar = document.getElementById('faturamentoProgressBar');
          const progressText = document.getElementById('faturamentoProgressText');
          const massaModal = document.getElementById('massaFaturamentoModal');
          const massaStatus = document.getElementById('massaFaturamentoStatus');
          const massaCloseBtn = document.getElementById('massaModalClose');
          const massaProgressBar = document.getElementById('massaProgressBar');
          const massaProgressText = document.getElementById('massaProgressText');

          const atualizarStatusModal = (mensagem, classe) => {
            if (!massaStatus) return;
            massaStatus.textContent = mensagem;
            massaStatus.classList.remove('text-blue-600', 'text-green-600', 'text-red-600');
            if (classe) massaStatus.classList.add(classe);
          };

          const progressTargets = [
            {
              bar: progressBar,
              text: progressText,
              onShow: () => {
                if (progressContainer) progressContainer.classList.remove('hidden');
              }
            },
            {
              bar: massaProgressBar,
              text: massaProgressText,
              onShow: () => {
                if (massaModal) massaModal.style.display = 'block';
                atualizarStatusModal('Processando planilha. Não feche esta janela até finalizar.', 'text-blue-600');
                if (massaCloseBtn) {
                  massaCloseBtn.classList.add('hidden');
                  massaCloseBtn.disabled = false;
                }
              }
            }
          ];

          progressTargets.forEach(({ bar, text, onShow }) => {
            if (typeof onShow === 'function') onShow();
            if (bar) bar.style.width = '0%';
            if (text) text.textContent = '0%';
          });

          const setProgress = (pct) => {
            progressTargets.forEach(({ bar, text }) => {
              if (bar) bar.style.width = pct + '%';
              if (text) text.textContent = pct + '%';
            });
          };

          const totalRows = rows.length;
          let processedRows = 0;
          const updateProgress = async () => {
            const pct = totalRows ? Math.round((processedRows / totalRows) * 100) : 0;
            setProgress(pct);
            if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
          };

          const grupos = {};
          const rowsSemData = [];
          const extrairDataPagamento = (valor) => {
            if (valor === undefined || valor === null) return null;
            const texto = String(valor).trim();
            if (!texto) return null;
            const match = texto.match(/(\d{4}-\d{2}-\d{2})/);
            return match ? match[1] : null;
          };

          for (const row of rows) {
            const headers = Object.keys(row);
            const dataPagamento = extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('hora do pagamento'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data do pedido'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data de criação'))
                .map(h => row[h])[0]
            );

            if (!dataPagamento) {
              rowsSemData.push(row);
              processedRows++;
              await updateProgress();
              continue;
            }

            if (!grupos[dataPagamento]) {
              grupos[dataPagamento] = {
                rows: [],
                bruto: 0,
                taxas: 0,
                qtdVendas: 0,
                skusVendidos: {},
                pedidosErrados: []
              };
            }

            const grupo = grupos[dataPagamento];
            grupo.rows.push({ row, headers });

            const status = (row['Status do pedido'] || '').toLowerCase();
            const ativo = !(status.includes('cancelado') || status.includes('não pago'));
            if (ativo) {
              const subtotal = parseFloat(row['Subtotal do produto']) || 0;
              const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
              const cupom = parseFloat(row['Cupom do vendedor']) || 0;
              const comissao = parseFloat(row['Taxa de comissão']) || 0;
              const servico = parseFloat(row['Taxa de serviço']) || 0;
              const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

              grupo.bruto += subtotal + reembolso;
              grupo.taxas += cupom + comissao + servico;
              grupo.qtdVendas++;

              const headerSku = headers.find(h => h.trim() === 'Número de referência SKU')
                || headers.find(h => h.trim() === 'Nº de referência do SKU principal');
              const skuValor = headerSku ? row[headerSku] : null;
              const sku = String(skuValor ?? '').trim();

              if (sku) {
                if (!grupo.skusVendidos[sku]) grupo.skusVendidos[sku] = { total: 0, valorLiquido: 0 };
                grupo.skusVendidos[sku].total++;
                grupo.skusVendidos[sku].valorLiquido += liquidoLinha;

                const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
                const pedidoId = headerPedido ? row[headerPedido] : null;
                const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
                const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
                const metaUnit = obterMetaSku(sku)?.valor || 0;
                const metaEsperada = metaUnit * (quantidade || 1);
                const sobraReal = liquidoLinha;

                if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                  grupo.pedidosErrados.push({
                    dia: dataPagamento,
                    loja: loja,
                    pedido: pedidoId,
                    sku: sku,
                    quantidade: quantidade,
                    subtotal: subtotal,
                    sobraReal: sobraReal,
                    totalLiquido: sobraReal,
                    sobraEsperada: metaEsperada,
                    uid: usuarioLogado.uid,
                    critico: true
                  });
                }
              }
            }

            processedRows++;
            await updateProgress();
          }

          if (!Object.keys(grupos).length) {
            mostrarErro('Nenhum registro com data de pagamento foi encontrado.');
            atualizarStatusModal('Nenhum registro com data de pagamento foi encontrado.', 'text-red-600');
            if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');
            return;
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          const pass = getPassphrase() || usuarioLogado.uid;
          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          const resultados = [];

          for (const [dataReferencia, grupo] of Object.entries(grupos)) {
            const ref = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja);
            const doc = await ref.get();
            let operacao = 'salvar';
            let dadosAnteriores = null;

            if (doc.exists) {
              const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
                title: 'Registro existente',
                text: `Já existe um registro para ${loja} em ${dataReferencia}. O que deseja fazer?`,
                showDenyButton: true,
                showCancelButton: true,
                confirmButtonText: 'Substituir',
                denyButtonText: 'Somar',
                cancelButtonText: 'Pular'
              });
              if (!substituir && !somar) {
                resultados.push({ data: dataReferencia, loja, status: 'ignorado' });
                continue;
              }
              operacao = somar ? 'somar' : 'substituir';
              const docData = doc.data();
              if (docData?.encrypted) {
                try {
                  dadosAnteriores = JSON.parse(await decryptString(docData.encrypted, pass));
                } catch (e) {
                  console.error('Erro ao descriptografar faturamento existente', e);
                }
              } else {
                dadosAnteriores = docData;
              }
            }

            if (operacao === 'somar' && dadosAnteriores) {
              grupo.bruto += dadosAnteriores.valorBruto || 0;
              grupo.taxas += dadosAnteriores.taxasPlataforma || 0;
              grupo.qtdVendas += dadosAnteriores.qtdVendas || 0;
            }

            if (grupo.pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(grupo.pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = grupo.bruto - grupo.taxas;

            const refSku = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia);
            await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp) {
              await baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            }

            for (const [sku, dadosSku] of Object.entries(grupo.skusVendidos)) {
              const skuId = makeSkuDocId(sku);
              const legacySkuId = makeLegacySkuDocId(sku);
              const listaCollection = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista');
              const docRef = listaCollection.doc(skuId);
              const docSnap = await docRef.get();

              let totalFinal = dadosSku.total;
              let valorLiquidoFinal = dadosSku.valorLiquido;
              if (docSnap.exists) {
                const dadosAnterioresSku = docSnap.data();
                totalFinal += dadosAnterioresSku.total || 0;
                valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
              } else if (legacySkuId !== skuId) {
                const legacyDocRef = listaCollection.doc(legacySkuId);
                const legacySnap = await legacyDocRef.get();
                if (legacySnap.exists) {
                  const dadosAnterioresSku = legacySnap.data();
                  totalFinal += dadosAnterioresSku.total || 0;
                  valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
                  try {
                    await legacyDocRef.delete();
                  } catch (err) {
                    console.warn('Não foi possível remover SKU legado', legacySkuId, err);
                  }
                }
              }

              await docRef.set({
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              });

              if (legacySkuId !== skuId) {
                listaCollection.doc(legacySkuId).delete().catch(() => {});
              }

              if (baseResp && respEmail) {
                const skuPayload = {
                  sku: sku,
                  total: totalFinal,
                  valorLiquido: valorLiquidoFinal,
                  data: dataReferencia,
                  loja: loja,
                  uid: usuarioLogado.uid
                };
                const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
                const baseRespLista = baseResp
                  .collection('skusVendidos')
                  .doc(dataReferencia)
                  .collection('lista');
                await baseRespLista
                  .doc(skuId)
                  .set({ encrypted: encSku, uid: usuarioLogado.uid });
                if (legacySkuId !== skuId) {
                  baseRespLista.doc(legacySkuId).delete().catch(() => {});
                }
              }
            }

            for (const { row, headers } of grupo.rows) {
              const headersLower = headers.map(h => h.toLowerCase());
              const headerPedidoId = headersLower.find((h) => h.includes('pedido') && h.includes('id'));
              const pedidoHeaderOriginal = headerPedidoId ? headers[headersLower.indexOf(headerPedidoId)] : null;
              const pedidoId = pedidoHeaderOriginal ? row[pedidoHeaderOriginal] : null;
              if (!pedidoId) continue;

              const headerPagamento = headersLower.find(h => h.includes('hora do pagamento'));
              const pagamentoOriginal = headerPagamento ? headers[headersLower.indexOf(headerPagamento)] : null;
              const horaPagamento = pagamentoOriginal ? row[pagamentoOriginal] : null;

              const headerCancelar = headersLower.find(h => h.includes('cancelar motivo'));
              const cancelarOriginal = headerCancelar ? headers[headersLower.indexOf(headerCancelar)] : null;
              const cancelarMotivoBruto = cancelarOriginal ? row[cancelarOriginal] : null;
              const cancelarMotivo = cancelarMotivoBruto ? String(cancelarMotivoBruto).trim() : '';

              const headerSkuPrimarioIdx = headersLower.findIndex(h =>
                h.includes('número de referência sku') || h.includes('numero de referencia sku')
              );
              const headerSkuPrincipalIdx = headersLower.findIndex(h =>
                h.includes('nº de referência do sku principal') ||
                h.includes('n° de referência do sku principal') ||
                h.includes('no de referência do sku principal') ||
                h.includes('n o de referência do sku principal')
              );
              const headerSkuPrimario = headerSkuPrimarioIdx >= 0 ? headers[headerSkuPrimarioIdx] : null;
              const headerSkuPrincipal = headerSkuPrincipalIdx >= 0 ? headers[headerSkuPrincipalIdx] : null;
              let numeroReferenciaSku = headerSkuPrimario ? row[headerSkuPrimario] : null;
              numeroReferenciaSku = numeroReferenciaSku !== null && numeroReferenciaSku !== undefined
                ? String(numeroReferenciaSku).trim()
                : '';
              const skuPrincipalValorBruto = headerSkuPrincipal ? row[headerSkuPrincipal] : null;
              const skuPrincipalValor = skuPrincipalValorBruto !== null && skuPrincipalValorBruto !== undefined
                ? String(skuPrincipalValorBruto).trim()
                : '';
              if (!numeroReferenciaSku && skuPrincipalValor) {
                numeroReferenciaSku = skuPrincipalValor;
              }

              const headerQtd = headersLower.find(h => h.includes('quantidade'));
              const qtdOriginal = headerQtd ? headers[headersLower.indexOf(headerQtd)] : null;
              const quantidade = qtdOriginal ? parseFloat(row[qtdOriginal]) || 0 : 0;

              const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
              const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
              const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
              const comissaoPedido = parseFloat(row['Taxa de comissão']) || 0;
              const servicoPedido = parseFloat(row['Taxa de serviço']) || 0;
              const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
              const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;

              const headerPrevEnvio = headersLower.find(h => h.includes('data prevista') && h.includes('envio'));
              const prevEnvioOriginal = headerPrevEnvio ? headers[headersLower.indexOf(headerPrevEnvio)] : null;
              let dataPrevistaEnvio = prevEnvioOriginal ? row[prevEnvioOriginal] : null;
              dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);

              const headerRastreamento = headersLower.find(h => h.includes('rastreamento'));
              const rastreamentoOriginal = headerRastreamento ? headers[headersLower.indexOf(headerRastreamento)] : null;
              const numeroRastreamento = rastreamentoOriginal ? String(row[rastreamentoOriginal]).trim() : '';

              const statusPedido = row['Status do pedido'] || '';

              const pedidoPayload = {
                pedidoId,
                status: statusPedido,
                loja,
                data: dataReferencia,
                horaPagamento,
                quantidade,
                subtotal: subtotalPedido,
                cupom: cupomPedido,
                reembolso: reembolsoPedido,
                comissao: comissaoPedido,
                servico: servicoPedido,
                taxas: taxasPedido,
                liquido: liquidoPedido
              };
              if (numeroReferenciaSku) pedidoPayload.sku = numeroReferenciaSku;
              if (cancelarMotivo) pedidoPayload.cancelarMotivo = cancelarMotivo;

              const dadosPlanilhaPedido = {
                'Status do pedido': statusPedido,
                'Cancelar Motivo': cancelarMotivo || null,
                'Número de referência SKU': numeroReferenciaSku || null,
                Quantidade: quantidade,
                'Subtotal do produto': subtotalPedido,
                'Cupom do vendedor': cupomPedido,
                'Reembolso Shopee': reembolsoPedido,
                'Taxa de comissão': comissaoPedido,
                'Taxa de serviço': servicoPedido
              };
              if (headerSkuPrincipal) {
                dadosPlanilhaPedido['Nº de referência do SKU principal'] = skuPrincipalValor || null;
              }
              pedidoPayload.dadosPlanilha = dadosPlanilhaPedido;
              if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
              if (numeroRastreamento) {
                pedidoPayload.numeroRastreamento = numeroRastreamento;
                pedidoPayload.etiquetaImpressa = true;
              }

              const pedidoDocRef = pedidosRef
                .doc(dataReferencia)
                .collection('lista')
                .doc(pedidoId);
              const pedidoDoc = await pedidoDocRef.get();
              let needsUpdate = true;
              if (pedidoDoc.exists) {
                try {
                  const atual = JSON.parse(
                    await decryptString(pedidoDoc.data().encrypted, pass)
                  );
                  if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                    needsUpdate = false;
                  }
                } catch (e) {
                  console.error('Erro ao comparar pedido existente', e);
                }
              }

              if (needsUpdate) {
                const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
                await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
                if (baseResp && respEmail) {
                  const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                  await baseResp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
                }
                if (baseExp && gestorEmail) {
                  const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                  await baseExp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
                }
              }
            }

            const lojaPayload = {
              valorBruto: grupo.bruto,
              taxasPlataforma: grupo.taxas,
              valorLiquido: liquido,
              qtdVendas: grupo.qtdVendas,
              loja: loja,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid,
              diasInformados: diasPlanilhaInformados
            };
            const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
            await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
            if (baseResp && respEmail) {
              const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .collection('lojas')
                .doc(loja)
                .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
            }

            const resumoPayload = {
              valorBruto: grupo.bruto,
              valorLiquido: liquido,
              taxasPlataforma: grupo.taxas,
              vendas: grupo.qtdVendas,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid,
              diasInformados: diasPlanilhaInformados
            };
            const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
            await db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp && respEmail) {
              const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
            }

            resultados.push({
              data: dataReferencia,
              loja,
              status: 'ok',
              bruto: grupo.bruto,
              taxas: grupo.taxas,
              liquido,
              qtd: grupo.qtdVendas,
              diasInformados: diasPlanilhaInformados
            });
            await notificarResponsavelFinanceiro(dataReferencia, loja, grupo.bruto, liquido, grupo.qtdVendas);
          }

          setProgress(100);
          atualizarStatusModal('Processamento concluído com sucesso!', 'text-green-600');
          if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');

          const sucesso = resultados.filter(r => r.status === 'ok');
          const ignorados = resultados.filter(r => r.status === 'ignorado');

          let html = '';
          const diasInformadosResumo = diasPlanilhaInformados
            .map(dia => {
              if (typeof dia !== 'string') return '';
              const partes = dia.split('-');
              if (partes.length === 3) {
                return `${partes[2]}/${partes[1]}/${partes[0]}`;
              }
              return dia;
            })
            .filter(Boolean)
            .join(', ');
          if (diasInformadosResumo) {
            html += `<div class="alert alert-info mb-4"><i class="fas fa-calendar-alt"></i> Dias informados na planilha: ${diasInformadosResumo}</div>`;
          }
          if (sucesso.length) {
            html += '<div class="alert alert-success">';
            html += '<i class="fas fa-check-circle"></i> Faturamentos processados:';
            html += '<ul class="mt-2 space-y-1">';
            html += sucesso
              .map(r => `<li><strong>${r.data}</strong> - ${r.loja}: Bruto R$ ${r.bruto.toFixed(2)}, Taxas R$ ${r.taxas.toFixed(2)}, Líquido R$ ${r.liquido.toFixed(2)}, Vendas ${r.qtd}</li>`)
              .join('');
            html += '</ul></div>';
          }
          if (ignorados.length || rowsSemData.length) {
            html += '<div class="alert alert-warning mt-4">';
            html += '<i class="fas fa-exclamation-triangle"></i> Atenção:';
            if (ignorados.length) {
              html += `<br>${ignorados.length} dia(s) foram ignorados por opção do usuário.`;
            }
            if (rowsSemData.length) {
              html += `<br>${rowsSemData.length} registro(s) sem data de pagamento foram desconsiderados.`;
            }
            html += '</div>';
          }

          document.getElementById('resultadoFaturamento').innerHTML = html || '<div class="alert alert-info"><i class="fas fa-info-circle"></i> Nenhum faturamento foi processado.</div>';
          input.value = '';
        } catch (err) {
          mostrarErro('Erro ao importar: ' + err.message);
          console.error(err);
          atualizarStatusModal('Ocorreu um erro durante o processamento.', 'text-red-600');
          if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');
        }
      };

      reader.readAsArrayBuffer(file);
    };

    // =============================================
    // FUNÇÕES DE EXPORTAÇÃO
    // =============================================

    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      if (menu) {
        menu.classList.toggle('show');
      }
    }

    document.addEventListener('click', function(e) {
      const menu = document.getElementById('exportMenu');
      const btn = document.getElementById('btnExportar');
      if (!menu || !btn) return;
      if (!btn.contains(e.target) && !menu.contains(e.target)) {
        menu.classList.remove('show');
      }
    });
    
    async function salvarComissaoSobras() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível. Processe um arquivo antes de salvar a comissão.');
        return;
      }
      if (!db || !usuarioLogado?.uid) {
        mostrarErro('É necessário estar autenticado para salvar as informações.');
        return;
      }

      const hoje = new Date().toISOString().slice(0, 10);
      const { value: dadosSalvar } = await Swal.fire({
        title: 'Salvar comissão',
        html: `
          <div style="display: flex; flex-direction: column; gap: 0.75rem; text-align: left;">
            <label style="display:flex; flex-direction:column; gap:0.25rem;">
              <span style="font-weight:600;">Data dos pedidos</span>
              <input id="swalDataComissao" type="date" class="swal2-input" value="${hoje}" />
            </label>
            <label style="display:flex; flex-direction:column; gap:0.25rem;">
              <span style="font-weight:600;">Nome da loja</span>
              <input id="swalLojaComissao" type="text" class="swal2-input" placeholder="Ex: Loja Central" />
            </label>
          </div>
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Salvar',
        cancelButtonText: 'Cancelar',
        preConfirm: () => {
          const dataSelecionada = document.getElementById('swalDataComissao')?.value;
          const lojaSelecionada = document.getElementById('swalLojaComissao')?.value?.trim();
          if (!dataSelecionada || !lojaSelecionada) {
            Swal.showValidationMessage('Informe a data e o nome da loja.');
            return false;
          }
          return { dataSelecionada, lojaSelecionada };
        }
      });

      if (!dadosSalvar) return;

      const { dataSelecionada, lojaSelecionada } = dadosSalvar;

      try {
        Swal.fire({
          title: 'Salvando dados',
          text: 'Armazenando pedidos e resumo de comissões...',
          allowOutsideClick: false,
          didOpen: () => {
            Swal.showLoading();
          }
        });

        const arredondar = (valor) => Math.round((Number(valor) || 0) * 100) / 100;

        const pedidosSalvos = pedidosProcessados.map((pedido) => {
          const comissaoDesvio = pedido.comissaoValorDisplay;
          const excedente = pedido.excedenteAcimaLimite;
          return {
            id: pedido.id,
            comprador: pedido.comprador || '',
            sku: pedido.sku,
            quantidade: Number(pedido.quantidade) || 0,
            subtotal: arredondar(pedido.subtotal),
            sobra: arredondar(pedido.sobra),
            descricaoComissao: obterDescricaoComissaoPercentual(pedido),
            comissaoDesvio: comissaoDesvio !== null && comissaoDesvio !== undefined && Number.isFinite(comissaoDesvio)
              ? arredondar(comissaoDesvio)
              : 0,
            excedente: excedente !== null && excedente !== undefined && Number.isFinite(excedente)
              ? Math.max(arredondar(excedente), 0)
              : 0
          };
        });

        const totalSubtotal = arredondar(
          pedidosSalvos.reduce((sum, p) => sum + (Number(p.subtotal) || 0), 0)
        );
        const totalSobra = arredondar(
          pedidosSalvos.reduce((sum, p) => sum + (Number(p.sobra) || 0), 0)
        );
        const totalComissaoDia = arredondar(
          pedidosSalvos.reduce((sum, p) => sum + (Number(p.comissaoDesvio) || 0), 0)
        );
        const totalExcedente = arredondar(
          pedidosSalvos.reduce((sum, p) => sum + (Number(p.excedente) || 0), 0)
        );
        const mediaPercentual = pedidosProcessados.length
          ? arredondar(
              pedidosProcessados.reduce((sum, pedido) => {
                const percentual = Number(pedido.percentual);
                return sum + (Number.isFinite(percentual) ? percentual : 0);
              }, 0) / pedidosProcessados.length
            )
          : 0;

        const totalQuantidade = arredondar(
          pedidosProcessados.reduce((sum, p) => sum + (Number(p.quantidade) || 0), 0)
        );
        const resumoMap = new Map();
        pedidosProcessados.forEach(p => {
          const chaveSku = p.sku || 'SEM SKU';
          const atual = resumoMap.get(chaveSku) || { sku: chaveSku, quantidade: 0, comissao: 0 };
          atual.quantidade += Number(p.quantidade) || 0;
          const valorComissao = Number(p.comissaoValorDisplay);
          if (p.comissaoValorDisplay !== null && p.comissaoValorDisplay !== undefined && Number.isFinite(valorComissao)) {
            atual.comissao += valorComissao;
          }
          resumoMap.set(chaveSku, atual);
        });

        const resumoSkus = Array.from(resumoMap.values()).map(item => ({
          sku: item.sku,
          quantidade: arredondar(item.quantidade),
          comissaoTotal: arredondar(item.comissao)
        }));

        const resumoGeral = {
          totalSubtotal,
          totalSobra,
          mediaPercentual,
          totalComissaoDesvio: totalComissaoDia,
          totalExcedente
        };

        const payload = {
          data: dataSelecionada,
          loja: lojaSelecionada,
          geradoEm: new Date().toISOString(),
          totalPedidos: pedidosProcessados.length,
          totalComissaoDia,
          totalQuantidade,
          resumoSkus,
          pedidos: pedidosProcessados,
          pedidosSalvos,
          resumoGeral
        };

        const { encryptString } = await import('./crypto.js');
        const pass = getPassphrase() || usuarioLogado.uid;
        const encrypted = await encryptString(JSON.stringify(payload), pass);

        const docRef = db
          .collection('uid')
          .doc(usuarioLogado.uid)
          .collection('comissoesSobras')
          .doc(dataSelecionada);

        const atualizadoEm = typeof firebase !== 'undefined' && firebase.firestore?.FieldValue?.serverTimestamp
          ? firebase.firestore.FieldValue.serverTimestamp()
          : new Date().toISOString();

        await docRef.set({
          uid: usuarioLogado.uid,
          data: dataSelecionada,
          loja: lojaSelecionada,
          totalPedidos: pedidosProcessados.length,
          totalComissaoDia,
          totalQuantidade,
          resumoSkus,
          resumoGeral,
          encrypted,
          atualizadoEm
        });

        Swal.close();
        mostrarSucesso('Comissão salva com sucesso!');
      } catch (error) {
        Swal.close();
        console.error('Erro ao salvar comissão', error);
        mostrarErro(`Erro ao salvar a comissão: ${error.message}`);
      }
    }

    function obterDescricaoComissaoPercentual(pedido) {
      if (!pedido) return '';

      const fontes = [pedido.comissaoDescricao, pedido.comissaoTexto];
      for (const fonte of fontes) {
        if (!fonte) continue;

        const matchPercentual = fonte.match(/(\d+(?:[.,]\d+)?)%/);
        if (matchPercentual && matchPercentual[1]) {
          const numero = Number.parseFloat(matchPercentual[1].replace(',', '.'));
          if (Number.isFinite(numero)) {
            const possuiDecimal = Math.abs(numero % 1) > 1e-9;
            const percentualFormatado = numero.toLocaleString('pt-BR', {
              minimumFractionDigits: possuiDecimal ? 1 : 0,
              maximumFractionDigits: 2
            });
            return `${percentualFormatado}%`;
          }
          return `${matchPercentual[1].replace('.', ',')}%`;
        }
      }

      return '';
    }

    function extrairPercentualComissao(valor) {
      const texto = typeof valor === 'string' ? valor : obterDescricaoComissaoPercentual(valor);
      if (!texto) return null;

      const match = String(texto).match(/(\d+(?:[.,]\d+)?)/);
      if (!match || !match[1]) return null;

      const numero = Number.parseFloat(match[1].replace(',', '.'));
      return Number.isFinite(numero) ? Number(numero.toFixed(1)) : null;
    }

    function obterSobraEsperadaPorPercentual(pedido) {
      const percentual = extrairPercentualComissao(pedido);
      if (!Number.isFinite(percentual) || !pedido) return null;

      if (percentual === 5 && numeroValido(pedido.custoMaximo)) return pedido.custoMaximo;
      if (percentual === 3 && numeroValido(pedido.custoMedio)) return pedido.custoMedio;
      if (percentual === 1.5 && numeroValido(pedido.custoMinimo)) return pedido.custoMinimo;
      return null;
    }

    function exportarCSV() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }

      try {
        // Cabeçalhos
        let csv = 'ID do Pedido;SKU;Comprador;Quantidade;Subtotal;Reembolso;Cupom;Comissão;Serviço;Sobra;Meta;Classificação do Preço;Detalhe da Classificação;Valor Comissão/Desvio (R$);Descrição Comissão;Excedente >3% Máx (R$);% vs Meta;Status\n';

        // Dados
        pedidosProcessados.forEach(pedido => {
          const status = pedido.meta ?
            (pedido.percentual <= -10 ? 'Crítico' :
             pedido.percentual <= -5 ? 'Atenção' :
             pedido.percentual >= 5 ? 'Bom' : 'Normal') : 'Sem meta';

          const detalheFaixa = (pedido.detalheFaixa || '').replace(/"/g, '""');
          const classificacao = (pedido.faixa || '').replace(/"/g, '""');
          const comprador = (pedido.comprador || '').replace(/"/g, '""');
          const quantidade = Number.isFinite(pedido.quantidade)
            ? pedido.quantidade.toLocaleString('pt-BR', {
                minimumFractionDigits: Number.isInteger(pedido.quantidade) ? 0 : 2,
                maximumFractionDigits: 2
              })
            : '';
          const valorComissao = pedido.comissaoValorDisplay !== null && pedido.comissaoValorDisplay !== undefined
            ? pedido.comissaoValorDisplay.toFixed(2)
            : '';
          const descricaoComissao = obterDescricaoComissaoPercentual(pedido).replace(/"/g, '""');
          const excedenteLimite = pedido.excedenteAcimaLimite > 0
            ? pedido.excedenteAcimaLimite.toFixed(2)
            : '';

          csv += `"${pedido.id}";"${pedido.sku}";"${comprador}";"${quantidade}";"${pedido.subtotal.toFixed(2)}";"${pedido.reembolso.toFixed(2)}";"${pedido.cupom.toFixed(2)}";"${pedido.comissao.toFixed(2)}";"${pedido.servico.toFixed(2)}";"${pedido.sobra.toFixed(2)}";"${pedido.meta.toFixed(2)}";"${classificacao}";"${detalheFaixa}";"${valorComissao}";"${descricaoComissao}";"${excedenteLimite}";"${pedido.percentual.toFixed(2)}";"${status}"\n`;
        });

        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.csv`);

        mostrarSucesso('Arquivo CSV exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar CSV: ${error.message}`);
        console.error("Erro ao exportar CSV:", error);
      }
    }

    function exportarExcel() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }

      try {
        const headers = [
          'ID do Pedido',
          'Comprador',
          'SKU',
          'Quantidade',
          'Subtotal',
          'Sobra',
          'Sobra Esperada p/ %',
          'Descrição Comissão',
          'Valor Comissão/Desvio (R$)',
          'Excedente >3% Máx (R$)'
        ];

        const cores = {
          1.5: 'FFFFC7CE', // vermelho claro
          3: 'FFFFFF99',   // amarelo claro
          5: 'FFC6EFCE'    // verde claro
        };

        const mapearPedidoParaLinha = (pedido) => {
          const descricaoComissao = obterDescricaoComissaoPercentual(pedido);
          const sobraEsperadaPercentual = Number.isFinite(pedido.sobraEsperadaPercentual)
            ? Number(pedido.sobraEsperadaPercentual.toFixed(2))
            : '';

          return {
            'ID do Pedido': pedido.id,
            'Comprador': pedido.comprador || '',
            'SKU': pedido.sku,
            'Quantidade': Number.isFinite(pedido.quantidade)
              ? Number(pedido.quantidade)
              : '',
            'Subtotal': Number(pedido.subtotal.toFixed(2)),
            'Sobra': Number(pedido.sobra.toFixed(2)),
            'Sobra Esperada p/ %': sobraEsperadaPercentual,
            'Descrição Comissão': descricaoComissao,
            'Valor Comissão/Desvio (R$)': pedido.comissaoValorDisplay !== null && pedido.comissaoValorDisplay !== undefined
              ? Number(pedido.comissaoValorDisplay.toFixed(2))
              : '',
            'Excedente >3% Máx (R$)': pedido.excedenteAcimaLimite > 0
              ? Number(pedido.excedenteAcimaLimite.toFixed(2))
              : ''
          };
        };

        const aplicarCabecalhoSeVazio = (worksheet) => {
          if (worksheet?.['!ref']) return;

          headers.forEach((header, index) => {
            const cellRef = XLSX.utils.encode_cell({ c: index, r: 0 });
            worksheet[cellRef] = { t: 's', v: header };
          });

          worksheet['!ref'] = XLSX.utils.encode_range({
            s: { c: 0, r: 0 },
            e: { c: headers.length - 1, r: 0 }
          });
        };

        const aplicarCorLinhasWorksheet = (worksheet, cor, quantidadeLinhas) => {
          if (!worksheet?.['!ref'] || !cor || !quantidadeLinhas) return;

          const range = XLSX.utils.decode_range(worksheet['!ref']);
          for (let r = 1; r <= quantidadeLinhas; r++) {
            for (let c = range.s.c; c <= range.e.c; c++) {
              const cellRef = XLSX.utils.encode_cell({ r, c });
              const cell = worksheet[cellRef] || (worksheet[cellRef] = { t: 's', v: '' });
              cell.s = {
                fill: {
                  patternType: 'solid',
                  fgColor: { rgb: cor }
                }
              };
            }
          }
        };

        const criarWorksheet = (linhas, cor) => {
          const worksheet = XLSX.utils.json_to_sheet(linhas, { header: headers });
          aplicarCabecalhoSeVazio(worksheet);
          aplicarCorLinhasWorksheet(worksheet, cor, linhas.length);
          return worksheet;
        };

        const percentuais = [1.5, 3, 5];
        const workbook = XLSX.utils.book_new();

        const totalSubtotal = pedidosProcessados.reduce((acc, pedido) => acc + (Number(pedido.subtotal) || 0), 0);
        const totalSobra = pedidosProcessados.reduce((acc, pedido) => acc + (Number(pedido.sobra) || 0), 0);
        const totalSobraEsperada = pedidosProcessados.reduce(
          (acc, pedido) => acc + (Number.isFinite(pedido.sobraEsperadaPercentual) ? pedido.sobraEsperadaPercentual : 0),
          0
        );
        const totalComissao = pedidosProcessados.reduce(
          (acc, pedido) => acc + (Number.isFinite(pedido.comissaoValorDisplay) ? pedido.comissaoValorDisplay : 0),
          0
        );
        const totalExcedenteMaximo = pedidosProcessados.reduce(
          (acc, pedido) => acc + (Number.isFinite(pedido.excedenteMaximo) && pedido.excedenteMaximo > 0 ? pedido.excedenteMaximo : 0),
          0
        );

        const percentuaisPedidos = pedidosProcessados
          .map((pedido) => extrairPercentualComissao(pedido))
          .filter((valor) => Number.isFinite(valor));
        const contagens = { 1.5: 0, 3: 0, 5: 0 };
        percentuaisPedidos.forEach((valor) => {
          if (contagens[valor] !== undefined) {
            contagens[valor] += 1;
          }
        });
        const mediaPercentual = percentuaisPedidos.length
          ? percentuaisPedidos.reduce((acc, valor) => acc + valor, 0) / percentuaisPedidos.length
          : 0;

        const resumoLinhas = [
          { Indicador: 'Total Subtotal (R$)', Valor: Number(totalSubtotal.toFixed(2)) },
          { Indicador: 'Total das Sobras (R$)', Valor: Number(totalSobra.toFixed(2)) },
          { Indicador: 'Sobra Esperada p/ % (R$)', Valor: Number(totalSobraEsperada.toFixed(2)) },
          { Indicador: 'Pedidos com 1,5%', Valor: contagens[1.5] },
          { Indicador: 'Pedidos com 3%', Valor: contagens[3] },
          { Indicador: 'Pedidos com 5%', Valor: contagens[5] },
          { Indicador: 'Média Geral % Comissão', Valor: Number(mediaPercentual.toFixed(2)) },
          { Indicador: 'Total Comissão/Desvio (R$)', Valor: Number(totalComissao.toFixed(2)) },
          { Indicador: 'Excedente acima do Máximo (R$)', Valor: Number(totalExcedenteMaximo.toFixed(2)) }
        ];

        const resumoSheet = XLSX.utils.json_to_sheet(resumoLinhas, { header: ['Indicador', 'Valor'] });
        aplicarCabecalhoSeVazio(resumoSheet);
        XLSX.utils.book_append_sheet(workbook, resumoSheet, 'Resumo');

        percentuais.forEach((percentual) => {
          const linhas = pedidosProcessados
            .filter((pedido) => extrairPercentualComissao(pedido) === percentual)
            .map(mapearPedidoParaLinha);
          const worksheet = criarWorksheet(linhas, cores[percentual]);
          const nomeAba = percentual === 1.5 ? '1,5%' : `${percentual}%`;
          XLSX.utils.book_append_sheet(workbook, worksheet, nomeAba);
        });

        const nomeArquivo = `relatorio_sobras_${new Date().toISOString().slice(0,10)}.xlsx`;
        XLSX.writeFile(workbook, nomeArquivo);
        mostrarSucesso('Arquivo Excel exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar Excel: ${error.message}`);
        console.error('Erro ao exportar Excel:', error);
      }
    }

    async function exportarSobrasPDF() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }

      if (!window.jspdf || typeof window.jspdf.jsPDF !== 'function') {
        mostrarErro('Biblioteca jsPDF não carregada para exportação em PDF.');
        return;
      }

      const hoje = new Date().toISOString().slice(0, 10);
      const { value: dadosCabecalho } = await Swal.fire({
        title: 'Informações do relatório',
        html: `
          <div class="swal2-field">
            <label style="display:block; text-align:left; font-weight:600; margin-bottom:4px;">Data</label>
            <input type="date" id="pdfData" class="swal2-input" value="${hoje}" style="width: 100%;" />
          </div>
          <div class="swal2-field">
            <label style="display:block; text-align:left; font-weight:600; margin-bottom:4px;">Nome da loja</label>
            <input type="text" id="pdfLoja" class="swal2-input" placeholder="Ex: Minha Loja" style="width: 100%;" />
          </div>
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Gerar PDF',
        cancelButtonText: 'Cancelar',
        preConfirm: () => {
          const data = document.getElementById('pdfData')?.value;
          const loja = document.getElementById('pdfLoja')?.value.trim();
          if (!data || !loja) {
            Swal.showValidationMessage('Informe a data e o nome da loja.');
            return false;
          }
          return { data, loja };
        }
      });

      if (!dadosCabecalho) return;

      const doc = new window.jspdf.jsPDF({ orientation: 'landscape', unit: 'mm', format: 'a4' });
      doc.setFontSize(12);
      const dataFormatada = dadosCabecalho.data.split('-').reverse().join('/');
      doc.text(`Data: ${dataFormatada}`, 14, 14);
      doc.text(`Loja: ${dadosCabecalho.loja}`, 14, 22);

      const totalSubtotal = pedidosProcessados.reduce((acc, pedido) => acc + (Number(pedido.subtotal) || 0), 0);
      const totalSobra = pedidosProcessados.reduce((acc, pedido) => acc + (Number(pedido.sobra) || 0), 0);
      const totalComissao = pedidosProcessados.reduce(
        (acc, pedido) => acc + (Number.isFinite(pedido.comissaoValorDisplay) ? pedido.comissaoValorDisplay : 0),
        0
      );
      const totalExcedente = pedidosProcessados.reduce(
        (acc, pedido) => acc + (Number.isFinite(pedido.excedenteAcimaLimite) ? pedido.excedenteAcimaLimite : 0),
        0
      );
      const mediaPercentual = pedidosProcessados.length
        ? pedidosProcessados.reduce((acc, pedido) => acc + (Number.isFinite(pedido.percentual) ? pedido.percentual : 0), 0) /
          pedidosProcessados.length
        : 0;

      const cards = [
        { titulo: 'Total Subtotal', valor: formatarMoedaBR(totalSubtotal) },
        { titulo: 'Total da Sobra', valor: formatarMoedaBR(totalSobra) },
        { titulo: 'Média (%)', valor: `${mediaPercentual.toFixed(2)}%` },
        { titulo: 'Total Comissão/Desvio', valor: formatarMoedaBR(totalComissao) },
        { titulo: 'Total Excedente', valor: formatarMoedaBR(totalExcedente) }
      ];

      let posX = 14;
      let posY = 32;
      const cardWidth = 60;
      const cardHeight = 18;
      const gap = 6;

      doc.setFontSize(10);
      cards.forEach((card, index) => {
        doc.setFillColor(245, 245, 245);
        doc.roundedRect(posX, posY, cardWidth, cardHeight, 2, 2, 'F');
        doc.setTextColor(60, 60, 60);
        doc.text(card.titulo, posX + 4, posY + 7);
        doc.setFontSize(12);
        doc.setTextColor(0, 0, 0);
        doc.text(card.valor, posX + 4, posY + 14);
        doc.setFontSize(10);

        const isFimLinha = (index + 1) % 3 === 0;
        if (isFimLinha) {
          posX = 14;
          posY += cardHeight + gap;
        } else {
          posX += cardWidth + gap;
        }
      });

      const inicioTabela = posY + cardHeight + 4;
      const corpo = pedidosProcessados.map((pedido) => [
        pedido.id,
        pedido.comprador || '-',
        pedido.sku,
        Number.isFinite(pedido.quantidade)
          ? pedido.quantidade.toLocaleString('pt-BR', { minimumFractionDigits: Number.isInteger(pedido.quantidade) ? 0 : 2 })
          : '-',
        formatarMoedaBR(pedido.subtotal),
        formatarMoedaBR(pedido.sobra),
        obterDescricaoComissaoPercentual(pedido) || '-',
        Number.isFinite(pedido.comissaoValorDisplay) ? formatarMoedaBR(pedido.comissaoValorDisplay) : '-',
        Number.isFinite(pedido.excedenteAcimaLimite) && pedido.excedenteAcimaLimite > 0
          ? formatarMoedaBR(pedido.excedenteAcimaLimite)
          : '-'
      ]);

      if (typeof doc.autoTable !== 'function') {
        mostrarErro('Recurso de tabela do PDF indisponível.');
        return;
      }

      doc.autoTable({
        head: [
          [
            'ID do Pedido',
            'Comprador',
            'SKU',
            'Quantidade',
            'Subtotal',
            'Sobra',
            'Descrição Comissão',
            'Valor Comissão/Desvio (R$)',
            'Excedente >3% Máx (R$)'
          ]
        ],
        body: corpo,
        startY: inicioTabela,
        styles: { fontSize: 9 },
        headStyles: { fillColor: [52, 58, 64] },
        willDrawCell: (data) => {
          if (data.section !== 'body') return;

          const cores = {
            1.5: [255, 204, 204],
            3.0: [255, 244, 179],
            5.0: [204, 236, 204]
          };

          const pedido = pedidosProcessados[data.row.index];
          const percentual = extrairPercentualComissao(pedido);
          const cor = cores[percentual];

          if (!cor) return;

          if (data.row && data.row.cells) {
            Object.values(data.row.cells).forEach((cell) => {
              cell.styles.fillColor = cor;
              cell.styles.textColor = [0, 0, 0];
            });
          }

          if (data.row && data.row.styles) {
            data.row.styles.fillColor = cor;
            data.row.styles.textColor = [0, 0, 0];
          }
        }
      });

      doc.save(`relatorio_sobras_${new Date().toISOString().slice(0, 10)}.pdf`);
    }
    const registrosFaturamentoSelecionados = new Set();

    function atualizarBotaoExcluirRegistrosSelecionados() {
      const btn = document.getElementById('btnExcluirRegistrosSelecionados');
      if (!btn) return;
      const temSelecao = registrosFaturamentoSelecionados.size > 0;
      btn.disabled = !temSelecao;
      btn.classList.toggle('opacity-60', !temSelecao);
      btn.classList.toggle('cursor-not-allowed', !temSelecao);
    }

    async function carregarRegistrosFaturamento(idContainer = "listaFaturamento", idFiltroMes = "filtroMes") {
      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const container = document.getElementById(idContainer);
      container.innerHTML = "";

      registrosFaturamentoSelecionados.clear();
      atualizarBotaoExcluirRegistrosSelecionados();

      const filtroMes = document.getElementById(idFiltroMes)?.value;

      for (const docData of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoData, mesData] = docData.id.split("-");
          if (anoFiltro !== anoData || mesFiltro !== mesData) continue;
        }

const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
                const { decryptString } = await import('./crypto.js');
        let bruto = 0, liquido = 0, qtd = 0;

        for (const sub of subSnap.docs) {
          const dataSub = sub.data();
          let d = dataSub;
          if (dataSub.encrypted) {
            try {
              const txt = await decryptString(dataSub.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          qtd += d.qtdVendas || 0;
        }

        const card = document.createElement("div");
        card.className = "bg-white rounded-2xl shadow-lg p-4 border border-gray-200 hover:shadow-xl transition";

        const selecionado = registrosFaturamentoSelecionados.has(docData.id);

        card.innerHTML = `
          <div class="flex items-center justify-between mb-2">
            <div class="text-sm text-gray-500 flex items-center gap-2">
              <i class="fas fa-calendar-alt text-blue-600"></i>
              <span class="font-semibold">${docData.id}</span>
            </div>
            <label class="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
              <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" ${selecionado ? 'checked' : ''}
                onchange="alternarSelecaoFaturamento(this, '${docData.id}')">
              Selecionar
            </label>
          </div>

          <div class="text-2xl font-bold text-blue-800 mb-1">💰 Bruto: R$ ${bruto.toLocaleString('pt-BR')}</div>
          <div class="text-xl font-semibold text-green-600 mb-1">🔻 Líquido: R$ ${liquido.toLocaleString('pt-BR')}</div>
          <div class="text-base text-gray-600 mb-4">🛒 Vendas: ${qtd}</div>

          <div class="flex justify-between items-center mt-4 gap-2">
            <button onclick='mostrarDetalhesFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-search"></i> Ver Detalhes
            </button>
            <button onclick='copiarResumoFaturamento("${docData.id}", ${bruto}, ${liquido}, ${qtd})'
              class="btn btn-outline">
              <i class="fas fa-copy"></i> Copiar Resumo
            </button>
            <button onclick='excluirFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-trash-alt"></i> Excluir
            </button>
          </div>

          <div id="detalhes-${docData.id}" class="mt-3 text-sm text-gray-700" style="display:none;"></div>
        `;

        container.appendChild(card);
      }
    }

    function copiarResumoFaturamento(dataRef, bruto, liquido, qtd) {
      const formatCurrency = (valor) => Number(valor || 0).toLocaleString('pt-BR', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      });

      const texto = `${dataRef}\n Bruto: R$ ${formatCurrency(bruto)}\n Líquido: R$ ${formatCurrency(liquido)}\nVendas: ${qtd}`;

      if (navigator?.clipboard?.writeText) {
        navigator.clipboard.writeText(texto)
          .then(() => {
            if (typeof showToast === 'function') {
              showToast('Resumo de faturamento copiado!', 'success');
            }
          })
          .catch(() => {
            if (typeof showToast === 'function') {
              showToast('Não foi possível copiar o resumo.', 'error');
            }
          });
      } else {
        const textarea = document.createElement('textarea');
        textarea.value = texto;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();
        try {
          document.execCommand('copy');
          if (typeof showToast === 'function') {
            showToast('Resumo de faturamento copiado!', 'success');
          }
        } catch (err) {
          if (typeof showToast === 'function') {
            showToast('Não foi possível copiar o resumo.', 'error');
          }
        } finally {
          document.body.removeChild(textarea);
        }
      }
    }

    async function mostrarDetalhesFaturamento(dataRef) {
      const detalhesEl = document.getElementById("detalhes-" + dataRef);
      if (detalhesEl.style.display === "block") {
        detalhesEl.style.display = "none";
        return;
      }

      detalhesEl.innerHTML = `<div class="text-sm text-gray-500">🔄 Carregando...</div>`;
      detalhesEl.style.display = "block";

      const { decryptString } = await import('./crypto.js');
 let refs = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('faturamento')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataRef)
          .get();
        q.forEach(doc => {
          refs.push(db.collection(`uid/${doc.ref.parent.parent.id}/faturamento/${dataRef}/lojas`));
        });
      } else {
        refs.push(db.collection(`uid/${usuarioLogado.uid}/faturamento/${dataRef}/lojas`));
      }
      let html = "";
 for (const r of refs) {
        const snap = await r.get();
        for (const doc of snap.docs) {
          let d = doc.data();
        if (d.encrypted) {
          try {
            const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
            d = JSON.parse(txt);
          } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
        }
        const loja = d.loja || "Desconhecida";
        const bruto = d.valorBruto?.toLocaleString("pt-BR") || "0,00";
        const liquido = d.valorLiquido?.toLocaleString("pt-BR") || "0,00";
        const vendas = d.qtdVendas || 0;

        html += `
          <div class="mt-1 text-sm text-gray-800 border-t pt-1">
            <strong>${loja}</strong>: Bruto R$ ${bruto} | Líquido R$ ${liquido} | Vendas: ${vendas}
          </div>
        `;
       }
      }

      detalhesEl.innerHTML = html;
    }

    async function excluirDocumentosSubcolecao(docRef, nomeColecao, limite = 500) {
      const subRef = docRef.collection(nomeColecao);
      while (true) {
        const snapshot = await subRef.limit(limite).get();
        if (snapshot.empty) break;

        const batch = db.batch();
        snapshot.docs.forEach((subDoc) => batch.delete(subDoc.ref));
        await batch.commit();

        if (snapshot.size < limite) break;
      }
    }

    async function excluirDocumentoFaturamento(docRef) {
      const subColecoes = ['lojas'];
      for (const nome of subColecoes) {
        await excluirDocumentosSubcolecao(docRef, nome);
      }
      await docRef.delete();
    }

    async function excluirRegistrosFaturamento(dias) {
      const isAdmin = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase());

      for (const data of dias) {
        if (isAdmin) {
          const snap = await db.collectionGroup('faturamento')
            .where(firebase.firestore.FieldPath.documentId(), '==', data)
            .get();
          for (const doc of snap.docs) {
            await excluirDocumentoFaturamento(doc.ref);
          }
        } else {
          const docRef = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').doc(data);
          await excluirDocumentoFaturamento(docRef);
        }
      }
    }

    async function excluirFaturamento(data) {
        if (!confirm(`Tem certeza que deseja excluir o faturamento do dia ${data}?`)) return;
        try {
          await excluirRegistrosFaturamento([data]);
          mostrarSucesso("Registro excluído com sucesso.");
          carregarRegistrosFaturamento();
        } catch (erro) {
          console.error('Erro ao excluir faturamento:', erro);
          mostrarErro('Não foi possível excluir o registro selecionado. Tente novamente.');
        }
      }

    function alternarSelecaoFaturamento(checkbox, dia) {
      if (checkbox.checked) {
        registrosFaturamentoSelecionados.add(dia);
      } else {
        registrosFaturamentoSelecionados.delete(dia);
      }
      atualizarBotaoExcluirRegistrosSelecionados();
    }

    async function excluirFaturamentosSelecionados() {
      const dias = Array.from(registrosFaturamentoSelecionados);
      if (!dias.length) return;

      const mensagemConfirmacao = dias.length === 1
        ? `Tem certeza que deseja excluir o faturamento do dia ${dias[0]}?`
        : `Tem certeza que deseja excluir os faturamentos dos dias:\n${dias.join(', ')}?`;

      if (!confirm(mensagemConfirmacao)) return;

      try {
        await excluirRegistrosFaturamento(dias);
        registrosFaturamentoSelecionados.clear();
        atualizarBotaoExcluirRegistrosSelecionados();

        mostrarSucesso(dias.length === 1
          ? "Registro excluído com sucesso."
          : "Registros excluídos com sucesso.");

        carregarRegistrosFaturamento();
      } catch (erro) {
        console.error('Erro ao excluir faturamentos selecionados:', erro);
        mostrarErro('Não foi possível excluir os registros selecionados. Tente novamente.');
      }
    }

    function exportarJSON() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }
      
      try {
        const data = {
          geradoEm: new Date().toISOString(),
          pedidos: pedidosProcessados,
          resumo: {
            totalSobra: pedidosProcessados.reduce((sum, p) => sum + p.sobra, 0),
            totalMeta: pedidosProcessados.reduce((sum, p) => sum + (p.meta || 0), 0),
            totalComissao: pedidosProcessados.reduce((sum, p) => {
              const valor = Number(p.comissaoValorDisplay);
              if (p.comissaoValorDisplay === null || p.comissaoValorDisplay === undefined || !Number.isFinite(valor)) {
                return sum;
              }
              return sum + valor;
            }, 0),
            totalQuantidade: pedidosProcessados.reduce((sum, p) => sum + (Number(p.quantidade) || 0), 0)
          }
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.json`);
        
        mostrarSucesso('Arquivo JSON exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar JSON: ${error.message}`);
        console.error("Erro ao exportar JSON:", error);
      }
    }
    window.analisarSobrasComIA = async function analisarSobrasComIA() {
      try {
        const linhas = document.querySelectorAll("#tabelaSobras tbody tr");
        let dados = [];

        linhas.forEach(linha => {
          const colunas = linha.querySelectorAll("td");
          if (colunas.length >= 5) {
            dados.push({
              sku: colunas[0].innerText.trim(),
              nome: colunas[1].innerText.trim(),
              vendido: parseInt(colunas[2].innerText) || 0,
              sobra: parseInt(colunas[3].innerText) || 0,
              data: colunas[4].innerText.trim()
            });
          }
        });

        const prompt = `
    Você é um especialista em controle de estoque e sobras da Shopee.

    Receberá uma lista com SKUs, nomes, vendidos e sobras.

    Analise:
    🔹 1. Valide se a sobra registrada faz sentido
    🔹 2. Detecte padrões incomuns (ex: sobra alta sem venda)
    🔹 3. Gere resumo por SKU com observações
    🔹 4. Sugira ações (ex: revisar, repor, ignorar)

    Dados:
    ${JSON.stringify(dados, null, 2)}
    `;

        const resposta = await consultarDeepSeek(prompt);
        document.getElementById("resultadoIA").innerText = resposta;
      } catch (erro) {
        console.error("Erro IA sobras:", erro);
        document.getElementById("resultadoIA").innerText = "Erro ao analisar sobras com IA.";
      }
   };
    async function analisarSobrasIA() {
      const prompt = `
    Sou um sistema de controle de sobras da Shopee. Com base nos dados abaixo, analise se os SKUs estão performando bem, identifique padrões incomuns e sugira ações como promoções, reposição ou atenção especial.

    Dados:
    ${document.getElementById("dadosSobrasIA").value}

    Gere um resumo inteligente com insights práticos.
    `;

      document.getElementById("resultadoIA").innerHTML = "⌛ Analisando com IA...";
      
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pergunta: prompt })
        });

        const data = await resposta.json();
        const output = data.choices?.[0]?.message?.content || data.resposta || "⚠️ Resposta não recebida.";

        document.getElementById("resultadoIA").innerHTML = output;
      } catch (error) {
        document.getElementById("resultadoIA").innerHTML = "❌ Erro ao consultar IA: " + error.message;
        console.error("Erro IA:", error);
        updateConnectionStatus(false);
      }
    }
    function resetPrevisaoProdutosVendidos() {
      const container = document.getElementById('produtosVendidosPrevisaoWrapper');
      const tabela = document.getElementById('produtosVendidosPrevisaoTabela');
      const resumo = document.getElementById('produtosVendidosPrevisaoResumo');
      if (container) container.classList.add('hidden');
      if (tabela) tabela.innerHTML = '';
      if (resumo) resumo.textContent = '';
    }

    function obterFiltroSkuProdutosVendidosValor() {
      return (
        document.getElementById('filtroSkuProdutosVendidos')?.value || ''
      )
        .trim()
        .toLowerCase();
    }

    function obterFiltroResponsavelProdutosVendidosValor() {
      const select = document.getElementById(
        'filtroResponsavelProdutosVendidos',
      );
      if (!select) return '';
      return (select.value || '').trim().toLowerCase();
    }

    function obterProdutosVendidosFiltrados() {
      const filtroSkuValor = obterFiltroSkuProdutosVendidosValor();
      const filtroResponsavelValor =
        obterFiltroResponsavelProdutosVendidosValor();

      const normalizarTexto = (valor) =>
        String(valor || '').trim().toLowerCase();

      const atendeFiltroSku = (sku) => {
        if (!filtroSkuValor) return true;
        return normalizarTexto(sku).includes(filtroSkuValor);
      };

      const reconstruirDetalhesPorUsuario = (item) => {
        if (!Array.isArray(item.detalhesPorUsuario)) return new Map();
        return new Map(
          item.detalhesPorUsuario.map((detalhe) => {
            const nome = detalhe?.nome ?? '';
            const mapaSkus = Array.isArray(detalhe?.skus)
              ? new Map(
                  detalhe.skus.map((skuInfo) => [
                    skuInfo?.sku ?? '',
                    {
                      total: Number(skuInfo?.total || 0),
                      valorLiquido: Number(skuInfo?.valorLiquido || 0),
                    },
                  ]),
                )
              : new Map();
            return [
              nome,
              {
                total: Number(detalhe?.total || 0),
                valorLiquido: Number(detalhe?.valorLiquido || 0),
                skus: mapaSkus,
              },
            ];
          }),
        );
      };

      const reconstruirDetalhesPorSku = (item) => {
        if (!Array.isArray(item.detalhesPorSku)) return new Map();
        return new Map(
          item.detalhesPorSku.map((detalhe) => {
            const mapaUsuarios = Array.isArray(detalhe?.usuarios)
              ? new Map(
                  detalhe.usuarios.map((usuarioInfo) => [
                    usuarioInfo?.nome ?? '',
                    {
                      total: Number(usuarioInfo?.total || 0),
                      valorLiquido: Number(usuarioInfo?.valorLiquido || 0),
                    },
                  ]),
                )
              : new Map();
            return [
              detalhe?.sku ?? '',
              {
                total: Number(detalhe?.total || 0),
                valorLiquido: Number(detalhe?.valorLiquido || 0),
                usuarios: mapaUsuarios,
              },
            ];
          }),
        );
      };

      const encontrarDetalhesUsuario = (mapa, referencia) => {
        const referenciaNormalizada = normalizarTexto(referencia);
        for (const [nome, dados] of mapa.entries()) {
          if (normalizarTexto(nome) === referenciaNormalizada) {
            return { nome, dados };
          }
        }
        return null;
      };

      const mapaParafusos = (item) =>
        new Map(
          Array.isArray(item.parafusosPorSku)
            ? item.parafusosPorSku
            : [],
        );

      return produtosVendidosResumo
        .map((item) => {
          const todosSkus = Array.isArray(item.todosSkus) ? item.todosSkus : [];
          const possuiSkuCompativel =
            !filtroSkuValor || todosSkus.some((sku) => atendeFiltroSku(sku));
          if (!possuiSkuCompativel) {
            return null;
          }

          const usuariosOriginais = Array.isArray(item.usuarios)
            ? item.usuarios
            : [];
          const usuariosSelecionados = filtroResponsavelValor
            ? usuariosOriginais.filter(
                ([nome]) => normalizarTexto(nome) === filtroResponsavelValor,
              )
            : usuariosOriginais;
          if (filtroResponsavelValor && !usuariosSelecionados.length) {
            return null;
          }

          const detalhesUsuarios = reconstruirDetalhesPorUsuario(item);
          const detalhesSkus = reconstruirDetalhesPorSku(item);

          const acumuladoSkus = new Map();
          const acumuladoUsuarios = new Map();
          let total = 0;
          let valorLiquido = 0;

          const adicionarVenda = (sku, quantidade, valor, nomeUsuario) => {
            const qtdNumero = Number(quantidade || 0);
            if (!sku || !Number.isFinite(qtdNumero) || qtdNumero <= 0) {
              return;
            }
            if (!atendeFiltroSku(sku)) {
              return;
            }
            const valorNumero = Number(valor || 0);
            total += qtdNumero;
            valorLiquido += Number.isFinite(valorNumero) ? valorNumero : 0;
            acumuladoSkus.set(
              sku,
              (acumuladoSkus.get(sku) || 0) + qtdNumero,
            );
            if (nomeUsuario) {
              acumuladoUsuarios.set(
                nomeUsuario,
                (acumuladoUsuarios.get(nomeUsuario) || 0) + qtdNumero,
              );
            }
          };

          if (filtroResponsavelValor) {
            usuariosSelecionados.forEach(([nomeReferencia]) => {
              const encontrado = encontrarDetalhesUsuario(
                detalhesUsuarios,
                nomeReferencia,
              );
              if (!encontrado) return;
              const { nome, dados } = encontrado;
              if (!(dados.skus instanceof Map)) return;
              dados.skus.forEach((info, sku) => {
                adicionarVenda(
                  sku,
                  info?.total,
                  info?.valorLiquido,
                  nome,
                );
              });
            });
          } else {
            detalhesSkus.forEach((dadosSku, sku) => {
              adicionarVenda(sku, dadosSku?.total, dadosSku?.valorLiquido);
              if (!(dadosSku.usuarios instanceof Map)) return;
              dadosSku.usuarios.forEach((infoUsuario, nomeUsuario) => {
                const qtdUsuario = Number(infoUsuario?.total || 0);
                if (!Number.isFinite(qtdUsuario) || qtdUsuario <= 0) {
                  return;
                }
                if (!atendeFiltroSku(sku)) {
                  return;
                }
                acumuladoUsuarios.set(
                  nomeUsuario,
                  (acumuladoUsuarios.get(nomeUsuario) || 0) + qtdUsuario,
                );
              });
            });
          }

          if (!total) {
            return null;
          }

          const vendidosPorSkuOrdenados = [];
          const skusAdicionados = new Set();
          const vendidosOriginais = Array.isArray(item.vendidosPorSku)
            ? item.vendidosPorSku
            : [];
          vendidosOriginais.forEach(([sku]) => {
            const quantidade = acumuladoSkus.get(sku);
            if (!quantidade || quantidade <= 0) return;
            vendidosPorSkuOrdenados.push([sku, quantidade]);
            skusAdicionados.add(sku);
          });
          acumuladoSkus.forEach((quantidade, sku) => {
            if (skusAdicionados.has(sku)) return;
            if (!quantidade || quantidade <= 0) return;
            vendidosPorSkuOrdenados.push([sku, quantidade]);
          });

          const usuariosOrdenados = [];
          const usuariosAdicionados = new Set();
          usuariosOriginais.forEach(([nome]) => {
            const quantidade = acumuladoUsuarios.get(nome);
            if (!quantidade || quantidade <= 0) return;
            usuariosOrdenados.push([nome, quantidade]);
            usuariosAdicionados.add(normalizarTexto(nome));
          });
          acumuladoUsuarios.forEach((quantidade, nome) => {
            if (!quantidade || quantidade <= 0) return;
            const normalizado = normalizarTexto(nome);
            if (usuariosAdicionados.has(normalizado)) return;
            usuariosOrdenados.push([nome, quantidade]);
          });

          const principaisDetalhesOriginais = Array.isArray(
            item.principaisVinculadosDetalhes,
          )
            ? item.principaisVinculadosDetalhes
            : [];
          const mapaParafusosItem = mapaParafusos(item);
          const principaisDetalhes = [];
          const principaisAdicionados = new Set();

          principaisDetalhesOriginais.forEach((detalhe) => {
            const quantidade = acumuladoSkus.get(detalhe?.sku);
            if (!quantidade || quantidade <= 0) return;
            if (!atendeFiltroSku(detalhe?.sku)) return;
            principaisDetalhes.push({
              ...detalhe,
              quantidade,
            });
            principaisAdicionados.add(detalhe?.sku);
          });

          acumuladoSkus.forEach((quantidade, sku) => {
            if (!quantidade || quantidade <= 0) return;
            if (!atendeFiltroSku(sku)) return;
            if (principaisAdicionados.has(sku)) return;
            principaisDetalhes.push({
              sku,
              quantidade,
              parafusos: mapaParafusosItem.get(sku),
            });
          });

          return {
            ...item,
            total,
            valorLiquido,
            vendidosPorSku: vendidosPorSkuOrdenados,
            usuarios: usuariosOrdenados,
            principaisVinculadosDetalhes: principaisDetalhes,
          };
        })
        .filter(Boolean);
    }

    function popularFiltroResponsavelProdutosVendidos() {
      const select = document.getElementById(
        'filtroResponsavelProdutosVendidos',
      );
      if (!select) return;

      const valorAtual = select.value || '';
      const nomes = new Set();

      produtosVendidosResumo.forEach((item) => {
        if (!Array.isArray(item.usuarios)) return;
        item.usuarios.forEach(([nome]) => {
          const nomeLimpo = String(nome || '').trim();
          if (nomeLimpo) nomes.add(nomeLimpo);
        });
      });

      const nomesOrdenados = Array.from(nomes).sort((a, b) =>
        a.localeCompare(b, 'pt-BR'),
      );

      select.innerHTML = '';

      const opcaoTodos = document.createElement('option');
      opcaoTodos.value = '';
      opcaoTodos.textContent = 'Todos os responsáveis';
      select.appendChild(opcaoTodos);

      nomesOrdenados.forEach((nome) => {
        const opt = document.createElement('option');
        opt.value = nome;
        opt.textContent = nome;
        select.appendChild(opt);
      });

      if (valorAtual && nomes.has(valorAtual)) {
        select.value = valorAtual;
      } else {
        select.value = '';
      }

      if (!select.dataset.listenerAdded) {
        select.addEventListener('change', renderProdutosVendidos);
        select.dataset.listenerAdded = 'true';
      }
    }

    function renderProdutosVendidos() {
      const tabela = document.getElementById('produtosVendidosTabela');
      if (!tabela) return;

      const formatCurrency = (valor) =>
        Number(valor || 0).toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL',
        });
      const normalizarQuantidadeParafusos = (valor) => {
        if (valor === undefined || valor === null) return null;
        const numero = Number(valor);
        return Number.isFinite(numero) ? numero : null;
      };
      const formatarQuantidadeParafusos = (valor) => {
        const numero = normalizarQuantidadeParafusos(valor);
        return numero === null ? null : numero.toLocaleString('pt-BR');
      };

      const filtroSku = obterFiltroSkuProdutosVendidosValor();
      const filtroResponsavel =
        obterFiltroResponsavelProdutosVendidosValor();
      const statusEl = document.getElementById('produtosVendidosStatus');
      const totalEl = document.getElementById('produtosVendidosTotalUnidades');
      const totalLiquidoEl = document.getElementById(
        'produtosVendidosTotalLiquido',
      );
      const totalParafusosEl = document.getElementById(
        'produtosVendidosTotalParafusos',
      );

      resetPrevisaoProdutosVendidos();

      const dadosFiltrados = obterProdutosVendidosFiltrados();

      if (!dadosFiltrados.length) {
        tabela.innerHTML =
          '<tr><td colspan="4" class="py-6 text-center text-gray-500">Nenhum SKU encontrado.</td></tr>';
        if (statusEl) {
          if (produtosVendidosResumo.length && (filtroSku || filtroResponsavel)) {
            statusEl.textContent = 'Nenhum SKU corresponde aos filtros aplicados.';
          } else if (produtosVendidosResumo.length) {
            statusEl.textContent =
              'Nenhum dado encontrado para o período selecionado.';
          } else {
            statusEl.textContent = 'Nenhum dado disponível.';
          }
        }
        if (totalEl) totalEl.textContent = '0';
        if (totalLiquidoEl) totalLiquidoEl.textContent = formatCurrency(0);
        if (totalParafusosEl) totalParafusosEl.textContent = '0';
        resetPrevisaoProdutosVendidos();
        return;
      }

      const ordenados = [...dadosFiltrados].sort((a, b) => b.total - a.total);
      let totalParafusosGeral = 0;
      const linhas = ordenados
        .map((item) => {
          const totalFormatado = item.total.toLocaleString('pt-BR');
          const valorLiquidoFormatado = formatCurrency(item.valorLiquido);
          const principaisDetalhes = Array.isArray(
            item.principaisVinculadosDetalhes,
          )
            ? item.principaisVinculadosDetalhes
            : [];
          const mapaParafusos = new Map(
            Array.isArray(item.parafusosPorSku) ? item.parafusosPorSku : [],
          );
          const mapaParafusosNormalizado = new Map();
          mapaParafusos.forEach((valor, chave) => {
            mapaParafusosNormalizado.set(
              String(chave || '').toLowerCase(),
              valor,
            );
          });
          const obterParafusosSku = (sku) => {
            if (!sku) return null;
            const normalizado = String(sku || '').toLowerCase();
            if (mapaParafusosNormalizado.has(normalizado)) {
              return normalizarQuantidadeParafusos(
                mapaParafusosNormalizado.get(normalizado),
              );
            }
            return null;
          };
          const mapaPecas = new Map(
            Array.isArray(item.pecasPorSku) ? item.pecasPorSku : [],
          );
          const mapaPecasNormalizado = new Map();
          mapaPecas.forEach((valor, chave) => {
            mapaPecasNormalizado.set(
              String(chave || '').toLowerCase(),
              Number(valor),
            );
          });
          const obterPecasSku = (sku) => {
            if (!sku) return 1;
            const normalizado = String(sku || '').toLowerCase();
            if (mapaPecasNormalizado.has(normalizado)) {
              const v = mapaPecasNormalizado.get(normalizado);
              return Number.isFinite(v) && v > 0 ? v : 1;
            }
            return 1;
          };
          const mapaComponentes = new Map(
            Array.isArray(item.componentesPorSku) ? item.componentesPorSku : [],
          );
          const mapaComponentesNormalizado = new Map();
          mapaComponentes.forEach((valor, chave) => {
            mapaComponentesNormalizado.set(
              String(chave || '').toLowerCase(),
              Array.isArray(valor) ? valor : [],
            );
          });
          const obterComponentesSku = (sku) => {
            if (!sku) return [];
            const normalizado = String(sku || '').toLowerCase();
            if (mapaComponentesNormalizado.has(normalizado)) {
              return mapaComponentesNormalizado.get(normalizado) || [];
            }
            return [];
          };
          const formatarBadgeComponente = (comp) => {
            const nome = String(comp?.nome || '').trim();
            const qtd = comp?.quantidade;
            const qtdValida = Number.isFinite(Number(qtd)) ? Number(qtd) : null;
            const quantidadeTexto =
              qtdValida === null ? '' : `<span>${qtdValida.toLocaleString('pt-BR')}</span><span>/un.</span>`;
            return `<div class="flex items-center gap-1 text-[10px] font-medium text-indigo-600"><span>${escapeHtml(
              nome,
            )}</span>${quantidadeTexto}</div>`;
          };
          const principalParafusosBruto =
            obterParafusosSku(item.sku) ??
            normalizarQuantidadeParafusos(item.quantidadeParafusosPrincipal);
          const principalParafusosNumero = normalizarQuantidadeParafusos(
            principalParafusosBruto,
          );
          const principalParafusosFormatado = formatarQuantidadeParafusos(
            principalParafusosNumero,
          );
          const principalParafusosHtml =
            principalParafusosFormatado !== null
              ? `<div class="mt-1 flex items-center gap-1 text-xs text-indigo-600"><span>🔩</span><span>${principalParafusosFormatado}</span><span>parafusos/un.</span></div>`
              : '';
          const principalComponentes = obterComponentesSku(item.sku);
          const principalComponentesHtml = principalComponentes.length
            ? `<div class="mt-1 flex flex-wrap gap-2">${principalComponentes
                .map((c) => formatarBadgeComponente(c))
                .join('')}</div>`
            : '';
          let totalParafusosItem = item.vendidosPorSku.reduce(
            (acc, [sku, qtd]) => {
              const quantidade = Number(qtd || 0);
              if (!Number.isFinite(quantidade) || quantidade <= 0) {
                return acc;
              }
              const parafusosPorUnidade =
                obterParafusosSku(sku) ?? principalParafusosNumero;
              const parafusosNormalizados = normalizarQuantidadeParafusos(
                parafusosPorUnidade,
              );
              if (parafusosNormalizados === null) {
                return acc;
              }
              return acc + parafusosNormalizados * quantidade;
            },
            0,
          );
          if (
            (!totalParafusosItem || totalParafusosItem <= 0) &&
            principalParafusosNumero !== null
          ) {
            const quantidadeTotal = Number(item.total || 0);
            if (Number.isFinite(quantidadeTotal) && quantidadeTotal > 0) {
              totalParafusosItem =
                principalParafusosNumero * quantidadeTotal;
            }
          }
          if (totalParafusosItem > 0) {
            totalParafusosGeral += totalParafusosItem;
          }
          const totalParafusosFormatado =
            totalParafusosItem > 0
              ? totalParafusosItem.toLocaleString('pt-BR')
              : null;
          const totalParafusosHtml = totalParafusosFormatado
            ? `<div class="flex items-center justify-center gap-1 text-xs font-medium text-indigo-600"><span>🔩</span><span>${totalParafusosFormatado}</span><span>parafusos</span></div>`
            : '';

          // Total de peças agregadas (peças/un. * vendas)
          const principalPecasNumero = (() => {
            const v = obterPecasSku(item.sku);
            return Number.isFinite(Number(v)) && Number(v) > 0 ? Number(v) : 1;
          })();
          let totalPecasItem = item.vendidosPorSku.reduce((acc, [sku, qtd]) => {
            const quantidade = Number(qtd || 0);
            if (!Number.isFinite(quantidade) || quantidade <= 0) return acc;
            const pecasPorUnidade = obterPecasSku(sku) || principalPecasNumero;
            const porUn = Number(pecasPorUnidade);
            const pecasValidas = Number.isFinite(porUn) && porUn > 0 ? porUn : 1;
            return acc + pecasValidas * quantidade;
          }, 0);
          if (!totalPecasItem || totalPecasItem <= 0) {
            const quantidadeTotal = Number(item.total || 0);
            const pecasPrincipal = principalPecasNumero;
            if (
              Number.isFinite(quantidadeTotal) &&
              quantidadeTotal > 0 &&
              Number.isFinite(Number(pecasPrincipal))
            ) {
              totalPecasItem = Number(pecasPrincipal) * quantidadeTotal;
            }
          }
          const totalPecasHtml =
            totalPecasItem > 0
              ? `<div class=\"flex items-center justify-center gap-1 text-xs font-medium text-indigo-600\"><span>🧩</span><span>${totalPecasItem.toLocaleString(
                  'pt-BR',
                )}</span><span>peças</span></div>`
              : '';

          // Agregar componentes (Fiação, Bocal, etc.) multiplicando pelas vendas
          const somarNoMapa = (mapa, nome, valor) => {
            const chave = String(nome || '').trim();
            const qtd = Number(valor || 0);
            if (!chave || !Number.isFinite(qtd) || qtd <= 0) return;
            mapa.set(chave, (mapa.get(chave) || 0) + qtd);
          };
          const obterQuantidadeValida = (valor) => {
            const n = Number(valor);
            return Number.isFinite(n) && n > 0 ? n : null;
          };
          const totaisComponentesMapa = new Map();
          item.vendidosPorSku.forEach(([sku, qtd]) => {
            const quantidade = Number(qtd || 0);
            if (!Number.isFinite(quantidade) || quantidade <= 0) return;
            const comps = obterComponentesSku(sku);
            comps.forEach((c) => {
              const porUnidade = obterQuantidadeValida(c?.quantidade);
              if (porUnidade === null) return;
              somarNoMapa(totaisComponentesMapa, c.nome, porUnidade * quantidade);
            });
          });
          // Fallback caso não haja componentes por SKU: usar os do principal
          if (totaisComponentesMapa.size === 0) {
            const quantidadeTotal = Number(item.total || 0);
            const compsPrincipal = obterComponentesSku(item.sku);
            if (Number.isFinite(quantidadeTotal) && quantidadeTotal > 0) {
              compsPrincipal.forEach((c) => {
                const porUnidade = obterQuantidadeValida(c?.quantidade);
                if (porUnidade === null) return;
                somarNoMapa(
                  totaisComponentesMapa,
                  c.nome,
                  porUnidade * quantidadeTotal,
                );
              });
            }
          }
          const totalComponentesHtml =
            totaisComponentesMapa.size > 0
              ? `<div class="flex flex-wrap justify-center gap-1 text-xs font-medium text-indigo-600">${Array.from(
                  totaisComponentesMapa.entries(),
                )
                  .map(
                    ([nome, qtd]) =>
                      `<span class=\"inline-flex items-center gap-1 rounded-full bg-indigo-50 px-1.5 py-0.5\"><span>${escapeHtml(
                        nome,
                      )}</span><span>${Number(qtd).toLocaleString('pt-BR')}</span></span>`,
                  )
                  .join('')}</div>`
              : '';
          const possuiPrincipais = principaisDetalhes.length > 0;
          let vendidosHtml = '';
          let extrasHtml = '';

          if (possuiPrincipais) {
            const linhasPrincipais = principaisDetalhes
              .map(({ sku, quantidade, parafusos, componentes }) => {
                const quantidadeFormatada = Number(quantidade || 0).toLocaleString(
                  'pt-BR',
                );
                const parafusosNormalizado =
                  obterParafusosSku(sku) ??
                  normalizarQuantidadeParafusos(parafusos);
                const parafusosFormatado = formatarQuantidadeParafusos(
                  parafusosNormalizado,
                );
                const parafusosHtml =
                  parafusosFormatado !== null
                    ? `<div class="flex items-center gap-1 text-[10px] font-medium text-indigo-600"><span>🔩</span><span>${parafusosFormatado}</span><span>parafusos/un.</span></div>`
                    : '';
                const comps = Array.isArray(componentes) && componentes.length
                  ? componentes
                  : obterComponentesSku(sku);
                const componentesHtml = comps.length
                  ? `<div class="flex flex-wrap gap-1">${comps
                      .map((c) => formatarBadgeComponente(c))
                      .join('')}</div>`
                  : '';
                return `<div class="flex flex-col gap-1 rounded-lg bg-indigo-50 px-2 py-1 text-[11px] text-indigo-700"><div class="flex items-center justify-between gap-2"><span class="font-medium">${escapeHtml(
                  sku,
                )}</span><span class="font-semibold text-gray-600">${quantidadeFormatada}</span></div>${parafusosHtml}${componentesHtml}</div>`;
              })
              .join('');
            vendidosHtml = `
              <div class="mt-2 text-xs text-gray-500">
                <div class="font-medium text-gray-600">Principais vinculados</div>
                <div class="mt-1 space-y-1">${linhasPrincipais}</div>
              </div>
            `.trim();
          } else {
            const vendidosChips = item.vendidosPorSku
              .map(([sku, qtd]) => {
                const parafusosFormatado = formatarQuantidadeParafusos(
                  obterParafusosSku(sku),
                );
                const parafusosBadge =
                  parafusosFormatado !== null
                    ? `<span class="inline-flex items-center gap-1 rounded-full bg-white/70 px-1.5 py-0.5 text-[10px] font-medium text-indigo-600"><span>🔩</span><span>${parafusosFormatado}</span></span>`
                    : '';
                const comps = obterComponentesSku(sku);
                const componentesBadges = comps.length
                  ? `<span class="inline-flex flex-wrap gap-1">${comps
                      .map(
                        (c) =>
                          `<span class=\"inline-flex items-center gap-1 rounded-full bg-white/70 px-1.5 py-0.5 text-[10px] font-medium text-indigo-600\">${formatarBadgeComponente(
                            c,
                          )}</span>`,
                      )
                      .join('')}</span>`
                  : '';
                return `<span class="inline-flex flex-col gap-1 rounded-lg bg-indigo-50 px-2 py-1 text-xs text-indigo-700"><span class="flex items-center justify-between gap-2"><span>${escapeHtml(
                  sku,
                )}</span><span class="font-semibold text-gray-600">${qtd.toLocaleString(
                  'pt-BR',
                )}</span></span>${parafusosBadge}${componentesBadges}</span>`;
              })
              .join('');
            vendidosHtml = vendidosChips
              ? `<div class="mt-2 flex flex-wrap gap-2">${vendidosChips}</div>`
              : '';
            const extrasLista = item.grupoCompleto
              .filter(
                (skuExtra) =>
                  !item.vendidosPorSku.some(
                    ([skuVend]) =>
                      skuVend.toLowerCase() === skuExtra.toLowerCase(),
                  ),
              )
              .map((skuExtra) => {
                const parafusosFormatado = formatarQuantidadeParafusos(
                  obterParafusosSku(skuExtra),
                );
                const parafusosTexto =
                  parafusosFormatado !== null
                    ? ` (🔩 ${parafusosFormatado})`
                    : '';
                const comps = obterComponentesSku(skuExtra);
                const compsTexto = comps.length
                  ? ` (${comps
                      .map((c) =>
                        `${escapeHtml(c.nome)}${
                          Number.isFinite(Number(c.quantidade))
                            ? ' ' + Number(c.quantidade).toLocaleString('pt-BR') + '/un.'
                            : ''
                        }`,
                      )
                      .join(', ')})`
                  : '';
                return `${escapeHtml(skuExtra)}${parafusosTexto}${compsTexto}`;
              });
            extrasHtml = extrasLista.length
              ? `<div class="mt-1 text-xs text-gray-400">Associados: ${extrasLista.join(
                  ', ',
                )}</div>`
              : '';
          }
          const detalhesHtml = (vendidosHtml || extrasHtml)
            ? `<div class="pv-detalhes mt-2 hidden">${vendidosHtml}${extrasHtml}</div>`
            : '';
          const usuariosTexto = item.usuarios
            .map(([nome, qtd]) =>
              `${escapeHtml(nome)} (${qtd.toLocaleString('pt-BR')})`,
            )
            .join('<br>');
          return `
            <tr class="divide-x divide-gray-100">
              <td class="py-3 px-4 font-semibold text-gray-700">
                <div>${escapeHtml(item.sku)}</div>
                ${principalParafusosHtml}
                ${principalComponentesHtml}
                ${detalhesHtml}
              </td>
              <td class="py-3 px-4 text-center font-medium text-gray-800">
                <div class="flex flex-col items-center gap-1">
                  <span>${totalFormatado}</span>
                  ${totalParafusosHtml}
                  ${totalPecasHtml}
                  ${totalComponentesHtml}
                </div>
              </td>
              <td class="py-3 px-4 text-right font-medium text-gray-800">${valorLiquidoFormatado}</td>
              <td class="py-3 px-4 text-sm text-gray-600 leading-5">
                ${usuariosTexto || '<span class="text-gray-400">-</span>'}
                <div class="mt-2 text-right">
                  <button type="button" class="pv-toggle text-xs font-semibold text-gray-800 hover:text-indigo-700" data-sku="${escapeHtml(
                    item.sku,
                  )}">VER MAIS</button>
                </div>
              </td>
            </tr>`;
        })
        .join('');

      tabela.innerHTML = linhas;

      // Delegação de eventos para expandir/colapsar detalhes
      if (!tabela.dataset.toggleListener) {
        tabela.addEventListener('click', (e) => {
          const btn = e.target.closest('.pv-toggle');
          if (!btn) return;
          const row = btn.closest('tr');
          if (!row) return;
          const detalhes = row.querySelector('.pv-detalhes');
          if (!detalhes) return;
          const isHidden = detalhes.classList.contains('hidden');
          if (isHidden) {
            detalhes.classList.remove('hidden');
            btn.textContent = 'VER MENOS';
          } else {
            detalhes.classList.add('hidden');
            btn.textContent = 'VER MAIS';
          }
        });
        tabela.dataset.toggleListener = 'true';
      }

      if (statusEl) {
        statusEl.textContent = `${ordenados.length} SKU${
          ordenados.length > 1 ? 's' : ''
        } encontrados.`;
      }
      if (totalEl) {
        const total = ordenados.reduce((acc, item) => acc + item.total, 0);
        totalEl.textContent = total.toLocaleString('pt-BR');
      }
      if (totalLiquidoEl) {
        const totalLiquido = ordenados.reduce(
          (acc, item) => acc + Number(item.valorLiquido || 0),
          0,
        );
        totalLiquidoEl.textContent = formatCurrency(totalLiquido);
      }
      if (totalParafusosEl) {
        totalParafusosEl.textContent = totalParafusosGeral
          ? totalParafusosGeral.toLocaleString('pt-BR')
          : '0';
      }
    }

    async function carregarProdutosVendidos() {
      const tabela = document.getElementById('produtosVendidosTabela');
      const statusEl = document.getElementById('produtosVendidosStatus');
      const totalEl = document.getElementById('produtosVendidosTotalUnidades');
      const totalLiquidoEl = document.getElementById(
        'produtosVendidosTotalLiquido',
      );
      const totalParafusosEl = document.getElementById(
        'produtosVendidosTotalParafusos',
      );
      const botaoFiltrar = document.getElementById('btnProdutosVendidosFiltrar');

      if (produtosVendidosCarregando) {
        if (statusEl) {
          statusEl.textContent =
            'Já existe um carregamento em andamento. Aguarde a finalização.';
        }
        return;
      }

      produtosVendidosCarregando = true;

      if (botaoFiltrar) {
        if (!botaoFiltrar.dataset.originalHtml) {
          botaoFiltrar.dataset.originalHtml = botaoFiltrar.innerHTML;
        }
        botaoFiltrar.disabled = true;
        botaoFiltrar.classList.add('opacity-70', 'cursor-not-allowed');
        botaoFiltrar.innerHTML =
          '<i class="fas fa-spinner fa-spin mr-2"></i>Carregando';
      }

      try {
        produtosVendidosResumo = [];
        produtosVendidosCarregado = false;
        resetPrevisaoProdutosVendidos();
        popularFiltroResponsavelProdutosVendidos();

        if (tabela) {
          tabela.innerHTML =
            '<tr><td colspan="4" class="py-6 text-center text-gray-500">Carregando...</td></tr>';
        }
        if (statusEl) {
          statusEl.textContent = 'Carregando dados de produtos vendidos...';
        }
        if (totalEl) totalEl.textContent = '0';
        if (totalLiquidoEl)
          totalLiquidoEl.textContent = Number(0).toLocaleString('pt-BR', {
            style: 'currency',
            currency: 'BRL',
          });
        if (totalParafusosEl) totalParafusosEl.textContent = '0';

        const inicioInput = document.getElementById(
          'filtroProdutosVendidosInicio',
        );
        const fimInput = document.getElementById('filtroProdutosVendidosFim');
        const hoje = new Date();
        const ano = hoje.getFullYear();
        const mes = String(hoje.getMonth() + 1).padStart(2, '0');
        const dia = String(hoje.getDate()).padStart(2, '0');
        const primeiroDiaMes = `${ano}-${mes}-01`;
        const hojeIso = `${ano}-${mes}-${dia}`;

        if (inicioInput && !inicioInput.value)
          inicioInput.value = primeiroDiaMes;
        if (fimInput && !fimInput.value) fimInput.value = hojeIso;

        const dataInicio = inicioInput?.value || null;
        const dataFim = fimInput?.value || null;
        if (dataInicio && dataFim && dataInicio > dataFim) {
          if (statusEl)
            statusEl.textContent =
              'Período inválido: a data inicial é maior que a final.';
          if (tabela)
            tabela.innerHTML =
              '<tr><td colspan="4" class="py-6 text-center text-red-500">Ajuste o período selecionado.</td></tr>';
          return;
        }

        const responsavelEmail = (usuarioLogado.email || '').trim();
        if (!responsavelEmail) {
          if (statusEl)
            statusEl.textContent =
              'Não foi possível identificar o responsável financeiro.';
          if (tabela)
            tabela.innerHTML =
              '<tr><td colspan="4" class="py-6 text-center text-gray-500">Usuário não autenticado.</td></tr>';
          return;
        }

        const usuariosMap = new Map();
        const usuariosSnap = await db
          .collection('usuarios')
          .where('responsavelFinanceiroEmail', '==', responsavelEmail)
          .get();
        usuariosSnap.forEach((doc) => {
          const dados = doc.data() || {};
          usuariosMap.set(doc.id, {
            nome: dados.nome || dados.email || doc.id,
            email: dados.email || '',
          });
        });

        const uidSnap = await db
          .collection('uid')
          .where('responsavelFinanceiroEmail', '==', responsavelEmail)
          .get();
        uidSnap.forEach((doc) => {
          if (!usuariosMap.has(doc.id)) {
            const dados = doc.data() || {};
            usuariosMap.set(doc.id, {
              nome: dados.nome || dados.email || doc.id,
              email: dados.email || '',
            });
          }
        });

        if (!usuariosMap.size) {
          if (statusEl)
            statusEl.textContent =
              'Nenhum usuário associado a este responsável financeiro.';
          if (tabela)
            tabela.innerHTML =
              '<tr><td colspan="4" class="py-6 text-center text-gray-500">Sem usuários vinculados.</td></tr>';
          return;
        }

        const normalizarSku = (valor) =>
          String(valor || '')
            .trim()
            .toUpperCase();
        const sanitizarQuantidadeParafusos = (valor) => {
          if (valor === undefined || valor === null || valor === '') return null;
          if (typeof valor === 'number' && Number.isFinite(valor)) return valor;
          const texto = String(valor).trim().replace(',', '.');
          if (!texto) return null;
          const numero = Number(texto);
          return Number.isFinite(numero) ? numero : null;
        };
        const principalPorSku = new Map();
        const principalOriginalPorSku = new Map();
        const grupoPorPrincipal = new Map();
        const grupoNormalizadoPorPrincipal = new Map();
        const principaisVinculadosPendentes = [];
        const principaisVinculadosPorPrincipal = new Map();
        const parafusosPorPrincipal = new Map();
        const parafusosPorSkuNormalizado = new Map();
        const componentesPorPrincipal = new Map();
        const componentesPorSkuNormalizado = new Map();
        const pecasPorPrincipal = new Map();
        const pecasPorSkuNormalizado = new Map();
        const compostosPorPrincipal = new Map();
        const compostosPorSkuNormalizado = new Map();
        const normalizarComponentesListaLocal = (componentes) => {
          if (!Array.isArray(componentes)) return [];
          return componentes
            .map((comp) => {
              if (!comp || typeof comp !== 'object') return null;
              const nome = String(comp.nome || comp.descricao || '').trim();
              if (!nome) return null;
              const numero = Number(comp.quantidade);
              const quantidade = Number.isFinite(numero) ? numero : null;
              return { nome, quantidade };
            })
            .filter(Boolean);
        };
        try {
          const associadosSnap = await db.collection('skuAssociado').get();
          associadosSnap.forEach((doc) => {
            const dados = doc.data() || {};
            const escopo = String(dados.escopo || '').toLowerCase();
            if (dados.apenasVts === true || escopo === 'vts') {
              return;
            }
            const skuPrincipal = String(
              dados.skuPrincipal || doc.id || '',
            ).trim();
            if (!skuPrincipal) return;
            const principalNormalizado = normalizarSku(skuPrincipal);
            const quantidadeParafusos = sanitizarQuantidadeParafusos(
              dados.quantidadeParafusos,
            );
            const componentesLista = normalizarComponentesListaLocal(
              dados.componentes,
            );
            const quantidadePecas = Number(dados.quantidadePecas);
            const compostosLista = Array.isArray(dados.compostos)
              ? dados.compostos
                  .map((c) => ({ sku: String(c?.sku || '').trim(), quantidade: Number(c?.quantidade) }))
                  .filter((c) => c.sku)
              : [];
            principalPorSku.set(principalNormalizado, skuPrincipal);
            const grupoAtual = grupoPorPrincipal.get(skuPrincipal) || new Set();
            const vinculadosAtuais =
              principaisVinculadosPorPrincipal.get(skuPrincipal) || new Set();
            grupoAtual.add(skuPrincipal);
            principalOriginalPorSku.set(principalNormalizado, skuPrincipal);
            if (quantidadeParafusos !== null) {
              parafusosPorPrincipal.set(skuPrincipal, quantidadeParafusos);
              parafusosPorSkuNormalizado.set(
                principalNormalizado,
                quantidadeParafusos,
              );
            }
            if (Number.isFinite(quantidadePecas)) {
              pecasPorPrincipal.set(skuPrincipal, quantidadePecas);
              pecasPorSkuNormalizado.set(
                principalNormalizado,
                quantidadePecas,
              );
            }
            if (componentesLista.length) {
              componentesPorPrincipal.set(skuPrincipal, componentesLista);
              componentesPorSkuNormalizado.set(
                principalNormalizado,
                componentesLista,
              );
            }
            if (compostosLista.length) {
              compostosPorPrincipal.set(skuPrincipal, compostosLista);
              compostosPorSkuNormalizado.set(principalNormalizado, compostosLista);
            }
            (dados.associados || []).forEach((skuAssoc) => {
              const associado = String(skuAssoc || '').trim();
              if (!associado) return;
              principalPorSku.set(normalizarSku(associado), skuPrincipal);
              grupoAtual.add(associado);
              principalOriginalPorSku.set(
                normalizarSku(associado),
                skuPrincipal,
              );
              if (quantidadeParafusos !== null) {
                parafusosPorSkuNormalizado.set(
                  normalizarSku(associado),
                  quantidadeParafusos,
                );
              }
              if (Number.isFinite(quantidadePecas)) {
                pecasPorSkuNormalizado.set(
                  normalizarSku(associado),
                  quantidadePecas,
                );
              }
              if (componentesLista.length) {
                componentesPorSkuNormalizado.set(
                  normalizarSku(associado),
                  componentesLista,
                );
              }
              if (compostosLista.length) {
                compostosPorSkuNormalizado.set(
                  normalizarSku(associado),
                  compostosLista,
                );
              }
            });

            (dados.principaisVinculados || []).forEach((skuPrincipalVinc) => {
              const principalVinculado = String(skuPrincipalVinc || '').trim();
              if (!principalVinculado) return;
              grupoAtual.add(principalVinculado);
              vinculadosAtuais.add(principalVinculado);
              principalOriginalPorSku.set(
                normalizarSku(principalVinculado),
                principalVinculado,
              );
              if (quantidadeParafusos !== null) {
                parafusosPorSkuNormalizado.set(
                  normalizarSku(principalVinculado),
                  quantidadeParafusos,
                );
              }
              principaisVinculadosPendentes.push({
                origem: skuPrincipal,
                vinculado: principalVinculado,
              });
            });

            grupoPorPrincipal.set(skuPrincipal, grupoAtual);
            principaisVinculadosPorPrincipal.set(
              skuPrincipal,
              vinculadosAtuais,
            );
          });
        } catch (assErr) {
          console.error('Erro ao carregar SKUs associados', assErr);
        }

        if (principaisVinculadosPendentes.length) {
          let houveAlteracao = true;
          while (houveAlteracao) {
            houveAlteracao = false;
            for (const relacionamento of principaisVinculadosPendentes) {
              const { origem, vinculado } = relacionamento;
              const grupoOrigem = grupoPorPrincipal.get(origem);
              if (!grupoOrigem) continue;

              const setPrincipaisOrigem =
                principaisVinculadosPorPrincipal.get(origem) || new Set();
              if (!principaisVinculadosPorPrincipal.has(origem)) {
                principaisVinculadosPorPrincipal.set(origem, setPrincipaisOrigem);
              }

              if (!grupoOrigem.has(vinculado)) {
                grupoOrigem.add(vinculado);
                houveAlteracao = true;
              }

              const normalizadoVinculado = normalizarSku(vinculado);
              const principalAtual = principalPorSku.get(normalizadoVinculado);
              if (principalAtual !== origem) {
                principalPorSku.set(normalizadoVinculado, origem);
                houveAlteracao = true;
              }

              const grupoVinculado = grupoPorPrincipal.get(vinculado);
              if (grupoVinculado && grupoVinculado !== grupoOrigem) {
                grupoVinculado.forEach((skuItem) => {
                  const jaPossui = grupoOrigem.has(skuItem);
                  grupoOrigem.add(skuItem);
                  const normalizadoItem = normalizarSku(skuItem);
                  if (principalPorSku.get(normalizadoItem) !== origem) {
                    principalPorSku.set(normalizadoItem, origem);
                  }
                  if (!jaPossui) houveAlteracao = true;
                });
                grupoPorPrincipal.set(vinculado, grupoOrigem);
              } else if (!grupoVinculado) {
                grupoPorPrincipal.set(vinculado, grupoOrigem);
              }

              const setPrincipaisVinculado =
                principaisVinculadosPorPrincipal.get(vinculado);
              if (setPrincipaisVinculado && setPrincipaisVinculado !== setPrincipaisOrigem) {
                const tamanhoAntes = setPrincipaisOrigem.size;
                setPrincipaisVinculado.forEach((sku) =>
                  setPrincipaisOrigem.add(sku),
                );
                if (setPrincipaisOrigem.size !== tamanhoAntes) {
                  houveAlteracao = true;
                }
              }

              if (!setPrincipaisOrigem.has(vinculado)) {
                setPrincipaisOrigem.add(vinculado);
                houveAlteracao = true;
              }

              principaisVinculadosPorPrincipal.set(origem, setPrincipaisOrigem);
              principaisVinculadosPorPrincipal.set(vinculado, setPrincipaisOrigem);
            }
          }
        }

        grupoPorPrincipal.forEach((grupoSet, principalChave) => {
          const setNormalizado = new Set();
          grupoSet.forEach((skuItem) => {
            setNormalizado.add(normalizarSku(skuItem));
          });
          grupoNormalizadoPorPrincipal.set(principalChave, setNormalizado);
          grupoNormalizadoPorPrincipal.set(
            normalizarSku(principalChave),
            setNormalizado,
          );
        });

        const obterQuantidadeParafusosDoSku = (sku) => {
          if (!sku) return null;
          const normalizado = normalizarSku(sku);
          if (parafusosPorSkuNormalizado.has(normalizado)) {
            const valor = parafusosPorSkuNormalizado.get(normalizado);
            return Number.isFinite(valor) ? valor : null;
          }
          if (parafusosPorPrincipal.has(sku)) {
            const valor = parafusosPorPrincipal.get(sku);
            return Number.isFinite(valor) ? valor : null;
          }
          const principalRelacionado = principalPorSku.get(normalizado);
          if (
            principalRelacionado &&
            parafusosPorPrincipal.has(principalRelacionado)
          ) {
            const valor = parafusosPorPrincipal.get(principalRelacionado);
            return Number.isFinite(valor) ? valor : null;
          }
          return null;
        };

        const obterQuantidadePecasDoSku = (sku) => {
          if (!sku) return 1;
          const normalizado = normalizarSku(sku);
          if (pecasPorSkuNormalizado.has(normalizado)) {
            const valor = pecasPorSkuNormalizado.get(normalizado);
            return Number.isFinite(valor) && valor > 0 ? valor : 1;
          }
          if (pecasPorPrincipal.has(sku)) {
            const valor = pecasPorPrincipal.get(sku);
            return Number.isFinite(valor) && valor > 0 ? valor : 1;
          }
          const principalRelacionado = principalPorSku.get(normalizado);
          if (
            principalRelacionado &&
            pecasPorPrincipal.has(principalRelacionado)
          ) {
            const valor = pecasPorPrincipal.get(principalRelacionado);
            return Number.isFinite(valor) && valor > 0 ? valor : 1;
          }
          return 1;
        };

        const obterComponentesDoSku = (sku) => {
          if (!sku) return [];
          const normalizado = normalizarSku(sku);
          if (componentesPorSkuNormalizado.has(normalizado)) {
            return componentesPorSkuNormalizado.get(normalizado) || [];
          }
          if (componentesPorPrincipal.has(sku)) {
            return componentesPorPrincipal.get(sku) || [];
          }
          const principalRelacionado = principalPorSku.get(normalizado);
          if (
            principalRelacionado &&
            componentesPorPrincipal.has(principalRelacionado)
          ) {
            return componentesPorPrincipal.get(principalRelacionado) || [];
          }
          return [];
        };

        const obterCompostosDoSku = (sku) => {
          if (!sku) return [];
          const normalizado = normalizarSku(sku);
          if (compostosPorSkuNormalizado.has(normalizado)) {
            return compostosPorSkuNormalizado.get(normalizado) || [];
          }
          if (compostosPorPrincipal.has(sku)) {
            return compostosPorPrincipal.get(sku) || [];
          }
          const principalRelacionado = principalPorSku.get(normalizado);
          if (principalRelacionado && compostosPorPrincipal.has(principalRelacionado)) {
            return compostosPorPrincipal.get(principalRelacionado) || [];
          }
          return [];
        };

        const agregados = new Map();
        for (const [uid, info] of usuariosMap.entries()) {
          try {
            const vendasSnap = await db
              .collection('uid')
              .doc(uid)
              .collection('skusVendidos')
              .get();

            const docsFiltrados = vendasSnap.docs.filter((docDia) => {
              const dataDoc = docDia.id || '';
              if (dataInicio && dataDoc && dataDoc < dataInicio) return false;
              if (dataFim && dataDoc && dataDoc > dataFim) return false;
              return true;
            });

            const listasResultado = await Promise.all(
              docsFiltrados.map(async (docDia) => {
                try {
                  const listaSnap = await docDia.ref.collection('lista').get();
                  return { docDia, listaSnap };
                } catch (listaErr) {
                  console.error(
                    'Erro ao carregar lista de SKUs vendidos',
                    { uid, data: docDia.id },
                    listaErr,
                  );
                  return null;
                }
              }),
            );

            for (const resultadoLista of listasResultado) {
              if (!resultadoLista) continue;
              const { listaSnap } = resultadoLista;
              listaSnap.forEach((itemDoc) => {
                const dados = itemDoc.data() || {};
                const skuOriginal = String(
                  dados.sku || itemDoc.id || '',
                ).trim();
                if (!skuOriginal) return;
                const total = Number(dados.total || 0);
                if (!Number.isFinite(total) || total <= 0) return;
                const valorLiquido = Number(
                  dados.valorLiquido ?? dados.liquido ?? 0,
                );
                const valorLiquidoNumero = Number.isFinite(valorLiquido)
                  ? valorLiquido
                  : 0;

                const principal =
                  principalPorSku.get(normalizarSku(skuOriginal)) ||
                  skuOriginal;
                if (!agregados.has(principal)) {
                  agregados.set(principal, {
                    sku: principal,
                    total: 0,
                    valorLiquido: 0,
                    usuarios: new Map(),
                    vendidosPorSku: new Map(),
                    grupoOficial:
                      grupoPorPrincipal.get(principal) ||
                      new Set([principal]),
                    principaisVinculados:
                      principaisVinculadosPorPrincipal.get(principal) ||
                      new Set(),
                    principaisVinculadosQuantidades: new Map(),
                    parafusosPorSku: new Map(),
                    detalhesPorUsuario: new Map(),
                    detalhesPorSku: new Map(),
                  });
                }

                const registro = agregados.get(principal);
                registro.total += total;
                registro.valorLiquido += valorLiquidoNumero;
                const nomeUsuario = info.nome || info.email || uid;
                registro.usuarios.set(
                  nomeUsuario,
                  (registro.usuarios.get(nomeUsuario) || 0) + total,
                );
                registro.vendidosPorSku.set(
                  skuOriginal,
                  (registro.vendidosPorSku.get(skuOriginal) || 0) + total,
                );

                if (!(registro.detalhesPorUsuario instanceof Map)) {
                  registro.detalhesPorUsuario = new Map(
                    registro.detalhesPorUsuario || [],
                  );
                }
                if (!(registro.detalhesPorSku instanceof Map)) {
                  registro.detalhesPorSku = new Map(
                    registro.detalhesPorSku || [],
                  );
                }

                const detalhesUsuarioAtual = registro.detalhesPorUsuario.get(
                  nomeUsuario,
                );
                const detalhesUsuario = detalhesUsuarioAtual || {
                  total: 0,
                  valorLiquido: 0,
                  skus: new Map(),
                };
                detalhesUsuario.total += total;
                detalhesUsuario.valorLiquido += valorLiquidoNumero;
                if (!(detalhesUsuario.skus instanceof Map)) {
                  detalhesUsuario.skus = new Map(detalhesUsuario.skus || []);
                }
                const detalhesSkuUsuarioAtual = detalhesUsuario.skus.get(
                  skuOriginal,
                );
                const detalhesSkuUsuario = detalhesSkuUsuarioAtual || {
                  total: 0,
                  valorLiquido: 0,
                };
                detalhesSkuUsuario.total += total;
                detalhesSkuUsuario.valorLiquido += valorLiquidoNumero;
                detalhesUsuario.skus.set(skuOriginal, detalhesSkuUsuario);
                registro.detalhesPorUsuario.set(nomeUsuario, detalhesUsuario);

                const detalhesSkuAtual = registro.detalhesPorSku.get(
                  skuOriginal,
                );
                const detalhesSku = detalhesSkuAtual || {
                  total: 0,
                  valorLiquido: 0,
                  usuarios: new Map(),
                };
                detalhesSku.total += total;
                detalhesSku.valorLiquido += valorLiquidoNumero;
                if (!(detalhesSku.usuarios instanceof Map)) {
                  detalhesSku.usuarios = new Map(detalhesSku.usuarios || []);
                }
                const detalhesSkuUsuarioResumoAtual = detalhesSku.usuarios.get(
                  nomeUsuario,
                );
                const detalhesSkuUsuarioResumo =
                  detalhesSkuUsuarioResumoAtual || {
                    total: 0,
                    valorLiquido: 0,
                  };
                detalhesSkuUsuarioResumo.total += total;
                detalhesSkuUsuarioResumo.valorLiquido += valorLiquidoNumero;
                detalhesSku.usuarios.set(nomeUsuario, detalhesSkuUsuarioResumo);
                registro.detalhesPorSku.set(skuOriginal, detalhesSku);

                if (!(registro.parafusosPorSku instanceof Map)) {
                  registro.parafusosPorSku = new Map(
                    registro.parafusosPorSku || [],
                  );
                }
                if (!registro.parafusosPorSku.has(skuOriginal)) {
                  registro.parafusosPorSku.set(
                    skuOriginal,
                    obterQuantidadeParafusosDoSku(skuOriginal),
                  );
                }

                const principaisDoRegistro =
                  registro.principaisVinculados instanceof Set
                    ? registro.principaisVinculados
                    : new Set(registro.principaisVinculados || []);
                if (principaisDoRegistro.size) {
                  const skuNormalizado = normalizarSku(skuOriginal);
                  const mapaQuantidades =
                    registro.principaisVinculadosQuantidades instanceof Map
                      ? registro.principaisVinculadosQuantidades
                      : new Map(
                          registro.principaisVinculadosQuantidades || [],
                        );
                  let principalDestino = null;
                  const principalOriginal = principalOriginalPorSku.get(
                    skuNormalizado,
                  );
                  const principalRegistroNormalizado = normalizarSku(principal);
                  const principalOriginalNormalizado = principalOriginal
                    ? normalizarSku(principalOriginal)
                    : null;
                  if (
                    principalOriginalNormalizado &&
                    principalOriginalNormalizado !== principalRegistroNormalizado
                  ) {
                    principaisDoRegistro.forEach((principalVinculado) => {
                      if (principalDestino) return;
                      if (
                        normalizarSku(principalVinculado) ===
                        principalOriginalNormalizado
                      ) {
                        principalDestino = principalVinculado;
                      }
                    });
                  }
                  if (
                    !principalDestino &&
                    (!principalOriginalNormalizado ||
                      principalOriginalNormalizado !== principalRegistroNormalizado)
                  ) {
                    principaisDoRegistro.forEach((principalVinculado) => {
                      if (principalDestino) return;
                      const grupoNormalizado =
                        grupoNormalizadoPorPrincipal.get(principalVinculado) ||
                        grupoNormalizadoPorPrincipal.get(
                          normalizarSku(principalVinculado),
                        );
                      const principalNormalizado = normalizarSku(
                        principalVinculado,
                      );
                      if (
                        (grupoNormalizado &&
                          grupoNormalizado.has(skuNormalizado)) ||
                        principalNormalizado === skuNormalizado
                      ) {
                        principalDestino = principalVinculado;
                      }
                    });
                  }
                  if (principalDestino) {
                    const acumulado =
                      mapaQuantidades.get(principalDestino) || 0;
                    mapaQuantidades.set(principalDestino, acumulado + total);
                    registro.principaisVinculadosQuantidades = mapaQuantidades;
                  }
                }
              });
            }
          } catch (loopErr) {
            console.error('Erro ao processar vendas do usuário', uid, loopErr);
          }
        }

        agregados.forEach((registro) => {
          const mapaParafusos =
            registro.parafusosPorSku instanceof Map
              ? registro.parafusosPorSku
              : new Map(registro.parafusosPorSku || []);
          const mapaComponentes =
            registro.componentesPorSku instanceof Map
              ? registro.componentesPorSku
              : new Map(registro.componentesPorSku || []);
          const mapaPecas =
            registro.pecasPorSku instanceof Map
              ? registro.pecasPorSku
              : new Map(registro.pecasPorSku || []);
          const grupoOficial =
            registro.grupoOficial instanceof Set
              ? registro.grupoOficial
              : new Set(registro.grupoOficial || []);
          grupoOficial.forEach((sku) => {
            if (!mapaParafusos.has(sku)) {
              mapaParafusos.set(sku, obterQuantidadeParafusosDoSku(sku));
            }
            if (!mapaComponentes.has(sku)) {
              mapaComponentes.set(sku, obterComponentesDoSku(sku));
            }
            if (!mapaPecas.has(sku)) {
              mapaPecas.set(sku, obterQuantidadePecasDoSku(sku));
            }
            if (!(registro.compostosPorSku instanceof Map)) {
              registro.compostosPorSku = new Map(registro.compostosPorSku || []);
            }
            if (!registro.compostosPorSku.has(sku)) {
              registro.compostosPorSku.set(sku, obterCompostosDoSku(sku));
            }
          });
          if (!mapaParafusos.has(registro.sku)) {
            mapaParafusos.set(
              registro.sku,
              obterQuantidadeParafusosDoSku(registro.sku),
            );
          }
          if (!mapaComponentes.has(registro.sku)) {
            mapaComponentes.set(registro.sku, obterComponentesDoSku(registro.sku));
          }
          if (!mapaPecas.has(registro.sku)) {
            mapaPecas.set(registro.sku, obterQuantidadePecasDoSku(registro.sku));
          }
          registro.parafusosPorSku = mapaParafusos;
          registro.componentesPorSku = mapaComponentes;
          registro.pecasPorSku = mapaPecas;
        });

        produtosVendidosResumo = Array.from(agregados.values()).map((item) => {
          const vendidosPorSku = Array.from(item.vendidosPorSku.entries()).sort(
            (a, b) => a[0].localeCompare(b[0], 'pt-BR'),
          );
          const grupoCompleto = Array.from(item.grupoOficial.values()).sort((
            a,
            b,
          ) => a.localeCompare(b, 'pt-BR'));
          const principaisVinculadosFonte =
            item.principaisVinculados instanceof Set
              ? item.principaisVinculados
              : new Set(item.principaisVinculados || []);
          const principaisVinculados = Array.from(
            principaisVinculadosFonte.values(),
          ).sort((a, b) => a.localeCompare(b, 'pt-BR'));
          const mapaQuantidadesPrincipais =
            item.principaisVinculadosQuantidades instanceof Map
              ? item.principaisVinculadosQuantidades
              : new Map(item.principaisVinculadosQuantidades || []);
          const mapaParafusos =
            item.parafusosPorSku instanceof Map
              ? item.parafusosPorSku
              : new Map(item.parafusosPorSku || []);
          const parafusosPorSkuEntries = Array.from(mapaParafusos.entries());
          const quantidadeParafusosPrincipal = mapaParafusos.has(item.sku)
            ? mapaParafusos.get(item.sku)
            : obterQuantidadeParafusosDoSku(item.sku);
          const mapaComponentes =
            item.componentesPorSku instanceof Map
              ? item.componentesPorSku
              : new Map(item.componentesPorSku || []);
          const componentesPorSkuEntries = Array.from(mapaComponentes.entries());
          const mapaCompostos =
            item.compostosPorSku instanceof Map
              ? item.compostosPorSku
              : new Map(item.compostosPorSku || []);
          const compostosPorSkuEntries = Array.from(mapaCompostos.entries());
          const mapaPecas =
            item.pecasPorSku instanceof Map
              ? item.pecasPorSku
              : new Map(item.pecasPorSku || []);
          const pecasPorSkuEntries = Array.from(mapaPecas.entries());
          const principaisVinculadosDetalhes = principaisVinculados.map((sku) => {
            const quantidade = mapaQuantidadesPrincipais.get(sku) || 0;
            const parafusos = mapaParafusos.has(sku)
              ? mapaParafusos.get(sku)
              : obterQuantidadeParafusosDoSku(sku);
            const componentes = mapaComponentes.has(sku)
              ? mapaComponentes.get(sku)
              : obterComponentesDoSku(sku);
            const pecas = mapaPecas.has(sku)
              ? mapaPecas.get(sku)
              : obterQuantidadePecasDoSku(sku);
            return {
              sku,
              quantidade,
              parafusos,
              componentes,
              pecas,
            };
          });
          const todosSkus = Array.from(
            new Set([
              ...grupoCompleto,
              ...vendidosPorSku.map(([sku]) => sku),
              item.sku,
            ]),
          ).sort((a, b) => a.localeCompare(b, 'pt-BR'));

          const converterDetalhesPorUsuario = (origem) => {
            if (origem instanceof Map) {
              return Array.from(origem.entries()).map(([nome, dados]) => ({
                nome,
                total: Number(dados?.total || 0),
                valorLiquido: Number(dados?.valorLiquido || 0),
                skus:
                  dados?.skus instanceof Map
                    ? Array.from(dados.skus.entries()).map(
                        ([skuDetalhe, valores]) => ({
                          sku: skuDetalhe,
                          total: Number(valores?.total || 0),
                          valorLiquido: Number(valores?.valorLiquido || 0),
                        }),
                      )
                    : [],
              }));
            }
            if (Array.isArray(origem)) {
              return origem.map((detalhe) => ({
                nome: detalhe?.nome ?? '',
                total: Number(detalhe?.total || 0),
                valorLiquido: Number(detalhe?.valorLiquido || 0),
                skus: Array.isArray(detalhe?.skus)
                  ? detalhe.skus.map((skuInfo) => ({
                      sku: skuInfo?.sku ?? '',
                      total: Number(skuInfo?.total || 0),
                      valorLiquido: Number(skuInfo?.valorLiquido || 0),
                    }))
                  : [],
              }));
            }
            return [];
          };

          const converterDetalhesPorSku = (origem) => {
            if (origem instanceof Map) {
              return Array.from(origem.entries()).map(([skuDetalhe, dados]) => ({
                sku: skuDetalhe,
                total: Number(dados?.total || 0),
                valorLiquido: Number(dados?.valorLiquido || 0),
                usuarios:
                  dados?.usuarios instanceof Map
                    ? Array.from(dados.usuarios.entries()).map(
                        ([nomeUsuario, valores]) => ({
                          nome: nomeUsuario,
                          total: Number(valores?.total || 0),
                          valorLiquido: Number(valores?.valorLiquido || 0),
                        }),
                      )
                    : [],
              }));
            }
            if (Array.isArray(origem)) {
              return origem.map((detalhe) => ({
                sku: detalhe?.sku ?? '',
                total: Number(detalhe?.total || 0),
                valorLiquido: Number(detalhe?.valorLiquido || 0),
                usuarios: Array.isArray(detalhe?.usuarios)
                  ? detalhe.usuarios.map((usuarioInfo) => ({
                      nome: usuarioInfo?.nome ?? '',
                      total: Number(usuarioInfo?.total || 0),
                      valorLiquido: Number(usuarioInfo?.valorLiquido || 0),
                    }))
                  : [],
              }));
            }
            return [];
          };

          return {
            sku: item.sku,
            total: item.total,
            valorLiquido: item.valorLiquido,
            usuarios: Array.from(item.usuarios.entries()),
            vendidosPorSku,
            grupoCompleto,
            todosSkus,
            principaisVinculados,
            principaisVinculadosDetalhes,
            quantidadeParafusosPrincipal,
            parafusosPorSku: parafusosPorSkuEntries,
            componentesPorSku: componentesPorSkuEntries,
            compostosPorSku: compostosPorSkuEntries,
            pecasPorSku: pecasPorSkuEntries,
            detalhesPorUsuario: converterDetalhesPorUsuario(
              item.detalhesPorUsuario,
            ),
            detalhesPorSku: converterDetalhesPorSku(item.detalhesPorSku),
          };
        });

        popularFiltroResponsavelProdutosVendidos();
        produtosVendidosCarregado = true;
        renderProdutosVendidos();
        if (statusEl && !produtosVendidosResumo.length) {
          statusEl.textContent =
            'Nenhum SKU encontrado para o período selecionado.';
        }

        const skuInput = document.getElementById('filtroSkuProdutosVendidos');
        if (skuInput && !skuInput.dataset.listenerAdded) {
          skuInput.addEventListener('input', renderProdutosVendidos);
          skuInput.dataset.listenerAdded = 'true';
        }
      } catch (err) {
        console.error('Erro ao carregar produtos vendidos', err);
        if (statusEl)
          statusEl.textContent =
            'Erro ao carregar dados de produtos vendidos.';
        if (tabela)
          tabela.innerHTML =
            '<tr><td colspan="4" class="py-6 text-center text-red-500">Erro ao carregar dados.</td></tr>';
      } finally {
        produtosVendidosCarregando = false;
        if (botaoFiltrar) {
          botaoFiltrar.disabled = false;
          botaoFiltrar.classList.remove('opacity-70', 'cursor-not-allowed');
          if (botaoFiltrar.dataset.originalHtml) {
            botaoFiltrar.innerHTML = botaoFiltrar.dataset.originalHtml;
          } else {
            botaoFiltrar.innerHTML =
              '<i class="fas fa-filter mr-2"></i>Filtrar';
          }
        }
      }
    }

    function obterProdutosVendidosParaExportacao() {
      return obterProdutosVendidosFiltrados()
        .sort((a, b) => b.total - a.total)
        .map((item) => ({
          skuPrincipal: item.sku,
          skusAgrupados: item.todosSkus.join(', '),
          quantidadeTotal: item.total,
          valorLiquido: Number(item.valorLiquido || 0),
          skusVendidos: item.vendidosPorSku
          .map(
            ([sku, qtd]) => `${sku} (${qtd.toLocaleString('pt-BR')})`,
          )
          .join('; '),
        usuarios: item.usuarios
          .map(
            ([nome, qtd]) => `${nome} (${qtd.toLocaleString('pt-BR')})`,
          )
          .join('; '),
      }));
    }

    function exportarProdutosVendidosExcel() {
      if (!produtosVendidosResumo.length) {
        mostrarErro('Nenhum dado disponível para exportar.');
        return;
      }
      if (typeof XLSX === 'undefined') {
        mostrarErro('Biblioteca de exportação para Excel indisponível.');
        return;
      }

      const linhas = obterProdutosVendidosParaExportacao();
      if (!linhas.length) {
        mostrarErro('Nenhum dado disponível para exportar com os filtros atuais.');
        return;
      }

      const linhasPlanilha = linhas.map((linha) => ({
        'SKU Principal': linha.skuPrincipal,
        'SKUs Agrupados': linha.skusAgrupados,
        'Quantidade Vendida': linha.quantidadeTotal,
        'Valor Líquido (R$)': linha.valorLiquido,
        'Detalhe por SKU': linha.skusVendidos,
        'Usuários Responsáveis': linha.usuarios,
      }));

      const ws = XLSX.utils.json_to_sheet(linhasPlanilha);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'ProdutosVendidos');
      const hoje = new Date().toISOString().slice(0, 10);
      XLSX.writeFile(wb, `produtos_vendidos_${hoje}.xlsx`);
      mostrarSucesso('Arquivo Excel gerado com sucesso.');
    }

    function exportarRelatorioPorPecaExcel() {
      try {
        const dados = obterProdutosVendidosFiltrados();
        if (!dados.length) {
          mostrarErro('Nenhum dado disponível para exportar.');
          return;
        }
        const agregador = new Map(); // produtoSku -> quantidade total
        
        dados.forEach((item) => {
          // Construir mapa de compostos: sku (normalizado) -> lista de compostos
          const mapaCompostos = new Map();
          if (Array.isArray(item.compostosPorSku)) {
            item.compostosPorSku.forEach(([skuChave, listaCompostos]) => {
              if (!skuChave || !Array.isArray(listaCompostos)) return;
              const chaveNormalizada = String(skuChave || '').toLowerCase().trim();
              if (chaveNormalizada) {
                mapaCompostos.set(chaveNormalizada, listaCompostos);
              }
            });
          }
          
          // Função para obter compostos de um SKU (com fallback para o SKU principal)
          const obterCompostos = (sku) => {
            if (!sku) return [];
            const chaveNormalizada = String(sku).toLowerCase().trim();
            // Tenta pelo SKU vendido
            if (mapaCompostos.has(chaveNormalizada)) {
              return mapaCompostos.get(chaveNormalizada) || [];
            }
            // Fallback: tenta pelo SKU principal
            const chavePrincipal = String(item.sku || '').toLowerCase().trim();
            if (chavePrincipal && mapaCompostos.has(chavePrincipal)) {
              return mapaCompostos.get(chavePrincipal) || [];
            }
            return [];
          };
          
          // Função para acumular quantidade por produto
          const acumular = (skuProduto, qtd) => {
            if (!skuProduto) return;
            const skuNorm = String(skuProduto).trim();
            if (!skuNorm) return;
            const q = Number(qtd || 0);
            if (!Number.isFinite(q) || q <= 0) return;
            agregador.set(skuNorm, (agregador.get(skuNorm) || 0) + q);
          };
          
          // Processar cada SKU vendido
          if (Array.isArray(item.vendidosPorSku)) {
            item.vendidosPorSku.forEach(([skuVendido, qtdVendida]) => {
              const quantidadeVendida = Number(qtdVendida || 0);
              if (!Number.isFinite(quantidadeVendida) || quantidadeVendida <= 0) return;
              
              const compostos = obterCompostos(skuVendido);
              
              if (Array.isArray(compostos) && compostos.length > 0) {
                // SKU é composto: separar em peças individuais
                compostos.forEach((comp) => {
                  const skuProduto = String(comp?.sku || '').trim();
                  const qtdPorUnidade = Number(comp?.quantidade || 1);
                  if (skuProduto && Number.isFinite(qtdPorUnidade) && qtdPorUnidade > 0) {
                    const totalPeca = quantidadeVendida * qtdPorUnidade;
                    acumular(skuProduto, totalPeca);
                  }
                });
              } else {
                // SKU não é composto: conta como peça única
                acumular(skuVendido, quantidadeVendida);
              }
            });
          }
          
          // Fallback: se não houver vendidosPorSku, usar o total do item principal
          if (!item.vendidosPorSku || item.vendidosPorSku.length === 0) {
            const quantidadeTotal = Number(item.total || 0);
            if (Number.isFinite(quantidadeTotal) && quantidadeTotal > 0) {
              const compostosPrincipal = obterCompostos(item.sku);
              if (Array.isArray(compostosPrincipal) && compostosPrincipal.length > 0) {
                compostosPrincipal.forEach((comp) => {
                  const skuProduto = String(comp?.sku || '').trim();
                  const qtdPorUnidade = Number(comp?.quantidade || 1);
                  if (skuProduto && Number.isFinite(qtdPorUnidade) && qtdPorUnidade > 0) {
                    const totalPeca = quantidadeTotal * qtdPorUnidade;
                    acumular(skuProduto, totalPeca);
                  }
                });
              } else {
                acumular(item.sku, quantidadeTotal);
              }
            }
          }
        });

        if (typeof XLSX === 'undefined') {
          mostrarErro('Biblioteca de exportação para Excel indisponível.');
          return;
        }
        
        const linhas = Array.from(agregador.entries())
          .sort((a, b) => a[0].localeCompare(b[0], 'pt-BR'))
          .map(([sku, qtd]) => ({ 
            'Produto (SKU)': sku, 
            'Quantidade Total': qtd 
          }));
        
        if (!linhas.length) {
          mostrarErro('Nenhuma peça encontrada para exportar.');
          return;
        }
        
        const ws = XLSX.utils.json_to_sheet(linhas);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'PorPeca');
        const hoje = new Date().toISOString().slice(0, 10);
        XLSX.writeFile(wb, `produtos_vendidos_por_peca_${hoje}.xlsx`);
        mostrarSucesso('Relatório por peça gerado com sucesso.');
      } catch (err) {
        console.error('Erro ao exportar relatório por peça:', err);
        mostrarErro('Erro ao exportar relatório por peça.');
      }
    }

    function exportarProdutosVendidosPDFDetalhado() {
      if (!produtosVendidosResumo?.length) {
        mostrarErro('Nenhum dado disponível para exportar.');
        return;
      }
      if (typeof html2pdf === 'undefined') {
        mostrarErro('Biblioteca de exportação para PDF indisponível.');
        return;
      }

      const dadosFiltrados = obterProdutosVendidosFiltrados();

      if (!dadosFiltrados.length) {
        mostrarErro('Nenhum SKU encontrado para exportar com os filtros atuais.');
        return;
      }

      const formatCurrency = (valor) =>
        Number(valor || 0).toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL',
        });

      const ordenados = [...dadosFiltrados].sort((a, b) => b.total - a.total);

      const totalUnidades = ordenados.reduce((acc, item) => acc + item.total, 0);
      const totalLiquido = ordenados.reduce(
        (acc, item) => acc + Number(item.valorLiquido || 0),
        0,
      );

      const normalizarQuantidadeParafusos = (valor) => {
        if (valor === undefined || valor === null) return null;
        const numero = Number(valor);
        return Number.isFinite(numero) ? numero : null;
      };
      const formatarQuantidadeParafusos = (valor) => {
        const numero = normalizarQuantidadeParafusos(valor);
        return numero === null ? null : numero.toLocaleString('pt-BR');
      };

      let totalParafusosGeral = 0;
      const linhas = ordenados
        .map((item) => {
          const principaisDetalhes = Array.isArray(
            item.principaisVinculadosDetalhes,
          )
            ? item.principaisVinculadosDetalhes
            : [];
          let detalhesHtml = '';
          let extrasHtml = '';

          const mapaParafusos = new Map(
            Array.isArray(item.parafusosPorSku) ? item.parafusosPorSku : [],
          );
          const mapaParafusosNormalizado = new Map();
          mapaParafusos.forEach((valor, chave) => {
            mapaParafusosNormalizado.set(
              String(chave || '').toLowerCase(),
              valor,
            );
          });
          const obterParafusosSku = (sku) => {
            if (!sku) return null;
            const normalizado = String(sku || '').toLowerCase();
            if (mapaParafusosNormalizado.has(normalizado)) {
              return normalizarQuantidadeParafusos(
                mapaParafusosNormalizado.get(normalizado),
              );
            }
            return null;
          };
          const principalParafusosBruto =
            obterParafusosSku(item.sku) ??
            normalizarQuantidadeParafusos(item.quantidadeParafusosPrincipal);
          const principalParafusosNumero = normalizarQuantidadeParafusos(
            principalParafusosBruto,
          );
          const principalParafusosFormatado = formatarQuantidadeParafusos(
            principalParafusosNumero,
          );
          const principalParafusosHtml =
            principalParafusosFormatado !== null
              ? `<div class="sku-parafusos"><span class="icon">🔩</span><span>${principalParafusosFormatado}</span><span>parafusos/un.</span></div>`
              : '';

          let totalParafusosItem = item.vendidosPorSku.reduce(
            (acc, [sku, qtd]) => {
              const quantidade = Number(qtd || 0);
              if (!Number.isFinite(quantidade) || quantidade <= 0) {
                return acc;
              }
              const parafusosPorUnidade =
                obterParafusosSku(sku) ?? principalParafusosNumero;
              const parafusosNormalizados = normalizarQuantidadeParafusos(
                parafusosPorUnidade,
              );
              if (parafusosNormalizados === null) {
                return acc;
              }
              return acc + parafusosNormalizados * quantidade;
            },
            0,
          );
          if (
            (!totalParafusosItem || totalParafusosItem <= 0) &&
            principalParafusosNumero !== null
          ) {
            const quantidadeTotal = Number(item.total || 0);
            if (Number.isFinite(quantidadeTotal) && quantidadeTotal > 0) {
              totalParafusosItem = principalParafusosNumero * quantidadeTotal;
            }
          }
          if (totalParafusosItem > 0) {
            totalParafusosGeral += totalParafusosItem;
          }
          const totalParafusosFormatado =
            totalParafusosItem > 0
              ? totalParafusosItem.toLocaleString('pt-BR')
              : null;
          const totalParafusosHtml = totalParafusosFormatado
            ? `<div class="total-parafusos"><span class="icon">🔩</span><span>${totalParafusosFormatado}</span><span>parafusos</span></div>`
            : '';

          if (principaisDetalhes.length) {
            const linhasPrincipais = principaisDetalhes
              .map(({ sku, quantidade, parafusos }) => {
                const quantidadeFormatada = Number(quantidade || 0).toLocaleString(
                  'pt-BR',
                );
                const parafusosNormalizado =
                  obterParafusosSku(sku) ??
                  normalizarQuantidadeParafusos(parafusos);
                const parafusosFormatado = formatarQuantidadeParafusos(
                  parafusosNormalizado,
                );
                const parafusosHtml =
                  parafusosFormatado !== null
                    ? `<div class="principal-parafusos"><span class="icon">🔩</span><span>${parafusosFormatado}</span><span>parafusos/un.</span></div>`
                    : '';
                return `
                  <div class="principal-item">
                    <div class="principal-header">
                      <span class="principal-sku">${escapeHtml(sku)}</span>
                      <span class="principal-quantidade">${quantidadeFormatada}</span>
                    </div>
                    ${parafusosHtml}
                  </div>
                `.trim();
              })
              .join('');
            detalhesHtml = `
              <div class="principais-container">
                <div class="principais-title">Principais vinculados</div>
                <div class="principais-list">${linhasPrincipais}</div>
              </div>
            `.trim();
          } else {
            const vendidosChips = item.vendidosPorSku
              .map(([sku, qtd]) => {
                const quantidadeFormatada = Number(qtd || 0).toLocaleString('pt-BR');
                const parafusosFormatado = formatarQuantidadeParafusos(
                  obterParafusosSku(sku),
                );
                const parafusosBadge =
                  parafusosFormatado !== null
                    ? `<span class="chip-parafusos"><span class="icon">🔩</span><span>${parafusosFormatado}</span></span>`
                    : '';
                return `
                  <span class="chip">
                    <span>${escapeHtml(sku)}</span>
                    <span class="chip-qty">${quantidadeFormatada}</span>
                    ${parafusosBadge}
                  </span>
                `.trim();
              })
              .join('');
            detalhesHtml = vendidosChips
              ? `<div class="chips-container">${vendidosChips}</div>`
              : '';
            const extrasLista = item.grupoCompleto
              .filter(
                (skuExtra) =>
                  !item.vendidosPorSku.some(
                    ([skuVend]) =>
                      skuVend.toLowerCase() === skuExtra.toLowerCase(),
                  ),
              )
              .map((skuExtra) => {
                const parafusosFormatado = formatarQuantidadeParafusos(
                  obterParafusosSku(skuExtra),
                );
                const parafusosTexto =
                  parafusosFormatado !== null
                    ? ` (🔩 ${parafusosFormatado})`
                    : '';
                return `${escapeHtml(skuExtra)}${parafusosTexto}`;
              });
            extrasHtml = extrasLista.length
              ? `<div class="extras">Associados: ${extrasLista.join(', ')}</div>`
              : '';
          }

          const usuariosHtml = item.usuarios.length
            ? item.usuarios
                .map(
                  ([nome, qtd]) =>
                    `<span>${escapeHtml(nome)} (${Number(qtd || 0).toLocaleString(
                      'pt-BR',
                    )})</span>`,
                )
                .join('')
            : '<span class="placeholder">-</span>';

          const totalFormatado = item.total.toLocaleString('pt-BR');
          const valorLiquidoFormatado = formatCurrency(item.valorLiquido);

          return `
            <tr class="pdf-row">
              <td class="col-sku">
                <div class="sku-title">${escapeHtml(item.sku)}</div>
                ${principalParafusosHtml}
                ${detalhesHtml}
                ${extrasHtml}
              </td>
              <td class="col-quantidade">
                <div class="quantidade-wrapper">
                  <span class="quantidade-total">${totalFormatado}</span>
                  ${totalParafusosHtml}
                </div>
              </td>
              <td class="col-valor">${valorLiquidoFormatado}</td>
              <td class="col-usuarios"><div class="usuarios">${usuariosHtml}</div></td>
            </tr>
          `.trim();
        })
        .join('');

      const formatarDataFiltro = (valor) => {
        if (!valor) return '';
        const partes = valor.split('-');
        if (partes.length !== 3) return '';
        return `${partes[2]}/${partes[1]}/${partes[0]}`;
      };

      const filtrosAtivos = [];
      const filtroSkuValor = obterFiltroSkuProdutosVendidosValor();
      const filtroInicio = document.getElementById('filtroProdutosVendidosInicio')?.value;
      const filtroFim = document.getElementById('filtroProdutosVendidosFim')?.value;

      if (filtroInicio) {
        filtrosAtivos.push(`Data inicial: ${formatarDataFiltro(filtroInicio)}`);
      }
      if (filtroFim) {
        filtrosAtivos.push(`Data final: ${formatarDataFiltro(filtroFim)}`);
      }
      if (filtroSkuValor) {
        filtrosAtivos.push(`SKU: ${filtroSkuValor}`);
      }

      const statusTexto = document
        .getElementById('produtosVendidosStatus')
        ?.textContent?.trim();
      const dataGeracao = new Date().toLocaleString('pt-BR');

      const wrapper = document.createElement('div');
      const filtrosHtml = filtrosAtivos.length
        ? `<div class="pdf-filters">${filtrosAtivos
            .map((texto) => `<span class="pdf-filter-chip">${escapeHtml(texto)}</span>`)
            .join('')}</div>`
        : '';
      const statusHtml = statusTexto
        ? `<p class="pdf-status">${escapeHtml(statusTexto)}</p>`
        : '';

      const totalParafusosResumo = totalParafusosGeral
        ? totalParafusosGeral.toLocaleString('pt-BR')
        : '0';

      wrapper.innerHTML = `
        <div id="pdf-root">
          <style>
            @page { size: A4 portrait; margin: 12mm; }
            * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            #pdf-root {
              font-family: 'Inter', Arial, sans-serif;
              color: #1f2937;
            }
            .pdf-card {
              width: 100%;
              background: #ffffff;
              border: 1px solid #e5e7eb;
              border-radius: 16px;
              padding: 20px;
              box-sizing: border-box;
            }
            .pdf-header {
              display: flex;
              justify-content: space-between;
              align-items: flex-start;
              gap: 16px;
              margin-bottom: 16px;
            }
            .pdf-title {
              font-size: 20px;
              font-weight: 700;
              margin: 0;
              color: #1f2937;
            }
            .pdf-subtitle {
              font-size: 12px;
              color: #6b7280;
              margin: 6px 0 0;
            }
            .pdf-generated-at {
              font-size: 10px;
              color: #9ca3af;
              margin: 6px 0 0;
            }
            .pdf-summary {
              font-size: 12px;
              color: #4b5563;
              text-align: right;
              line-height: 1.5;
            }
            .pdf-summary span {
              font-weight: 600;
              color: #111827;
            }
            .pdf-summary .icon {
              margin-right: 4px;
            }
            .pdf-filters {
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
              margin-bottom: 12px;
            }
            .pdf-filter-chip {
              background: #eef2ff;
              color: #4338ca;
              border-radius: 9999px;
              padding: 4px 12px;
              font-size: 11px;
              font-weight: 600;
            }
            .pdf-status {
              font-size: 11px;
              color: #6b7280;
              margin: 0 0 12px;
            }
            .pdf-table {
              width: 100%;
              border-collapse: collapse;
              font-size: 11px;
              color: #1f2937;
            }
            .pdf-table thead th {
              background: #f9fafb;
              color: #6b7280;
              text-transform: uppercase;
              letter-spacing: 0.05em;
              font-size: 10px;
              padding: 8px 10px;
              border-bottom: 1px solid #e5e7eb;
              text-align: left;
            }
            .pdf-table tbody td {
              border-bottom: 1px solid #f3f4f6;
              padding: 10px;
              vertical-align: top;
            }
            .col-sku { width: 38%; }
            .col-quantidade { width: 16%; text-align: center; }
            .col-valor { width: 20%; text-align: right; }
            .col-usuarios { width: 26%; }
            .sku-title {
              font-weight: 600;
              font-size: 12px;
              color: #1f2937;
            }
            .chips-container {
              display: flex;
              flex-wrap: wrap;
              gap: 6px;
              margin-top: 6px;
            }
            .chip {
              display: inline-flex;
              align-items: center;
              gap: 6px;
              background: #eef2ff;
              color: #4338ca;
              border-radius: 9999px;
              padding: 3px 10px;
              font-weight: 600;
              font-size: 11px;
            }
            .chip-qty {
              color: #374151;
              font-weight: 600;
            }
            .chip-parafusos {
              display: inline-flex;
              align-items: center;
              gap: 4px;
              font-weight: 600;
              color: #4338ca;
              font-size: 10px;
            }
            .principais-container {
              margin-top: 8px;
              font-size: 11px;
              color: #6b7280;
            }
            .principais-title {
              font-weight: 600;
              color: #4b5563;
              margin-bottom: 4px;
            }
            .principais-list {
              display: flex;
              flex-direction: column;
              gap: 4px;
            }
            .principal-item {
              display: flex;
              flex-direction: column;
              gap: 4px;
              background: #eef2ff;
              color: #4338ca;
              border-radius: 10px;
              padding: 6px 10px;
            }
            .principal-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
            }
            .principal-quantidade {
              font-weight: 600;
              color: #374151;
            }
            .principal-parafusos {
              display: inline-flex;
              align-items: center;
              gap: 4px;
              font-size: 10px;
              font-weight: 600;
              color: #4338ca;
            }
            .extras {
              margin-top: 6px;
              font-size: 10px;
              color: #9ca3af;
            }
            .sku-parafusos {
              margin-top: 4px;
              font-size: 10px;
              color: #4338ca;
              display: inline-flex;
              align-items: center;
              gap: 4px;
              font-weight: 600;
            }
            .quantidade-wrapper {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
            }
            .quantidade-total {
              font-weight: 600;
              color: #1f2937;
            }
            .total-parafusos {
              display: inline-flex;
              align-items: center;
              gap: 4px;
              font-size: 10px;
              font-weight: 600;
              color: #4338ca;
            }
            .icon {
              display: inline-block;
            }
            .usuarios {
              font-size: 11px;
              color: #4b5563;
              line-height: 1.5;
            }
            .usuarios span {
              display: block;
            }
            .usuarios .placeholder {
              color: #d1d5db;
              font-style: italic;
            }
            .pdf-row {
              page-break-inside: avoid;
              break-inside: avoid;
            }
          </style>
          <div class="pdf-card">
            <div class="pdf-header">
              <div>
                <h2 class="pdf-title">Produtos Vendidos</h2>
                <p class="pdf-subtitle">Resumo consolidado das vendas por SKU dos usuários vinculados a este responsável financeiro.</p>
                <p class="pdf-generated-at">Relatório gerado em ${dataGeracao}</p>
              </div>
              <div class="pdf-summary">
                <div>Total vendido: <span>${totalUnidades.toLocaleString('pt-BR')}</span> unidades</div>
                <div>Valor líquido: <span>${formatCurrency(totalLiquido)}</span></div>
                <div><span class="icon">🔩</span>Total de parafusos: <span>${totalParafusosResumo}</span></div>
              </div>
            </div>
            ${filtrosHtml}
            ${statusHtml}
            <table class="pdf-table">
              <thead>
                <tr class="pdf-row">
                  <th class="col-sku">SKU</th>
                  <th class="col-quantidade">Quantidade vendida</th>
                  <th class="col-valor">Valor líquido</th>
                  <th class="col-usuarios">Usuários responsáveis</th>
                </tr>
              </thead>
              <tbody>${linhas}</tbody>
            </table>
          </div>
        </div>
      `;

      const opt = {
        margin: 12,
        filename: `produtos_vendidos_${new Date().toISOString().slice(0, 10)}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
          scale: Math.max(2, window.devicePixelRatio || 1),
          useCORS: true,
          scrollY: 0,
        },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
        pagebreak: {
          mode: ['css', 'legacy'],
          avoid: ['.pdf-row', 'tr', 'td', 'th'],
        },
      };

      html2pdf()
        .set(opt)
        .from(wrapper)
        .save()
        .then(() => {
          mostrarSucesso('Arquivo PDF gerado com sucesso.');
        })
        .catch((e) => {
          console.error(e);
          mostrarErro('Falha ao gerar o PDF.');
        });
    }

    function exportarProdutosVendidosPDFSimplificado() {
      try {
        const linhas = obterProdutosVendidosFiltrados().sort((a, b) => b.total - a.total);
        if (!linhas.length) {
          mostrarErro('Nenhum dado disponível para exportar.');
          return;
        }

        const doc = new jspdf.jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });
        const margem = 12;
        const titulo = 'Produtos Vendidos (simplificado)';
        doc.setFontSize(14);
        doc.text(titulo, margem, 14);

        const normalizarNumero = (v) => (Number.isFinite(Number(v)) ? Number(v) : 0);
        const formatarMoeda = (valor) => Number(valor || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });

        const calcularTotalPecas = (item) => {
          const mapaPecas = new Map(Array.isArray(item.pecasPorSku) ? item.pecasPorSku : []);
          const obterPecasSkuLocal = (sku) => {
            const n = String(sku || '').toLowerCase();
            if (mapaPecas.has(n)) {
              const v = Number(mapaPecas.get(n));
              return Number.isFinite(v) && v > 0 ? v : 1;
            }
            return 1;
          };
          const principalPecas = obterPecasSkuLocal(item.sku);
          let total = item.vendidosPorSku.reduce((acc, [sku, qtd]) => {
            const quantidade = normalizarNumero(qtd);
            if (!quantidade) return acc;
            const porUn = obterPecasSkuLocal(sku) || principalPecas || 1;
            return acc + porUn * quantidade;
          }, 0);
          if (!total) {
            const quantidadeTotal = normalizarNumero(item.total);
            total = (principalPecas || 1) * quantidadeTotal;
          }
          return total;
        };

        const calcularTotaisComponentes = (item) => {
          const mapaComponentes = new Map(Array.isArray(item.componentesPorSku) ? item.componentesPorSku : []);
          const obterComponentesSkuLocal = (sku) => {
            const n = String(sku || '').toLowerCase();
            return mapaComponentes.has(n) ? mapaComponentes.get(n) || [] : [];
          };
          const somas = new Map();
          const somar = (nome, qtd) => {
            const q = normalizarNumero(qtd);
            if (!nome || !q) return;
            somas.set(nome, (somas.get(nome) || 0) + q);
          };
          item.vendidosPorSku.forEach(([sku, qtd]) => {
            const quantidade = normalizarNumero(qtd);
            if (!quantidade) return;
            obterComponentesSkuLocal(sku).forEach((c) => {
              const porUn = normalizarNumero(c?.quantidade) || 0;
              if (porUn > 0) somar(c.nome, porUn * quantidade);
            });
          });
          if (!somas.size) {
            const quantidadeTotal = normalizarNumero(item.total);
            obterComponentesSkuLocal(item.sku).forEach((c) => {
              const porUn = normalizarNumero(c?.quantidade) || 0;
              if (porUn > 0) somar(c.nome, porUn * quantidadeTotal);
            });
          }
          return Array.from(somas.entries())
            .map(([nome, qtd]) => `${nome} ${qtd.toLocaleString('pt-BR')}`)
            .join('; ');
        };

        const cabecalho = [
          { header: 'SKU', dataKey: 'sku' },
          { header: 'Peças', dataKey: 'pecas' },
          { header: 'Fiação/Bocal/Outros', dataKey: 'componentes' },
          { header: 'Valor líquido', dataKey: 'valor' },
          { header: 'Usuários responsáveis', dataKey: 'usuarios' },
        ];

        const linhasTabela = linhas.map((item) => ({
          sku: item.sku,
          pecas: calcularTotalPecas(item).toLocaleString('pt-BR'),
          componentes: calcularTotaisComponentes(item) || '—',
          valor: formatarMoeda(item.valorLiquido),
          usuarios: (Array.isArray(item.usuarios) ? item.usuarios : [])
            .map(([nome, qtd]) => `${nome} (${Number(qtd || 0).toLocaleString('pt-BR')})`)
            .join('; '),
        }));

        doc.autoTable({
          head: [cabecalho.map((c) => c.header)],
          body: linhasTabela.map((l) => [l.sku, l.pecas, l.componentes, l.valor, l.usuarios]),
          startY: 18,
          styles: { fontSize: 9, cellPadding: 2 },
          headStyles: { fillColor: [79, 70, 229] },
          margin: { left: margem, right: margem },
        });

        doc.save('produtos_vendidos_simplificado.pdf');
      } catch (err) {
        console.error('Erro ao exportar PDF de produtos vendidos (simplificado):', err);
        mostrarErro('Erro ao exportar PDF.');
      }
    }


    async function carregarControleVendas() {
      const container = document.getElementById("listaControleVendas");
      const resumoContainer = document.getElementById("resumoMensalVendas");
      const projecaoContainer = document.getElementById("cardsProjecao");
      const filtroMes = document.getElementById("filtroMesVendas")?.value;
      registrarEventosControleVendas();
      limparSelecaoControleVendas();
      if (!container) return;
      container.innerHTML = "🔄 Carregando...";
      if (resumoContainer) resumoContainer.innerHTML = "";
      if (projecaoContainer) projecaoContainer.innerHTML = "🔄 Carregando...";

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      if (projecaoContainer) {
        const hoje = new Date();
        const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
        const anoMesPrev = proxMes.toISOString().slice(0, 7);
        try {
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            const prevSnap = await db.collectionGroup('previsoes')
              .where(firebase.firestore.FieldPath.documentId(), '==', anoMesPrev)
              .get();
            const totalPrev = {};
            prevSnap.forEach(doc => {
              const dados = doc.data();
              if (dados.skus) {
                Object.entries(dados.skus).forEach(([sku, info]) => {
                  totalPrev[sku] = (totalPrev[sku] || 0) + (info.total || 0);
                });
              }
            });
            if (Object.keys(totalPrev).length) {
              projecaoContainer.innerHTML = Object.entries(totalPrev)
                .map(([sku, total]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${total.toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
            }
          } else {
            const prevDoc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMesPrev).get();
            if (prevDoc.exists) {
              const dados = prevDoc.data();
              projecaoContainer.innerHTML = Object.entries(dados.skus || {})
                .map(([sku, info]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${(info.total || 0).toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
            }
          }
        } catch (err) {
          console.error('Erro ao carregar previsão', err);
          projecaoContainer.innerHTML = '<p class="text-red-500">Erro ao carregar previsão.</p>';
        }
      }

      container.innerHTML = "";
      const totaisSku = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id; // Ex: 2025-07-21
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoDoc, mesDoc] = dataDoc.split("-");
          if (anoFiltro !== anoDoc || mesFiltro !== mesDoc) continue;
        }

 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`);
        const listaSnap = await listaRef.get();
        if (listaSnap.empty) continue;

        let htmlSKUs = "";
        let totalDia = 0;

        listaSnap.forEach(docSKU => {
          const { sku, total, loja } = docSKU.data();
          const skuKey = sku || docSKU.id;
          totalDia += total || 0;
          htmlSKUs += `
      <div class="text-sm text-gray-700">
        <strong>${skuKey}</strong> (${loja || "-"}) — ${total || 0} unid.
      </div>`;
          totaisSku[skuKey] = (totaisSku[skuKey] || 0) + (total || 0);
        });

        const card = document.createElement("div");
        card.className = "bg-white rounded-lg shadow p-4 border border-gray-200";
        card.innerHTML = `
          <div class="flex items-center justify-between gap-2 mb-2">
            <div class="flex items-center gap-2">
              <input type="checkbox" class="controle-vendas-checkbox h-4 w-4" data-dia="${dataDoc}" data-uid="${ownerUid}">
              <div class="text-center font-bold bg-blue-100 text-blue-800 px-3 py-1 rounded">${dataDoc}</div>
            </div>
            <button type="button" onclick="verDetalhesDia('${dataDoc}')" class="text-blue-600 text-sm hover:underline">🔍 Ver mais</button>
          </div>
          <div class="mb-2 text-sm text-gray-600">🧾 Total do dia: <strong>${totalDia}</strong> unidades</div>
          ${htmlSKUs}
        `;
        container.appendChild(card);
        const checkbox = card.querySelector('.controle-vendas-checkbox');
        if (checkbox) {
          checkbox.addEventListener('change', () => atualizarSelecaoControleVendas(checkbox));
        }
      }

      if (container.innerHTML === "") {
        container.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o período selecionado.</p>`;
      }
      atualizarPainelSelecaoControleVendas();
      if (resumoContainer) {
        if (Object.keys(totaisSku).length) {
          const cards = Object.entries(totaisSku)
            .sort((a, b) => b[1] - a[1])
            .map(([sku, total]) =>
              `<div class="bg-white rounded-lg shadow p-4 border border-gray-200 flex justify-between"><span>${sku}</span><span class="font-bold">${total}</span></div>`
            ).join("");
          resumoContainer.innerHTML = cards;
        } else {
          resumoContainer.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o período selecionado.</p>`;
        }
      }
    }

    const sobrasEstado = {
      pedidos: [],
      filtros: {
        dataInicio: '',
        dataFim: '',
        loja: 'todos',
        sku: 'todos',
        usuario: 'todos'
      },
      ordenacao: {
        coluna: '',
        asc: true
      },
      eventosInicializados: false
    };

    function normalizarTextoSobras(valor) {
      return (valor ?? '').toString().trim();
    }

    function normalizarDataSobras(valor) {
      if (!valor) return null;
      if (valor instanceof Date) {
        return Number.isNaN(valor.getTime()) ? null : valor;
      }
      if (typeof valor === 'number') {
        const data = new Date(valor);
        return Number.isNaN(data.getTime()) ? null : data;
      }
      const texto = normalizarTextoSobras(valor);
      if (!texto) return null;
      let data = new Date(texto);
      if (!Number.isNaN(data.getTime())) return data;
      if (texto.includes('/')) {
        const partes = texto.split(/[\\/]/);
        if (partes.length === 3) {
          const [dia, mes, ano] = partes;
          data = new Date(`${ano}-${mes}-${dia}`);
          if (!Number.isNaN(data.getTime())) return data;
        }
      }
      if (/^\d{8}$/.test(texto)) {
        const ano = texto.slice(0, 4);
        const mes = texto.slice(4, 6);
        const dia = texto.slice(6, 8);
        data = new Date(`${ano}-${mes}-${dia}`);
        if (!Number.isNaN(data.getTime())) return data;
      }
      return null;
    }

    function normalizarNumeroSobras(valor) {
      if (typeof valor === 'number') {
        return Number.isFinite(valor) ? valor : 0;
      }
      const texto = normalizarTextoSobras(valor);
      if (!texto) return 0;
      let normalizado = texto.replace(/[^\d,.-]/g, '');
      if (!normalizado) return 0;
      const temVirgula = normalizado.includes(',');
      const totalPontos = (normalizado.match(/\./g) || []).length;
      if (temVirgula) {
        normalizado = normalizado.replace(/\./g, '').replace(',', '.');
      } else if (totalPontos > 1) {
        normalizado = normalizado.replace(/\./g, '');
      }
      normalizado = normalizado.replace(/,/g, '.');
      const numero = Number(normalizado);
      return Number.isFinite(numero) ? numero : 0;
    }

    function preencherSelectSobras(select, valores, valorAtual) {
      if (!select) return;
      const labelPadrao = select.id === 'filtroSobrasLoja' ? 'Todas' : 'Todos';
      const lista = Array.from(valores).filter(Boolean).sort((a, b) => a.localeCompare(b, 'pt-BR', { sensitivity: 'base' }));
      select.innerHTML = `<option value="todos">${labelPadrao}</option>` + lista.map(item => `<option value="${item}">${item}</option>`).join('');
      if (valorAtual && valorAtual !== 'todos' && lista.includes(valorAtual)) {
        select.value = valorAtual;
      } else {
        select.value = 'todos';
      }
    }

    function atualizarSobrasFiltrosDisponiveis() {
      const usuarios = new Set();
      const lojas = new Set();
      const skus = new Set();
      sobrasEstado.pedidos.forEach(item => {
        const usuario = normalizarTextoSobras(item.usuario || item.user || item.email || item.nomeUsuario);
        if (usuario) usuarios.add(usuario);
        const loja = normalizarTextoSobras(item.loja || item.shop || item.nomeLoja);
        if (loja) lojas.add(loja);
        const sku = normalizarTextoSobras(item.sku || item.idSku || item.codigoSku);
        if (sku) skus.add(sku);
      });
      const usuarioSelect = document.getElementById('filtroSobrasUsuario');
      const lojaSelect = document.getElementById('filtroSobrasLoja');
      const skuSelect = document.getElementById('filtroSobrasSku');
      preencherSelectSobras(usuarioSelect, usuarios, sobrasEstado.filtros.usuario);
      preencherSelectSobras(lojaSelect, lojas, sobrasEstado.filtros.loja);
      preencherSelectSobras(skuSelect, skus, sobrasEstado.filtros.sku);
      if (usuarioSelect) sobrasEstado.filtros.usuario = usuarioSelect.value;
      if (lojaSelect) sobrasEstado.filtros.loja = lojaSelect.value;
      if (skuSelect) sobrasEstado.filtros.sku = skuSelect.value;
    }

    function obterDadosFiltradosSobras() {
      const { filtros, pedidos } = sobrasEstado;
      let dataInicio = filtros.dataInicio ? normalizarDataSobras(filtros.dataInicio) : null;
      let dataFim = filtros.dataFim ? normalizarDataSobras(filtros.dataFim) : null;
      if (dataInicio) dataInicio.setHours(0, 0, 0, 0);
      if (dataFim) dataFim.setHours(23, 59, 59, 999);
      const usuarioFiltro = filtros.usuario !== 'todos' ? filtros.usuario.toLowerCase() : null;
      const lojaFiltro = filtros.loja !== 'todos' ? filtros.loja.toLowerCase() : null;
      const skuFiltro = filtros.sku !== 'todos' ? filtros.sku.toLowerCase() : null;
      return pedidos.filter(item => {
        if (usuarioFiltro) {
          const usuario = normalizarTextoSobras(item.usuario || item.user || item.email || item.nomeUsuario).toLowerCase();
          if (usuario !== usuarioFiltro) return false;
        }
        if (lojaFiltro) {
          const loja = normalizarTextoSobras(item.loja || item.shop || item.nomeLoja).toLowerCase();
          if (loja !== lojaFiltro) return false;
        }
        if (skuFiltro) {
          const sku = normalizarTextoSobras(item.sku || item.idSku || item.codigoSku).toLowerCase();
          if (sku !== skuFiltro) return false;
        }
        if (dataInicio || dataFim) {
          const dataPedido = normalizarDataSobras(item.dia || item.data || item.dataPedido || item.dataPedidoShopee);
          if (dataInicio && (!dataPedido || dataPedido < dataInicio)) return false;
          if (dataFim && (!dataPedido || dataPedido > dataFim)) return false;
        }
        return true;
      });
    }

    function obterValorOrdenacaoSobras(item, coluna) {
      switch (coluna) {
        case 'usuario':
          return normalizarTextoSobras(item.usuario || item.user || item.email || item.nomeUsuario);
        case 'dia':
          return normalizarDataSobras(item.dia || item.data || item.dataPedido || item.dataPedidoShopee);
        case 'loja':
          return normalizarTextoSobras(item.loja || item.shop || item.nomeLoja);
        case 'pedido':
          return normalizarTextoSobras(item.pedido || item.idPedido || item.numeroPedido || item.id);
        case 'sku':
          return normalizarTextoSobras(item.sku || item.idSku || item.codigoSku);
        case 'quantidade':
          return normalizarNumeroSobras(item.quantidade ?? item.qtd ?? item.qtdVendida ?? 0);
        case 'subtotal':
          return normalizarNumeroSobras(item.subtotal ?? item.valorSubtotal ?? 0);
        case 'sobraReal':
          return normalizarNumeroSobras(item.sobraReal ?? item.totalLiquido ?? 0);
        case 'sobraEsperada':
          return normalizarNumeroSobras(item.sobraEsperada ?? item.metaEsperada ?? 0);
        default:
          return normalizarTextoSobras(item[coluna]);
      }
    }

    function aplicarOrdenacaoSobras(dados) {
      const { coluna, asc } = sobrasEstado.ordenacao;
      if (!coluna) return dados.slice();
      const fator = asc ? 1 : -1;
      return dados.slice().sort((a, b) => {
        const valorA = obterValorOrdenacaoSobras(a, coluna);
        const valorB = obterValorOrdenacaoSobras(b, coluna);
        if (valorA instanceof Date || valorB instanceof Date) {
          const tempoA = valorA instanceof Date ? valorA.getTime() : Number.NEGATIVE_INFINITY;
          const tempoB = valorB instanceof Date ? valorB.getTime() : Number.NEGATIVE_INFINITY;
          if (tempoA === tempoB) return 0;
          return tempoA > tempoB ? fator : -fator;
        }
        if (typeof valorA === 'number' || typeof valorB === 'number') {
          const numA = typeof valorA === 'number' && Number.isFinite(valorA) ? valorA : Number.NEGATIVE_INFINITY;
          const numB = typeof valorB === 'number' && Number.isFinite(valorB) ? valorB : Number.NEGATIVE_INFINITY;
          if (numA === numB) return 0;
          return numA > numB ? fator : -fator;
        }
        const textoA = normalizarTextoSobras(valorA).toLowerCase();
        const textoB = normalizarTextoSobras(valorB).toLowerCase();
        if (textoA === textoB) return 0;
        return textoA.localeCompare(textoB, 'pt-BR') * fator;
      });
    }

    function atualizarIndicadoresOrdenacaoSobras() {
      const { coluna, asc } = sobrasEstado.ordenacao;
      document.querySelectorAll('[data-sobras-indicador]').forEach(span => {
        const key = span.getAttribute('data-sobras-indicador');
        if (key === coluna) {
          span.textContent = asc ? '▲' : '▼';
        } else {
          span.textContent = '';
        }
      });
    }

    function atualizarSobrasTabela() {
      const tbody = document.getElementById('listaSobras');
      if (!tbody) return;
      const dadosFiltrados = obterDadosFiltradosSobras();
      const dadosOrdenados = aplicarOrdenacaoSobras(dadosFiltrados);
      const formatarMoeda = valor => `R$ ${normalizarNumeroSobras(valor).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
      if (!dadosOrdenados.length) {
        const mensagem = sobrasEstado.pedidos.length
          ? 'Nenhum pedido encontrado com os filtros selecionados.'
          : 'Sem pedidos';
        tbody.innerHTML = `<tr><td colspan="9" class="text-center text-gray-500">${mensagem}</td></tr>`;
        atualizarIndicadoresOrdenacaoSobras();
        return;
      }
      tbody.innerHTML = '';
      dadosOrdenados.forEach(dado => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${normalizarTextoSobras(dado.usuario || dado.user || dado.email || dado.nomeUsuario)}</td>
          <td>${normalizarTextoSobras(dado.dia || dado.data || dado.dataPedido || '')}</td>
          <td>${normalizarTextoSobras(dado.loja || dado.shop || dado.nomeLoja)}</td>
          <td>${normalizarTextoSobras(dado.pedido || dado.idPedido || dado.numeroPedido || dado.id)}</td>
          <td>${normalizarTextoSobras(dado.sku || dado.idSku || dado.codigoSku)}</td>
          <td>${normalizarNumeroSobras(dado.quantidade ?? dado.qtd ?? dado.qtdVendida ?? 0)}</td>
          <td>${formatarMoeda(dado.subtotal ?? dado.valorSubtotal)}</td>
          <td>${formatarMoeda(dado.sobraReal ?? dado.totalLiquido)}</td>
          <td>${formatarMoeda(dado.sobraEsperada ?? dado.metaEsperada)}</td>`;
        tbody.appendChild(tr);
      });
      atualizarIndicadoresOrdenacaoSobras();
    }

    function inicializarSobrasEventos() {
      if (sobrasEstado.eventosInicializados) return;
      sobrasEstado.eventosInicializados = true;
      const dataInicio = document.getElementById('filtroSobrasDataInicio');
      const dataFim = document.getElementById('filtroSobrasDataFim');
      const usuarioSelect = document.getElementById('filtroSobrasUsuario');
      const lojaSelect = document.getElementById('filtroSobrasLoja');
      const skuSelect = document.getElementById('filtroSobrasSku');
      if (dataInicio) {
        dataInicio.addEventListener('change', event => {
          sobrasEstado.filtros.dataInicio = event.target.value;
          atualizarSobrasTabela();
        });
      }
      if (dataFim) {
        dataFim.addEventListener('change', event => {
          sobrasEstado.filtros.dataFim = event.target.value;
          atualizarSobrasTabela();
        });
      }
      if (usuarioSelect) {
        usuarioSelect.addEventListener('change', event => {
          sobrasEstado.filtros.usuario = event.target.value;
          atualizarSobrasTabela();
        });
      }
      if (lojaSelect) {
        lojaSelect.addEventListener('change', event => {
          sobrasEstado.filtros.loja = event.target.value;
          atualizarSobrasTabela();
        });
      }
      if (skuSelect) {
        skuSelect.addEventListener('change', event => {
          sobrasEstado.filtros.sku = event.target.value;
          atualizarSobrasTabela();
        });
      }
      document.querySelectorAll('[data-sobras-ordenar]').forEach(th => {
        th.addEventListener('click', () => {
          const coluna = th.getAttribute('data-sobras-ordenar');
          if (!coluna) return;
          if (sobrasEstado.ordenacao.coluna === coluna) {
            sobrasEstado.ordenacao.asc = !sobrasEstado.ordenacao.asc;
          } else {
            sobrasEstado.ordenacao.coluna = coluna;
            sobrasEstado.ordenacao.asc = true;
          }
          atualizarSobrasTabela();
        });
      });
    }

    async function carregarSobras() {
      await tabsLoaded;
      if (!usuarioLogado.uid) {
        console.error('Usuário não autenticado');
        return;
      }
      const tbody = document.getElementById('listaSobras');
      if (tbody) tbody.innerHTML = '<tr><td colspan="9">Carregando...</td></tr>';
      try {
        const pedidos = [];
        const addPedidos = (snap, usuario) => {
          snap.forEach(doc => pedidos.push({ usuario, ...doc.data() }));
        };
        const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('pedidosErrados').get();
        addPedidos(snap, usuarioLogado.email || usuarioLogado.uid);
        const respSnap = await db.collection('usuarios').where('responsavelFinanceiroEmail', '==', usuarioLogado.email).get();
        for (const docSnap of respSnap.docs) {
          const nome = docSnap.data().nome || docSnap.data().email || docSnap.id;
          const errSnap = await db.collection('uid').doc(docSnap.id).collection('pedidosErrados').get();
          addPedidos(errSnap, nome);
        }
        sobrasEstado.pedidos = pedidos;
        atualizarSobrasFiltrosDisponiveis();
        atualizarSobrasTabela();
        inicializarSobrasEventos();
      } catch (e) {
        console.error('Erro ao carregar sobras', e);
        sobrasEstado.pedidos = [];
        atualizarSobrasTabela();
        if (tbody) tbody.innerHTML = '<tr><td colspan="9" class="text-red-500">Erro ao carregar dados</td></tr>';
      }
    }

    const CENARIOS_PREVISAO = [
      { titulo: 'Pessimista', fator: 0.85 },
      { titulo: 'Base', fator: 1 },
      { titulo: 'Otimista', fator: 1.15 }
    ];

    function calcularResumoPrevisaoPorSku(sku = 'todos') {
      const resultado = {
        totalBase: 0,
        pess: 0,
        otm: 0,
        diario: []
      };

      const dadosSkus = previsaoDados?.skus || {};
      const chaves = Object.keys(dadosSkus);
      if (!chaves.length) return resultado;

      const diarioAcumulado = {};

      if (sku === 'todos') {
        for (const info of Object.values(dadosSkus)) {
          const total = Number(info?.total || 0);
          resultado.totalBase += total;
          const diario = info?.diario || {};
          for (const [data, valor] of Object.entries(diario)) {
            const numero = Number(valor || 0);
            diarioAcumulado[data] = (diarioAcumulado[data] || 0) + numero;
          }
        }
      } else if (dadosSkus[sku]) {
        const info = dadosSkus[sku];
        resultado.totalBase = Number(info?.total || 0);
        const diario = info?.diario || {};
        for (const [data, valor] of Object.entries(diario)) {
          diarioAcumulado[data] = Number(valor || 0);
        }
      }

      const labels = Object.keys(diarioAcumulado).sort();
      resultado.diario = labels.map(data => ({ data, quantidade: Number(diarioAcumulado[data] || 0) }));
      resultado.pess = resultado.totalBase * 0.85;
      resultado.otm = resultado.totalBase * 1.15;
      return resultado;
    }

    function calcularCenariosTopSkus() {
      const dadosSkus = Object.entries(previsaoDados?.skus || {});
      if (!dadosSkus.length) return [];

      return CENARIOS_PREVISAO.map(config => {
        const itens = dadosSkus
          .map(([sku, info]) => {
            const quantidadeBase = Number(info?.total || 0);
            const quantidade = quantidadeBase * config.fator;
            const preco = Number(produtos[sku] || 0);
            const sobraUnit = Number(obterMetaSku(sku)?.valor || 0);
            const bruto = quantidade * preco;
            const sobra = quantidade * sobraUnit;
            return { sku, quantidade, bruto, sobra };
          })
          .sort((a, b) => b.quantidade - a.quantidade)
          .slice(0, 10);

        return { ...config, itens };
      }).filter(c => c.itens.length);
    }

    function gerarTopSkusTabelaHtml(cenario) {
      const linhas = cenario.itens
        .map(item => `
            <tr>
              <td class="px-2 py-1 border">${item.sku}</td>
              <td class="px-2 py-1 border">${Number(item.quantidade || 0).toLocaleString('pt-BR', { maximumFractionDigits: 0 })}</td>
              <td class="px-2 py-1 border">R$ ${Number(item.bruto || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
              <td class="px-2 py-1 border">R$ ${Number(item.sobra || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
            </tr>`)
        .join('');

      return `
          <div class="overflow-x-auto">
            <h4 class="font-bold mb-2 text-center">Top 10 SKUs projeção ${cenario.titulo}</h4>
            <table class="min-w-full text-sm text-left">
              <thead>
                <tr>
                  <th class="px-2 py-1 border">SKU</th>
                  <th class="px-2 py-1 border">Quantidade</th>
                  <th class="px-2 py-1 border">Bruto Esperado<br>(Valor de venda)</th>
                  <th class="px-2 py-1 border">Sobra Esperada<br>(Sobra esperada x quantidade)</th>
                </tr>
              </thead>
              <tbody>
                ${linhas}
              </tbody>
            </table>
          </div>`;
    }

    function gerarCardsPrevisaoPdfHtml(resumo) {
      const formatNumero = valor => Number(valor || 0).toLocaleString('pt-BR', { maximumFractionDigits: 0 });
      const cards = [
        { titulo: 'Pessimista', valor: formatNumero(resumo.pess), bg: '#fee2e2', color: '#991b1b' },
        { titulo: 'Base', valor: formatNumero(resumo.totalBase), bg: '#dbeafe', color: '#1d4ed8' },
        { titulo: 'Otimista', valor: formatNumero(resumo.otm), bg: '#dcfce7', color: '#166534' }
      ];

      const cardsHtml = cards
        .map(card => `
        <div style="background:${card.bg};color:${card.color};padding:16px;border-radius:12px;box-shadow:0 1px 3px rgba(15,23,42,0.1);text-align:center;">
          <div style="font-weight:600;font-size:14px;margin-bottom:4px;">${card.titulo}</div>
          <div style="font-size:24px;font-weight:700;">${card.valor}</div>
        </div>`)
        .join('');

      return `<div style="display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));margin-bottom:16px;">${cardsHtml}</div>`;
    }

    function gerarTabelaPrevisaoPdfHtml(diario) {
      if (!diario.length) {
        return '<p style="color:#6b7280;font-size:12px;margin:0 0 16px;">Nenhum histórico diário disponível para esta previsão.</p>';
      }

      const linhas = diario
        .map(item => `
          <tr>
            <td style="border:1px solid #d1d5db;padding:8px;font-size:12px;">${item.data}</td>
            <td style="border:1px solid #d1d5db;padding:8px;font-size:12px;text-align:right;">${Number(item.quantidade || 0).toLocaleString('pt-BR', { maximumFractionDigits: 0 })}</td>
          </tr>`)
        .join('');

      return `
        <div style="margin-bottom:16px;">
          <h4 style="font-size:14px;font-weight:600;margin:0 0 8px;">Distribuição diária (Base)</h4>
          <table style="width:100%;border-collapse:collapse;font-size:12px;">
            <thead>
              <tr>
                <th style="border:1px solid #d1d5db;padding:8px;text-align:left;font-size:12px;background:#f3f4f6;">Data</th>
                <th style="border:1px solid #d1d5db;padding:8px;text-align:right;font-size:12px;background:#f3f4f6;">Quantidade</th>
              </tr>
            </thead>
            <tbody>
              ${linhas}
            </tbody>
          </table>
        </div>`;
    }

    function gerarTopSkusPdfHtml(cenarios) {
      if (!cenarios.length) {
        return '<p style="color:#6b7280;font-size:12px;margin:0;">Nenhuma previsão disponível.</p>';
      }

      const celulaStyle = 'border:1px solid #d1d5db;padding:8px;font-size:12px;text-align:left;';
      const celulaNumerica = 'border:1px solid #d1d5db;padding:8px;font-size:12px;text-align:right;';

      const htmlCenarios = cenarios
        .map(cenario => {
          const linhas = cenario.itens
            .map(item => `
              <tr>
                <td style="${celulaStyle}">${item.sku}</td>
                <td style="${celulaNumerica}">${Number(item.quantidade || 0).toLocaleString('pt-BR', { maximumFractionDigits: 0 })}</td>
                <td style="${celulaNumerica}">R$ ${Number(item.bruto || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
                <td style="${celulaNumerica}">R$ ${Number(item.sobra || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
              </tr>`)
            .join('');

          return `
            <div style="page-break-inside:avoid;">
              <h4 style="font-size:14px;font-weight:600;text-align:center;margin:0 0 8px;">Top 10 SKUs projeção ${cenario.titulo}</h4>
              <table style="width:100%;border-collapse:collapse;font-size:12px;margin-bottom:16px;">
                <thead>
                  <tr>
                    <th style="${celulaStyle};background:#f3f4f6;">SKU</th>
                    <th style="${celulaNumerica};background:#f3f4f6;">Quantidade</th>
                    <th style="${celulaNumerica};background:#f3f4f6;">Bruto Esperado<br>(Valor de venda)</th>
                    <th style="${celulaNumerica};background:#f3f4f6;">Sobra Esperada<br>(Sobra esperada x quantidade)</th>
                  </tr>
                </thead>
                <tbody>
                  ${linhas}
                </tbody>
              </table>
            </div>`;
        })
        .join('');

      return `<div style="display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));">${htmlCenarios}</div>`;
    }

    async function carregarPrevisao() {
      await tabsLoaded;
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const cards = document.getElementById('cardsPrevisao');
      if (!selectSku || !cards) return;
      cards.innerHTML = '🔄 Carregando...';
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const doc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).get();
      if (doc.exists) {
        previsaoDados = doc.data() || {};
        const skus = Object.keys(previsaoDados.skus || {});
        selectSku.innerHTML = '<option value="todos">Todos</option>' + skus.map(s => `<option value="${s}">${s}</option>`).join('');
        cards.innerHTML = '';
        renderizarPrevisao();
        renderizarTopSkus();
      } else {
        previsaoDados = { skus: {} };
        selectSku.innerHTML = '<option value="todos">Todos</option>';
        cards.innerHTML = '🔄 Gerando previsão inicial...';
        await gerarPrevisao({ topN: 5, silencioso: true });
      }
    }

    function renderizarPrevisao() {
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const sku = selectSku?.value || 'todos';
      const cards = document.getElementById('cardsPrevisao');
      const tabela = document.getElementById('tabelaPrevisao');
      const ctx = document.getElementById('graficoPrevisao')?.getContext('2d');
      if (!cards || !tabela || !ctx) return;

      const resumo = calcularResumoPrevisaoPorSku(sku);
      const formatNumero = valor => Number(valor || 0).toLocaleString('pt-BR', { maximumFractionDigits: 0 });
      cards.innerHTML = `
        <div class="bg-red-100 text-red-800 p-4 rounded shadow text-center">
          <div class="font-bold">Pessimista</div><div>${formatNumero(resumo.pess)}</div>
        </div>
        <div class="bg-blue-100 text-blue-800 p-4 rounded shadow text-center">
          <div class="font-bold">Base</div><div>${formatNumero(resumo.totalBase)}</div>
        </div>
        <div class="bg-green-100 text-green-800 p-4 rounded shadow text-center">
          <div class="font-bold">Otimista</div><div>${formatNumero(resumo.otm)}</div>
        </div>`;

      const labels = resumo.diario.map(item => item.data);
      const dados = resumo.diario.map(item => Number(item.quantidade || 0));
      if (graficoPrevisao) graficoPrevisao.destroy();
      graficoPrevisao = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Previsão diária', data: dados, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.3)', tension: 0.2 }] },
        options: { responsive: true, maintainAspectRatio: false }
      });

      if (!labels.length) {
        tabela.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
      } else {
        tabela.innerHTML = `
        <table class="min-w-full text-sm text-left">
          <thead><tr><th class="px-2 py-1 border">Data</th><th class="px-2 py-1 border">Qtde</th></tr></thead>
          <tbody>
            ${labels.map((data, idx) => `<tr><td class="px-2 py-1 border">${data}</td><td class="px-2 py-1 border">${dados[idx].toLocaleString('pt-BR', { maximumFractionDigits: 0 })}</td></tr>`).join('')}
          </tbody>
        </table>`;
      }
    }

    function renderizarTopSkus() {
      const container = document.getElementById('topSkusPrevisao');
      if (!container) return;
      const cenarios = calcularCenariosTopSkus();
      if (!cenarios.length) {
        container.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
        return;
      }

      const tabelas = cenarios.map(gerarTopSkusTabelaHtml).join('');
      container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${tabelas}</div>`;
    }

   function baixarPrevisaoPdf() {
  const area = document.getElementById('previsaoResumoPdf');
  if (!area) {
    mostrarErro('Conteúdo de previsão indisponível para exportação.');
    return;
  }
  
    function exportarProdutosVendidosPDFSimplificado() {
      try {
        const linhas = obterProdutosVendidosFiltrados().sort((a, b) => b.total - a.total);
        if (!linhas.length) {
          mostrarErro('Nenhum dado disponível para exportar.');
          return;
        }

        const doc = new jspdf.jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });
        const margem = 12;
        const titulo = 'Produtos Vendidos (período filtrado)';
        doc.setFontSize(14);
        doc.text(titulo, margem, 14);

        const cabecalho = [
          { header: 'SKU', dataKey: 'sku' },
          { header: 'Peças', dataKey: 'pecas' },
          { header: 'Fiação/Bocal/Outros', dataKey: 'componentes' },
          { header: 'Valor líquido', dataKey: 'valor' },
          { header: 'Usuários responsáveis', dataKey: 'usuarios' },
        ];

        const normalizarNumero = (v) => (Number.isFinite(Number(v)) ? Number(v) : 0);
        const formatarMoeda = (valor) => Number(valor || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });

        const calcularTotalPecas = (item) => {
          const mapaPecas = new Map(Array.isArray(item.pecasPorSku) ? item.pecasPorSku : []);
          const obterPecasSkuLocal = (sku) => {
            const n = String(sku || '').toLowerCase();
            if (mapaPecas.has(n)) {
              const v = Number(mapaPecas.get(n));
              return Number.isFinite(v) && v > 0 ? v : 1;
            }
            // fallback 1 por SKU
            return 1;
          };
          const principalPecas = obterPecasSkuLocal(item.sku);
          let total = item.vendidosPorSku.reduce((acc, [sku, qtd]) => {
            const quantidade = normalizarNumero(qtd);
            if (!quantidade) return acc;
            const porUn = obterPecasSkuLocal(sku) || principalPecas || 1;
            return acc + porUn * quantidade;
          }, 0);
          if (!total) {
            const quantidadeTotal = normalizarNumero(item.total);
            total = (principalPecas || 1) * quantidadeTotal;
          }
          return total;
        };

        const calcularTotaisComponentes = (item) => {
          const mapaComponentes = new Map(Array.isArray(item.componentesPorSku) ? item.componentesPorSku : []);
          const obterComponentesSkuLocal = (sku) => {
            const n = String(sku || '').toLowerCase();
            return mapaComponentes.has(n) ? mapaComponentes.get(n) || [] : [];
          };
          const somas = new Map();
          const somar = (nome, qtd) => {
            const q = normalizarNumero(qtd);
            if (!nome || !q) return;
            somas.set(nome, (somas.get(nome) || 0) + q);
          };
          item.vendidosPorSku.forEach(([sku, qtd]) => {
            const quantidade = normalizarNumero(qtd);
            if (!quantidade) return;
            (obterComponentesSku(sku) || obterComponentesSku(item.sku) || []).forEach((c) => {
              const porUn = normalizarNumero(c?.quantidade) || 0;
              if (porUn > 0) somar(c.nome, porUn * quantidade);
            });
          });
          if (!somas.size) {
            const quantidadeTotal = normalizarNumero(item.total);
            (obterComponentesSku(item.sku) || []).forEach((c) => {
              const porUn = normalizarNumero(c?.quantidade) || 0;
              if (porUn > 0) somar(c.nome, porUn * quantidadeTotal);
            });
          }
          return Array.from(somas.entries())
            .map(([nome, qtd]) => `${nome} ${qtd.toLocaleString('pt-BR')}`)
            .join('; ');
        };

        const linhasTabela = linhas.map((item) => ({
          sku: item.sku,
          pecas: calcularTotalPecas(item).toLocaleString('pt-BR'),
          componentes: calcularTotaisComponentes(item) || '—',
          valor: formatarMoeda(item.valorLiquido),
          usuarios: (Array.isArray(item.usuarios) ? item.usuarios : [])
            .map(([nome, qtd]) => `${nome} (${Number(qtd || 0).toLocaleString('pt-BR')})`)
            .join('; '),
        }));

        // autoTable
        doc.autoTable({
          head: [cabecalho.map((c) => c.header)],
          body: linhasTabela.map((l) => [l.sku, l.pecas, l.componentes, l.valor, l.usuarios]),
          startY: 18,
          styles: { fontSize: 9, cellPadding: 2 },
          headStyles: { fillColor: [79, 70, 229] },
          margin: { left: margem, right: margem },
        });

        doc.save('produtos_vendidos_simplificado.pdf');
      } catch (err) {
        console.error('Erro ao exportar PDF de produtos vendidos:', err);
        mostrarErro('Erro ao exportar PDF.');
      }
    }
  if (typeof html2pdf === 'undefined') {
    mostrarErro('Biblioteca de exportação para PDF indisponível.');
    return;
  }

  const selectSku = document.getElementById('filtroSkuPrevisao');
  const skuSelecionado = selectSku?.value || 'todos';
  const identificadorSku = skuSelecionado === 'todos'
    ? 'todos'
    : skuSelecionado.replace(/[^a-zA-Z0-9_-]+/g, '_');
  const dataArquivo = new Date().toISOString().slice(0, 10);

  // A4 landscape: 297mm largura. Com margem de 10mm de cada lado => 277mm úteis.
  // Converter mm -> px assumindo 96 DPI: px = (mm / 25.4) * 96
  const margemMm = 10;
  const larguraUtilMm = 297 - (margemMm * 2); // 277mm
  const larguraUtilPx = Math.round((larguraUtilMm / 25.4) * 96); // ~1046px

  const opt = {
    margin: margemMm, // em mm (unit 'mm' no jsPDF)
    filename: `previsao_${identificadorSku}_${dataArquivo}.pdf`,
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: {
      scale: Math.min(2, window.devicePixelRatio || 2),
      useCORS: true,
      backgroundColor: '#ffffff',
      scrollY: 0
    },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
    // Remover 'avoid-all' para não criar canvas gigante (PDF branco)
    pagebreak: { mode: ['css', 'legacy'] }
  };

  // Wrapper invisível mas participando do layout
  const exportWrapper = document.createElement('div');
  exportWrapper.style.position = 'absolute';
  exportWrapper.style.left = '0';
  exportWrapper.style.top = '0';
  exportWrapper.style.visibility = 'hidden';
  exportWrapper.style.backgroundColor = '#ffffff';
  exportWrapper.style.boxSizing = 'border-box';
  exportWrapper.style.fontFamily = "'Inter', Arial, sans-serif";
  exportWrapper.style.color = '#111827';
  exportWrapper.style.width = `${larguraUtilPx}px`;
  exportWrapper.style.padding = '0'; // padding controlado via @page (margem)

  // Estilos específicos para impressão / quebras
  const style = document.createElement('style');
  style.textContent = `
    @page { size: A4 landscape; margin: ${margemMm}mm; }
    * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
    .pdf-break { page-break-before: always; }
    .no-break { break-inside: avoid; page-break-inside: avoid; }
    table { border-collapse: collapse; width: 100%; table-layout: fixed; font-size: 12px; }
    th, td { border: 1px solid #e5e7eb; padding: 6px; vertical-align: top; word-break: break-word; overflow-wrap:anywhere; }
    thead { display: table-header-group; }
    tfoot { display: table-footer-group; }
  `;
  exportWrapper.appendChild(style);

  // Cabeçalho
  const header = document.createElement('div');
  header.style.margin = '0 0 12px';
  header.innerHTML = `
    <h2 style="margin:0 0 6px;font-size:20px;font-weight:600;">Previsão de Vendas</h2>
    <p style="margin:0;font-size:12px;color:#4b5563;">
      Gerado em ${new Date().toLocaleString('pt-BR')} | SKU: ${skuSelecionado === 'todos' ? 'Todos' : skuSelecionado}
    </p>
  `;

  // Gera conteúdo (garanta que estas funções retornem strings de HTML válidas)
  const resumo = calcularResumoPrevisaoPorSku(skuSelecionado);
  const cenarios = calcularCenariosTopSkus();

  const conteudo = document.createElement('div');
  conteudo.innerHTML = `
    ${gerarCardsPrevisaoPdfHtml(resumo) || ''}
    <div class="no-break">
      ${gerarTabelaPrevisaoPdfHtml(resumo?.diario || []) || ''}
    </div>
    <div class="pdf-break"></div>
    <div class="no-break">
      ${gerarTopSkusPdfHtml(cenarios) || ''}
    </div>
  `;

  exportWrapper.appendChild(header);
  exportWrapper.appendChild(conteudo);
  document.body.appendChild(exportWrapper);

  // Diagnóstico rápido (se der 0, provavelmente ficaria branco)
  // console.log('wrapper px:', exportWrapper.offsetWidth, exportWrapper.offsetHeight);

  html2pdf()
    .set(opt)
    .from(exportWrapper)
    .save()
    .then(() => {
      mostrarSucesso('Arquivo PDF gerado com sucesso.');
    })
    .catch(err => {
      console.error('Erro ao gerar PDF da previsão', err);
      mostrarErro('Não foi possível gerar o PDF da previsão.');
    })
    .finally(() => {
      exportWrapper.remove();
    });
}

    function gerarDatas(qtd, endDate = new Date()) {
      const datas = [];
      for (let i = qtd; i > 0; i--) {
        const d = new Date(endDate);
        d.setDate(d.getDate() - i);
        datas.push(d.toISOString().slice(0,10));
      }
      return datas;
    }

    function calcularBeta(arr) {
      const n = arr.length;
      const xMean = (n + 1) / 2;
      const yMean = arr.reduce((a, b) => a + b, 0) / n;
      let num = 0, den = 0;
      for (let i = 0; i < n; i++) {
        num += (i + 1 - xMean) * (arr[i] - yMean);
        den += Math.pow(i + 1 - xMean, 2);
      }
      return den ? num / den : 0;
    }

    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    function winsorize(arr, low = 0.05, high = 0.95) {
      const sorted = [...arr].sort((a, b) => a - b);
      const n = sorted.length;
      const lowVal = sorted[Math.floor(n * low)];
      const highVal = sorted[Math.ceil(n * high) - 1];
      return arr.map(v => clamp(v, lowVal, highVal));
    }

    function percentile(arr, p) {
      if (!arr.length) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = (sorted.length - 1) * p;
      const lower = Math.floor(idx);
      const upper = Math.ceil(idx);
      const weight = idx - lower;
      return sorted[lower] * (1 - weight) + (sorted[upper] || sorted[lower]) * weight;
    }

    async function gerarPrevisao(opcoes = {}) {
      const { topN, silencioso } = opcoes;
      const btn = document.getElementById('btnGerarPrevisao');
      if (btn) { btn.disabled = true; btn.innerText = 'Gerando...'; }
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const diasProxMes = new Date(proxMes.getFullYear(), proxMes.getMonth()+1, 0).getDate();
      const datas30 = gerarDatas(30, hoje);
      const datas90 = gerarDatas(90, hoje);
      const ref = db.collection(`uid/${usuarioLogado.uid}/skusVendidos`);
      const snap = await ref.get();
      const serieSkus = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        if (!datas90.includes(dataDoc)) continue;
        const listaSnap = await doc.ref.collection('lista').get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total } = skuDoc.data();
          const skuKey = sku || skuDoc.id;
          if (!serieSkus[skuKey]) serieSkus[skuKey] = {};
          serieSkus[skuKey][dataDoc] = (serieSkus[skuKey][dataDoc] || 0) + (total || 0);
        }
      }

      let skuKeys = Object.keys(serieSkus);
      if (topN) {
        const totais = skuKeys.map(sku => ({
          sku,
          total: datas30.reduce((s, d) => s + (serieSkus[sku][d] || 0), 0)
        }));
        skuKeys = totais.sort((a, b) => b.total - a.total).slice(0, topN).map(t => t.sku);
      }

      const previsao = { skus: {}, totalGeral: 0 };
      for (const sku of skuKeys) {
        const serie = serieSkus[sku] || {};
        const arr90 = datas90.map(d => serie[d] || 0);
        const arr90w = winsorize(arr90, 0.05, 0.95);
        const arr30 = arr90w.slice(-30);
        const arr7 = arr30.slice(-7);
        const avg30 = arr30.reduce((a,b)=>a+b,0) / arr30.length;
        const avg7 = arr7.reduce((a,b)=>a+b,0) / arr7.length;

        let w30 = 0.6;
        let w7 = 0.4;
        const nDados = Object.keys(serie).length;
        if (nDados < 30) {
          const f30 = Math.min(nDados / 30, 1);
          const f7 = Math.min(nDados / 7, 1);
          w30 *= f30;
          w7 *= f7;
          const wsum = w30 + w7;
          if (wsum > 0) { w30 /= wsum; w7 /= wsum; }
        }
        const base = w30 * avg30 + w7 * avg7;

        let beta = 0;
        if (nDados >= 14) beta = calcularBeta(arr30);
        const lowBase = avg30 < 1 && avg7 < 1;
        if (lowBase) beta = 0;

        const globalMean = arr90w.reduce((s,v)=>s+v,0) / arr90w.length;
        const weeks = Math.min(12, Math.floor(nDados / 7));
        let lambda = Math.min(1, weeks / 12);
        if (nDados < 7 || lowBase) lambda = 0;
        const fatores = {};
        for (let w=0; w<7; w++) {
          const vals = datas90
            .map((d,i)=>({d, v: arr90w[i]}))
            .filter(({d})=>new Date(d).getDay()===w)
            .map(({v})=>v);
          const m = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
          const fatorWd = globalMean ? m/globalMean : 1;
          const saz = 1 + lambda * (fatorWd - 1);
          fatores[w] = clamp(saz, 0.85, 1.20);
        }

        const p95 = percentile(arr90w, 0.95);
        const diario = {};
        let total = 0;
        for (let i=1; i<=diasProxMes; i++) {
          const d = new Date(proxMes.getFullYear(), proxMes.getMonth(), i);
          const wd = d.getDay();
          const trendRaw = beta * i;
          const trend = clamp(trendRaw * 0.5, -0.2*base/30, 0.2*base/30);
          const saz = fatores[wd] || 1;
          let val = (base + trend) * saz;
          val = clamp(Math.round(Math.max(0, val)), 0, Math.round(p95 * 1.2));
          const ds = d.toISOString().slice(0,10);
          diario[ds] = val;
          total += val;
        }
        previsao.skus[sku] = { diario, total, p95 };
        previsao.totalGeral += total;
      }

      await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).set(previsao);
      if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-sync-alt"></i> Gerar previsão'; }
      if (!silencioso) Swal.fire('Sucesso','Previsão gerada!','success');
      carregarPrevisao();
      carregarControleVendas();
    }
    window.verDetalhesDia = async function (dataDoc) {
let uids = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('skusVendidos')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataDoc)
          .get();
        q.forEach(doc => uids.push(doc.ref.parent.parent.id));
      } else {
        uids.push(usuarioLogado.uid);
      }

      const agrupadoPorLoja = {};
      let sobraEsperada = 0;
      let valorLiquidoTotal = 0;

      for (const uid of uids) {
        const ref = db.collection(`uid/${uid}/skusVendidos/${dataDoc}/lista`);
        const snap = await ref.get();
        for (const doc of snap.docs) {
          const { sku, total, loja, valorLiquido: valorSku } = doc.data();
          if (!agrupadoPorLoja[loja]) agrupadoPorLoja[loja] = [];

          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(uid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dados = querySnap.docs[0].data();
              custo = Number(dados.custo || 0);

            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }
          sobraEsperada += (total || 0) * custo;
          valorLiquidoTotal += Number(valorSku || 0);
          agrupadoPorLoja[loja].push({ sku, total, custo, valorLiquido: valorSku || 0 });
        }
      }

      // 🧾 Montar HTML
      let html = `<strong>📅 Detalhes de ${dataDoc}</strong><br><br>`;
      for (const loja in agrupadoPorLoja) {
        html += `<strong>🏪 Loja: ${loja}</strong>`;
        html += `<table style="width:100%; border-collapse: collapse; margin: 8px 0;">
          <thead>
            <tr style="background:#f0f0f0;">
              <th style="border:1px solid #ddd; padding:4px;">SKU</th>
              <th style="border:1px solid #ddd; padding:4px;">Unidades</th>
              <th style="border:1px solid #ddd; padding:4px;">Sobra Esperada</th>
              <th style="border:1px solid #ddd; padding:4px;">Valor Líquido</th>
            </tr>
          </thead>
          <tbody>`;
        agrupadoPorLoja[loja].forEach(({ sku, total, custo, valorLiquido }) => {
          const sobraItem = (total || 0) * (custo || 0);
          html += `<tr>
            <td style="border:1px solid #ddd; padding:4px;">${sku}</td>
            <td style="border:1px solid #ddd; padding:4px;">${total}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${sobraItem.toFixed(2)}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${(valorLiquido || 0).toFixed(2)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
      }

      html += `<hr><strong>📦 Sobra Esperada:</strong> R$ ${sobraEsperada.toFixed(2)}<br>`;
      html += `<strong>💰 Valor Líquido Real:</strong> R$ ${valorLiquidoTotal.toFixed(2)}<br>`;

      Swal.fire({
        title: 'Detalhamento por Loja',
        html: html,
        icon: 'info',
        confirmButtonText: 'Fechar'
      });
    };

    async function exportarVendasMes() {
      const filtroMes = document.getElementById('filtroMesVendas')?.value;
      if (!filtroMes) {
        alert('Selecione um mês para exportar.');
        return;
      }

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      const dados = [];
      const resumo = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        const [anoDoc, mesDoc] = dataDoc.split('-');
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        if (anoDoc !== anoFiltro || mesDoc !== mesFiltro) continue;

        const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaSnap = await db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`).get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total, loja, valorLiquido } = skuDoc.data();
          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(ownerUid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dadosProd = querySnap.docs[0].data();
              custo = Number(dadosProd.custo || 0);
            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }

          const sobraEsperada = (total || 0) * (custo || 0);
          const sobraReal = Number(valorLiquido || 0);
          const chave = sku || skuDoc.id;

          dados.push({
            Data: dataDoc,
            Loja: loja || '-',
            SKU: chave,
            Unidades: total || 0,
            SobraEsperada: sobraEsperada,
            SobraReal: sobraReal
          });

          if (!resumo[chave]) resumo[chave] = { sku: chave, total: 0, prejuizo: 0 };
          resumo[chave].total += total || 0;
          resumo[chave].prejuizo += (sobraEsperada - sobraReal);
        }
      }

      if (!dados.length) {
        alert('Nenhum dado de vendas encontrado para o mês selecionado.');
        return;
      }

      const itemsResumo = Object.values(resumo);
      const maiorEntrada = itemsResumo.reduce((a, b) => (b.total > a.total ? b : a));
      const menorEntrada = itemsResumo.reduce((a, b) =>
        (b.total > 0 && b.total < a.total ? b : a), { total: Infinity });
      const maiorPrejuizo = itemsResumo.reduce((a, b) => (b.prejuizo > a.prejuizo ? b : a));

      const resumoSheet = [
        { Resumo: 'Maior entrada', SKU: maiorEntrada.sku, Unidades: maiorEntrada.total },
        { Resumo: 'Menor entrada', SKU: menorEntrada.sku, Unidades: menorEntrada.total },
        { Resumo: 'Maior prejuízo', SKU: maiorPrejuizo.sku, Valor: maiorPrejuizo.prejuizo.toFixed(2) }
      ];

      const wsDados = XLSX.utils.json_to_sheet(dados);
      const wsResumo = XLSX.utils.json_to_sheet(resumoSheet);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsDados, 'Vendas');
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');
      XLSX.writeFile(wb, `vendas_${filtroMes}.xlsx`);
    }

    async function exportarFaturamentoExcel() {
 let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      for (const docData of snap.docs) {
 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
       for (const sub of subSnap.docs) {
          let d = sub.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          dataExport.push({
            Data: docData.id,
            Loja: d.loja || "Desconhecida",
            Bruto: d.valorBruto || 0,
            Taxas: d.taxasPlataforma || 0,
            Líquido: d.valorLiquido || 0,
            Vendas: d.qtdVendas || 0
          });
       }
      }

      if (dataExport.length === 0) {
        alert("Nenhum dado de faturamento encontrado.");
        return;
      }

      const ws = XLSX.utils.json_to_sheet(dataExport);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Faturamento");
      XLSX.writeFile(wb, "faturamento.xlsx");
    }
    
    async function carregarAcompanhamento() {
      const tbody = document.querySelector('#tabelaAcompanhamento tbody');
      const resumoEl = document.getElementById('resumoAcompanhamento');
      tbody.innerHTML = '<tr><td colspan="4">🔄 Carregando...</td></tr>';
      resumoEl.innerHTML = '';
 const metaBrutoDiario = parseFloat(localStorage.getItem('metaBrutoDiario')) || 0;
      const metaLiquidoDiario = parseFloat(localStorage.getItem('metaLiquidoDiario')) || 0;
     const metaBrutoInput = document.getElementById('metaBrutoDiario');
      if (metaBrutoInput) metaBrutoInput.value = metaBrutoDiario || '';
      const metaLiquidoInput = document.getElementById('metaLiquidoDiario');
      if (metaLiquidoInput) metaLiquidoInput.value = metaLiquidoDiario || '';
      
    let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value;
      const normalizarMes = valor => {
        if (!valor) return '';
        if (valor instanceof Date) {
          return `${valor.getFullYear()}-${String(valor.getMonth() + 1).padStart(2, '0')}`;
        }
        if (typeof valor?.toDate === 'function') {
          const dt = valor.toDate();
          return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, '0')}`;
        }
        const texto = String(valor);
        const match = texto.match(/(\d{4})[-/_](\d{1,2})/);
        if (match) {
          return `${match[1]}-${match[2].padStart(2, '0')}`;
        }
        return '';
      };
      const extrairMesReferencia = (docId, dadosSaque) => {
        const candidatos = [];
        if (docId) candidatos.push(docId);
        const campos = ['anoMes', 'mesReferencia', 'mes', 'competencia', 'data', 'dataReferencia'];
        for (const campo of campos) {
          if (dadosSaque && Object.prototype.hasOwnProperty.call(dadosSaque, campo)) {
            const normalizado = normalizarMes(dadosSaque[campo]);
            if (normalizado) return normalizado;
            if (typeof dadosSaque[campo] === 'string') candidatos.push(dadosSaque[campo]);
          }
        }
        for (const candidato of candidatos) {
          const normalizado = normalizarMes(candidato);
          if (normalizado) return normalizado;
        }
        return '';
      };
      let dados = [];
      dadosAcompanhamento = [];
      sobraPorSku = {};
      resumoSku = {};
      let totalBruto = 0, totalLiquido = 0, totalVendas = 0, totalSobra = 0;
      let totalSaques = 0,
        totalComissaoPrevista = 0,
        totalComissaoPaga = 0;
      const ownerUidsFiltro = new Set();

      for (const doc of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split('-');
          const [ano, mes] = doc.id.split('-');
          if (ano !== anoFiltro || mes !== mesFiltro) continue;
        }

  const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        if (ownerUid) ownerUidsFiltro.add(ownerUid);
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${doc.id}/lojas`);
        const subSnap = await subRef.get();
        let bruto = 0, liquido = 0, vendas = 0;
         for (const s of subSnap.docs) {
          let d = s.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          vendas += d.qtdVendas || 0;
        }

        let sobraDia = 0;
        try {
           let listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${doc.id}/lista`);

          const listaSnap = await listaRef.get();
          listaSnap.forEach(item => {
            const { sku, total, valorLiquido } = item.data();
            const custo = Number(produtos[sku] || 0);
            const quantidade = total || 0;
            const valor = quantidade * custo;
            const liquidoSku = valorLiquido || 0;
            sobraDia += valor;
            sobraPorSku[sku] = (sobraPorSku[sku] || 0) + valor;
            resumoSku[sku] = resumoSku[sku] || { vendas: 0, sobra: 0, liquido: 0 };
            resumoSku[sku].vendas += quantidade;
            resumoSku[sku].sobra += valor;
            resumoSku[sku].liquido += liquidoSku;
          });
        } catch (e) {
          console.warn('Erro ao calcular sobra esperada do dia', e);
        }

        dados.push({ data: doc.id, bruto, liquido, vendas, sobra: sobraDia });
        totalBruto += bruto;
        totalLiquido += liquido;
        totalVendas += vendas;
        totalSobra += sobraDia;
      }

      if (!ownerUidsFiltro.size && usuarioLogado?.uid) ownerUidsFiltro.add(usuarioLogado.uid);
      const mesSelecionado = filtroMes || (dados.length ? normalizarMes(dados[0].data) : '');
      let encontrouSaquesMensais = false;
      if (mesSelecionado && ownerUidsFiltro.size) {
        for (const uidFiltro of ownerUidsFiltro) {
          try {
            const resumoRef = db.collection('usuarios').doc(uidFiltro).collection('comissoes').doc(mesSelecionado);
            const resumoSnap = await resumoRef.get();
            let totalSaquesDetalhados = 0;
            let totalComissaoDetalhada = 0;
            let possuiDetalhes = false;
            try {
              const saquesSnap = await resumoRef.collection('saques').get();
              if (!saquesSnap.empty) {
                encontrouSaquesMensais = true;
                for (const saqueDoc of saquesSnap.docs) {
                  const dadosMensais = saqueDoc.data() || {};
                  const valorSaque = Number(dadosMensais.valor) || 0;
                  totalSaquesDetalhados += valorSaque;
                  const comissaoPagaDoc = Number(dadosMensais.comissaoPaga);
                  const percentualPago = Number(dadosMensais.percentualPago);
                  if (Number.isFinite(comissaoPagaDoc)) {
                    totalComissaoDetalhada += comissaoPagaDoc;
                  } else if (Number.isFinite(percentualPago) && percentualPago > 0) {
                    totalComissaoDetalhada += valorSaque * percentualPago;
                  }
                }
                possuiDetalhes = true;
              }
            } catch (e) {
              console.error('Erro ao carregar saques mensais detalhados', e);
            }
            const resumoExiste =
              typeof resumoSnap.exists === 'function'
                ? resumoSnap.exists()
                : resumoSnap.exists;
            if (resumoExiste) {
              let utilizouResumo = false;
              const dadosResumo = resumoSnap.data() || {};
              const totalSacadoResumo = Number(dadosResumo.totalSacado);
              const comissaoPrevistaResumo = Number(dadosResumo.comissaoPrevista);
              const comissaoJaPagaResumo = Number(
                dadosResumo.comissaoJaPaga ?? dadosResumo.comissaoRecebida,
              );
              const ajusteFinalResumo = Number(dadosResumo.ajusteFinal);
              let comissaoPagaResumo = Number.isFinite(comissaoJaPagaResumo)
                ? comissaoJaPagaResumo
                : NaN;
              if (
                !Number.isFinite(comissaoPagaResumo) &&
                Number.isFinite(comissaoPrevistaResumo) &&
                Number.isFinite(ajusteFinalResumo)
              ) {
                comissaoPagaResumo = comissaoPrevistaResumo - ajusteFinalResumo;
              }
              if (Number.isFinite(totalSacadoResumo)) {
                totalSaques += totalSacadoResumo;
                utilizouResumo = true;
              }
              if (Number.isFinite(comissaoPrevistaResumo)) {
                totalComissaoPrevista += comissaoPrevistaResumo;
                utilizouResumo = true;
              }
              if (Number.isFinite(comissaoPagaResumo)) {
                totalComissaoPaga += comissaoPagaResumo;
                utilizouResumo = true;
              }
              if (utilizouResumo) {
                encontrouSaquesMensais = true;
              } else if (possuiDetalhes) {
                totalSaques += totalSaquesDetalhados;
                totalComissaoPrevista += totalComissaoDetalhada;
                totalComissaoPaga += totalComissaoDetalhada;
              }
            } else if (possuiDetalhes) {
              totalSaques += totalSaquesDetalhados;
              totalComissaoPrevista += totalComissaoDetalhada;
              totalComissaoPaga += totalComissaoDetalhada;
            }
          } catch (e) {
            console.error('Erro ao carregar resumo de saques mensais', e);
          }
        }
      }
      if (!encontrouSaquesMensais) {
        try {
          let refSaques;
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            refSaques = db.collectionGroup('saques');
          } else {
            refSaques = db.collection('uid').doc(usuarioLogado.uid).collection('saques');
          }
          const snapSaques = await refSaques.get();
          for (const docS of snapSaques.docs) {
            const ownerUidSaques = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase()) ? docS.ref.parent.parent.id : usuarioLogado.uid;
            if (!ownerUidSaques) continue;
            if (ownerUidsFiltro.size && !ownerUidsFiltro.has(ownerUidSaques)) continue;
            let dadosSaque = docS.data();
            if (dadosSaque.encrypted) {
              try {
                const txt = await decryptString(dadosSaque.encrypted, getPassphrase() || `chave-${dadosSaque.uid || ownerUidSaques || usuarioLogado.uid}`);
                dadosSaque = JSON.parse(txt);
              } catch (e) {
                console.error('Erro ao descriptografar saque', e);
                continue;
              }
            }
            const mesDoc = extrairMesReferencia(docS.id, dadosSaque);
            if (mesSelecionado && mesDoc && mesDoc !== mesSelecionado) continue;
            if (mesSelecionado && !mesDoc) continue;
            const valorSaqueTotal = Number(dadosSaque.valorTotal || dadosSaque.valor || 0) || 0;
            totalSaques += valorSaqueTotal;
            try {
              const subRefSaque = db.collection(`uid/${ownerUidSaques}/saques/${docS.id}/lojas`);
              const subSnapSaque = await subRefSaque.get();
              for (const lojaDoc of subSnapSaque.docs) {
                let dadosLoja = lojaDoc.data();
                if (dadosLoja.encrypted) {
                  try {
                    const txtLoja = await decryptString(dadosLoja.encrypted, getPassphrase() || `chave-${dadosSaque.uid || ownerUidSaques}`);
                    dadosLoja = JSON.parse(txtLoja);
                  } catch (e) {
                    console.error('Erro ao descriptografar loja saque', e);
                    continue;
                  }
                }
                const valorLoja = parseFloat(dadosLoja.valor) || 0;
                const comissaoPct = parseFloat(dadosLoja.comissao) || 0;
                if (comissaoPct) {
                  const valorComissao = (valorLoja * comissaoPct) / 100;
                  totalComissaoPrevista += valorComissao;
                  totalComissaoPaga += valorComissao;
                }
              }
            } catch (e) {
              console.error('Erro ao carregar comissão dos saques', e);
            }
          }
        } catch (e) {
          console.error('Erro ao carregar saques', e);
        }
      }
      const totalComissaoAPagar = Math.max(0, totalComissaoPrevista - totalComissaoPaga);
      totalSaquesAcompanhamento = totalSaques;
      totalComissaoAcompanhamento = totalComissaoPrevista;
      totalComissaoPagaAcompanhamento = totalComissaoPaga;
      totalComissaoAPagarAcompanhamento = totalComissaoAPagar;

      tbody.innerHTML = '';
      dados.sort((a,b) => a.data.localeCompare(b.data));
      dadosAcompanhamento = dados.slice();
      dados.forEach(d => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${d.data}</td><td>R$ ${d.bruto.toLocaleString('pt-BR')}</td><td>R$ ${d.liquido.toLocaleString('pt-BR')}</td><td>${d.vendas}</td>`;
            if ((metaBrutoDiario && d.bruto < metaBrutoDiario) || (metaLiquidoDiario && d.liquido < metaLiquidoDiario)) {
          tr.classList.add('abaixo-meta');
        }
        tbody.appendChild(tr);
      });

 // Calcula totais a partir de dadosAcompanhamento
      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const ticket = totais.vendas ? totais.liquido / totais.vendas : 0;
const dias = dadosAcompanhamento.length;
      const totalMetaBruto = metaBrutoDiario * dias;
      const totalMetaLiquido = metaLiquidoDiario * dias;
      const diffBruto = totais.bruto - totalMetaBruto;
      const diffLiquido = totais.liquido - totalMetaLiquido;
      const percBruto = totalMetaBruto ? (diffBruto / totalMetaBruto) * 100 : 0;
      const percLiquido = totalMetaLiquido ? (diffLiquido / totalMetaLiquido) * 100 : 0;
      const resumoBrutoMeta = metaBrutoDiario ? `<small>${diffBruto >= 0 ? 'Acima' : 'Abaixo'} da meta (${percBruto.toFixed(2)}%, R$ ${Math.abs(diffBruto).toLocaleString('pt-BR')})</small>` : '';
      const resumoLiquidoMeta = metaLiquidoDiario ? `<small>${diffLiquido >= 0 ? 'Acima' : 'Abaixo'} da meta (${percLiquido.toFixed(2)}%, R$ ${Math.abs(diffLiquido).toLocaleString('pt-BR')})</small>` : '';
      
      resumoEl.classList.add('resumo-grid');
      resumoEl.innerHTML = `
        <div class="resumo-card"><h4>Total Bruto</h4><p>R$ ${totais.bruto.toLocaleString('pt-BR')}</p>${resumoBrutoMeta}</div>
        <div class="resumo-card"><h4>Total Líquido</h4><p>R$ ${totais.liquido.toLocaleString('pt-BR')}</p>${resumoLiquidoMeta}</div>
        <div class="resumo-card"><h4>Total Vendido</h4><p>${totais.vendas}</p><button class="btn btn-secondary btn-sm" style="margin-top:0.5rem" onclick="mostrarDetalhesVendas()">Ver mais</button></div>
        <div class="resumo-card"><h4>Total Saques</h4><p>R$ ${totalSaques.toLocaleString('pt-BR')}</p></div>
        <div class="resumo-card"><h4>Ticket Médio</h4><p>R$ ${ticket.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p></div>`;
    }

function mostrarDetalhesVendas(data = resumoSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'Não há informações de vendas por SKU para o período selecionado.', 'info');
    return;
  }

  const entries = Object.entries(data)
    .map(([sku, info]) => [sku, Number(info.vendas) || 0])
    .sort((a, b) => b[1] - a[1]);

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  let rows = '';
  for (const [sku, qtd] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${qtd}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Quantidade Vendida</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${total}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Vendas por SKU',
    html,
    width: '80%',
    confirmButtonText: 'Fechar'
  });
}

function mostrarDetalhesSobra(data = sobraPorSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'Não há informações de sobra esperada por SKU para o período selecionado.', 'info');
    return;
  }

  const fmtBRL = new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' });

  // entries = [['SKU1', 123.45], ...] — garantindo número válido
  const entries = Object.entries(data)
    .map(([sku, v]) => [sku, Number(v) || 0])
    .sort((a, b) => b[1] - a[1]); // ordem decrescente por valor

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  // Monta tabela
  let rows = '';
  for (const [sku, valor] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${fmtBRL.format(valor)}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Sobra Esperada</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${fmtBRL.format(total)}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Sobra Esperada por SKU',
    html,
    width: 720,
    confirmButtonText: 'OK'
  });
}

     function exportarAcompanhamentoExcel() {
      if (!dadosAcompanhamento.length) return;

      const mediaSaques = totalSaquesAcompanhamento / (dadosAcompanhamento.length || 1);
      const sheetData = dadosAcompanhamento.map(d => ({
        Data: d.data,
        Bruto: d.bruto,
        Liquido: d.liquido,
        Vendas: d.vendas,
        SobraEsperada: d.sobra,
        SobraReal: d.sobra - mediaSaques
      }));

      const wsVendas = XLSX.utils.json_to_sheet(sheetData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsVendas, 'Vendas');

      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const sobraRealTotal = totais.sobra - totalSaquesAcompanhamento;

      const entries = Object.entries(sobraPorSku || {});
      let maiorEntrada = ['', 0], menorEntrada = ['', 0], prejuizo = ['', 0];
      if (entries.length) {
        maiorEntrada = entries.reduce((a,b)=>b[1]>a[1]?b:a, entries[0]);
        menorEntrada = entries.reduce((a,b)=>b[1]<a[1]?b:a, entries[0]);
        const negativos = entries.filter(([,v])=>v<0);
        if (negativos.length) prejuizo = negativos.reduce((a,b)=>b[1]<a[1]?b:a, negativos[0]);
      }

      const resumo = [
        { Campo: 'Sobra Esperada Total', Valor: totais.sobra },
        { Campo: 'Sobra Real Total', Valor: sobraRealTotal },
        { Campo: 'Produto Maior Entrada', SKU: maiorEntrada[0], Valor: maiorEntrada[1] },
        { Campo: 'Produto Menor Entrada', SKU: menorEntrada[0], Valor: menorEntrada[1] }
      ];
      if (prejuizo[0]) resumo.push({ Campo: 'Produto Prejuízo', SKU: prejuizo[0], Valor: prejuizo[1] });

      const resumoSkus = Object.entries(resumoSku || {})
        .map(([sku, info]) => ({
          SKU: sku,
          Vendas: info.vendas,
          SobraEsperada: info.sobra,
          Liquido: info.liquido
        }))
        .sort((a, b) => b.Vendas - a.Vendas);

      const wsResumo = XLSX.utils.json_to_sheet(resumo);
      XLSX.utils.sheet_add_aoa(wsResumo, [[]], { origin: -1 });
      XLSX.utils.sheet_add_json(wsResumo, resumoSkus, { origin: -1 });
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');

      XLSX.writeFile(wb, 'acompanhamento.xlsx');
    }

    async function exportarResumoTopSkus() {
      if (!dadosAcompanhamento.length) {
        Swal.fire('Sem dados', 'Carregue o acompanhamento para exportar o resumo.', 'info');
        return;
      }

      const totalPecasVendidas = dadosAcompanhamento.reduce(
        (acc, item) => acc + (Number(item.vendas) || 0),
        0,
      );

      const topSkus = Object.entries(resumoSku || {})
        .map(([sku, info]) => ({
          sku,
          quantidade: Number(info?.vendas) || 0,
          valorLiquido: Number(info?.liquido) || 0,
        }))
        .filter(({ quantidade, valorLiquido }) => quantidade > 0 || valorLiquido > 0)
        .sort((a, b) => b.quantidade - a.quantidade)
        .slice(0, 15);

      if (!topSkus.length) {
        Swal.fire('Sem dados', 'Não há vendas por SKU para o período selecionado.', 'info');
        return;
      }

      const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value;
      const referenciaMes = (() => {
        if (filtroMes) return filtroMes;
        const hoje = new Date();
        return `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}`;
      })();

      const nomeUsuario = await obterNomeUsuarioAtual();
      const mesFormatado = formatarMesReferencia(referenciaMes) || referenciaMes;
      const numeroFormatter = new Intl.NumberFormat('pt-BR');
      const moedaFormatter = new Intl.NumberFormat('pt-BR', {
        style: 'currency',
        currency: 'BRL',
        maximumFractionDigits: 2,
      });

      const pdfElement = document.createElement('div');
      pdfElement.style.fontFamily = "'Inter', Arial, sans-serif";
      pdfElement.style.padding = '24px';
      pdfElement.style.width = '100%';
      pdfElement.style.maxWidth = '720px';

      pdfElement.innerHTML = `
        <div style="text-align: center; margin-bottom: 24px;">
          <div style="font-size: 14px; font-weight: 600; color: #1f2937; letter-spacing: 0.3px;">
            ${escapeHtml(nomeUsuario)}
          </div>
          <div style="font-size: 22px; font-weight: 700; margin-top: 6px; color: #111827;">
            PEÇAS VENDIDAS MÊS
          </div>
          <div style="font-size: 14px; color: #4b5563; margin-top: 6px; text-transform: capitalize;">
            ${escapeHtml(mesFormatado)}
          </div>
        </div>
        <div style="font-size: 13px; color: #1f2937; margin-bottom: 18px;">
          Total de peças vendidas no período: <strong>${numeroFormatter.format(totalPecasVendidas)}</strong>
        </div>
        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
          <thead>
            <tr>
              <th style="padding: 10px 12px; text-align: left; border-bottom: 2px solid #e5e7eb; color: #1f2937; font-weight: 600; background-color: #f3f4f6;">#</th>
              <th style="padding: 10px 12px; text-align: left; border-bottom: 2px solid #e5e7eb; color: #1f2937; font-weight: 600; background-color: #f3f4f6;">SKU</th>
              <th style="padding: 10px 12px; text-align: right; border-bottom: 2px solid #e5e7eb; color: #1f2937; font-weight: 600; background-color: #f3f4f6;">Peças vendidas</th>
              <th style="padding: 10px 12px; text-align: right; border-bottom: 2px solid #e5e7eb; color: #1f2937; font-weight: 600; background-color: #f3f4f6;">Valor líquido</th>
            </tr>
          </thead>
          <tbody>
            ${topSkus
              .map(
                ({ sku, quantidade, valorLiquido }, index) => `
                  <tr>
                    <td style="padding: 8px 12px; border-bottom: 1px solid #e5e7eb; color: #111827;">${index + 1}</td>
                    <td style="padding: 8px 12px; border-bottom: 1px solid #e5e7eb; color: #1f2937;">${escapeHtml(sku)}</td>
                    <td style="padding: 8px 12px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #1f2937;">${numeroFormatter.format(quantidade)}</td>
                    <td style="padding: 8px 12px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #065f46; font-weight: 600;">${moedaFormatter.format(valorLiquido)}</td>
                  </tr>
                `,
              )
              .join('')}
          </tbody>
        </table>
        <div style="font-size: 11px; color: #6b7280; margin-top: 16px; text-align: right;">
          Relatório gerado em ${escapeHtml(new Intl.DateTimeFormat('pt-BR', {
            dateStyle: 'medium',
            timeStyle: 'short',
          }).format(new Date()))}
        </div>
      `;

      const opt = {
        margin: [15, 12, 20, 12],
        filename: `top-15-skus_${referenciaMes}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
      };

      await html2pdf().set(opt).from(pdfElement).save();
    }

async function exportarAcompanhamentoPDF() {
  const element = document.getElementById('areaImpressao');
  if (!element) return;

  const nomeUsuario = escapeHtml(await obterNomeUsuarioAtual());
  const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value || '';

  let mesReferencia = filtroMes;
  if (!mesReferencia && Array.isArray(dadosAcompanhamento) && dadosAcompanhamento.length) {
    const primeiroRegistro = dadosAcompanhamento.find(item => item && item.data);
    if (primeiroRegistro?.data) {
      const [ano, mes] = String(primeiroRegistro.data).split('-');
      if (ano && mes) mesReferencia = `${ano}-${mes}`;
    }
  }

  let mesFormatado = '';
  if (mesReferencia) {
    const texto = formatarMesReferencia(mesReferencia);
    if (texto) mesFormatado = texto.charAt(0).toUpperCase() + texto.slice(1);
  }
  const mesLabel = escapeHtml(mesFormatado || 'Período completo');

  // === Clona o conteúdo a imprimir ===
  const clone = element.cloneNode(true);
  clone.style.marginTop = '16px';
  clone.style.width = '100%';
  clone.style.maxWidth = '100%';

  clone.querySelectorAll('.table-container').forEach(container => {
    container.style.overflow = 'visible';
    container.style.width = '100%';
    container.style.maxWidth = '100%';
  });

  const resumoClone = clone.querySelector('#resumoAcompanhamento');
  if (resumoClone) {
    resumoClone.style.display = 'grid';
    resumoClone.style.gridTemplateColumns = 'repeat(auto-fit, minmax(140px, 1fr))';
    resumoClone.style.gap = '12px';
  }

  clone.querySelectorAll('.resumo-card').forEach(card => {
    card.style.background = '#f9fafb';
    card.style.border = '1px solid #e5e7eb';
    card.style.borderRadius = '8px';
    card.style.padding = '12px';
    // manter "avoid" aqui é ok pois são blocos pequenos
    card.style.pageBreakInside = 'avoid';
  });

  clone.querySelectorAll('table').forEach(table => {
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';
    table.style.marginTop = '16px';
  });

  clone.querySelectorAll('th, td').forEach(cell => {
    cell.style.border = '1px solid #e5e7eb';
    cell.style.padding = '8px';
    cell.style.fontSize = '12px';
    // REMOVIDO: pageBreakInside: avoid (pode causar corte de página)
  });

  clone.querySelectorAll('tr').forEach(row => {
    // REMOVIDO: pageBreakInside: avoid (deixa quebrar quando necessário)
  });

  // === Wrapper formatado para A4 útil (210mm - 12mm - 12mm = 186mm) ===
  const wrapper = document.createElement('div');
  wrapper.style.fontFamily = "'Inter', 'Segoe UI', sans-serif";
  wrapper.style.padding = '16px 24px';
  wrapper.style.backgroundColor = '#ffffff';
  wrapper.style.width = '186mm';
  wrapper.style.maxWidth = '186mm';
  wrapper.style.boxSizing = 'border-box';

  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.justifyContent = 'space-between';
  header.style.alignItems = 'flex-start';
  header.style.marginBottom = '16px';
  header.style.paddingBottom = '12px';
  header.style.borderBottom = '1px solid #e5e7eb';
  header.innerHTML = `
    <div style="font-size:18px;font-weight:700;color:#111827;">Relatório de Acompanhamento Mensal</div>
    <div style="text-align:right;font-size:12px;color:#374151;line-height:1.4;">
      <div style="font-weight:600;">${nomeUsuario}</div>
      <div>${mesLabel}</div>
    </div>
  `;

  const styleBlock = document.createElement('style');
  styleBlock.textContent = `
    * { box-sizing: border-box; }
    .resumo-card h4 { font-size: 12px; margin-bottom: 4px; color: #111827; }
    .resumo-card p { font-size: 14px; font-weight: 600; color: #111827; margin: 0; }
    .resumo-card small { display: block; margin-top: 4px; font-size: 11px; color: #4b5563; }
    #tabelaAcompanhamento thead th { background: #f3f4f6; font-weight: 600; color: #1f2937; }
    #tabelaAcompanhamento tbody tr:nth-child(even) { background: #f9fafb; }
    #tabelaAcompanhamento tbody tr.abaixo-meta { background: #fef2f2; color: #991b1b; }
    #tabelaAcompanhamento tbody tr.abaixo-meta td { border-color: #fecaca; }
    table { table-layout: fixed; width: 100%; }
    th, td { word-wrap: break-word; word-break: break-word; }

    /* Permitir que a tabela quebre entre linhas/células quando necessário */
    tr, td, th {
      break-inside: auto !important;
      page-break-inside: auto !important;
    }

    .section-title { font-size: 14px; font-weight: 600; color: #374151; margin-top: 24px; margin-bottom: 8px; }

    /* Classe opcional para forçar quebra manual */
    .page-break {
      break-before: page;
      page-break-before: always;
    }

    @media print {
      .resumo-card { break-inside: avoid; page-break-inside: avoid; }
    }
  `;

  wrapper.appendChild(styleBlock);
  wrapper.appendChild(header);
  wrapper.appendChild(clone);

  // === Contêiner fora da tela, mas com dimensão real (nada de 0x0/overflow hidden) ===
  const tempContainer = document.createElement('div');
  tempContainer.style.position = 'absolute';
  tempContainer.style.left = '-9999px'; // offscreen sem clipping
  tempContainer.style.top = '0';
  tempContainer.style.width = 'auto';
  tempContainer.style.height = 'auto';
  tempContainer.style.overflow = 'visible';
  tempContainer.appendChild(wrapper);
  document.body.appendChild(tempContainer);

  // === Opções html2pdf/html2canvas seguras ===
  const opt = {
    margin: [10, 12, 16, 12],
    filename: 'acompanhamento.pdf',
    image: { type: 'jpeg', quality: 0.98 },
    html2canvas: {
      scale: 2,
      useCORS: true,
      // deixe o motor calcular o tamanho da área de render
      // windowWidth: wrapper.scrollWidth,
      // windowHeight: wrapper.scrollHeight,
      scrollX: 0,
      scrollY: 0
    },
    jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' },
    pagebreak: { mode: ['css', 'legacy'] } // respeita as regras CSS de quebra
  };

  try {
    await html2pdf().set(opt).from(wrapper).save();
  } finally {
    document.body.removeChild(tempContainer);
  }
}

const aguardarEntreDownloads = (tempo = 900) =>
  new Promise((resolve) => setTimeout(resolve, tempo));

async function baixarFechamentoMensal() {
  const botao = document.getElementById('btnFechamentoMensal');
  let htmlOriginal = '';

  if (botao) {
    htmlOriginal = botao.innerHTML;
    botao.disabled = true;
    botao.classList.add('opacity-80', 'pointer-events-none');
    botao.innerHTML =
      '<span class="flex items-center gap-2"><i class="fas fa-spinner fa-spin"></i> Gerando PDFs...</span>';
  }

  const etapas = [
    { nome: 'Fechamento de Saques', chave: 'imprimirFechamento' },
    { nome: 'Produtos Vendidos', chave: 'exportarProdutosVendidosPDF' },
    { nome: 'Top 15 SKUs', chave: 'exportarResumoTopSkus' },
    { nome: 'Previsão', chave: 'baixarPrevisaoPdf' },
    { nome: 'Acompanhamento', chave: 'exportarAcompanhamentoPDF' },
  ];

  const erros = [];

  for (const etapa of etapas) {
    const fn = window[etapa.chave];
    if (typeof fn !== 'function') {
      erros.push(`${etapa.nome} indisponível`);
      continue;
    }

    try {
      const retorno = fn();
      if (retorno instanceof Promise) {
        await retorno;
      }
      await aguardarEntreDownloads();
    } catch (error) {
      console.error(`Erro ao gerar PDF de ${etapa.nome}`, error);
      erros.push(`${etapa.nome} falhou`);
    }
  }

  if (botao) {
    botao.disabled = false;
    botao.classList.remove('opacity-80', 'pointer-events-none');
    botao.innerHTML = htmlOriginal;
  }

  if (erros.length) {
    if (typeof mostrarErro === 'function') {
      mostrarErro(`Não foi possível gerar todos os PDFs: ${erros.join(' | ')}`);
    } else {
      alert(`Não foi possível gerar todos os PDFs: ${erros.join(' | ')}`);
    }
    return;
  }

  if (typeof mostrarSucesso === 'function') {
    mostrarSucesso('Fechamento do mês gerado! Verifique os downloads em seu navegador.');
  } else {
    alert('Fechamento do mês gerado! Verifique os downloads em seu navegador.');
  }
}

    function printAcompanhamento() {
      const element = document.getElementById('areaImpressao');
      if (!element) return;
      const printWindow = window.open('', '', 'width=900,height=650');
      printWindow.document.write(`
        <html>
          <head>
            <title>Imprimir Acompanhamento</title>
            <link rel="stylesheet" href="css/styles.css?v=20240826">
          </head>
          <body>
            ${element.innerHTML}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
      printWindow.close();
    }
  
    function salvarMetasAcompanhamento() {
      const bruto = parseFloat(document.getElementById('metaBrutoDiario').value) || 0;
      const liquido = parseFloat(document.getElementById('metaLiquidoDiario').value) || 0;
      localStorage.setItem('metaBrutoDiario', bruto);
      localStorage.setItem('metaLiquidoDiario', liquido);
      carregarAcompanhamento();
    }

function aplicarEstiloCritico() {
  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const statusEl = linha.querySelector(".status-only");
    if (!statusEl) return;

    const status = statusEl.textContent.trim().toLowerCase();

    if (status === "crítico") {
      linha.style.backgroundColor = "#ffebee"; // fundo vermelho claro
      linha.style.color = "#b71c1c";            // texto vermelho escuro
      linha.style.fontWeight = "bold";
    } else {
      // Remove estilo se não for crítico (útil em reaplicações de filtro)
      linha.style.backgroundColor = "";
      linha.style.color = "";
      linha.style.fontWeight = "";
    }
  });
}
 window.toggleInfoFaturamento = function() {
    const card = document.getElementById('infoFaturamento');
    if (card) {
      card.classList.toggle('hidden');
    }
  };

  window.fecharFaturamentoMassaModal = function() {
    const modal = document.getElementById('massaFaturamentoModal');
    if (modal) {
      modal.style.display = 'none';
    }
  };


function normalizarNumeroDiario(valor) {
  const numero = Number(valor);
  return Number.isFinite(numero) ? numero : 0;
}

function normalizarPercentualDiario(valor) {
  if (valor === null || valor === undefined || valor === '') return null;
  const numero = Number(valor);
  return Number.isFinite(numero) ? numero : null;
}

function inferirMomentoDiarioPadrao() {
  const agora = new Date();
  const hora = agora.getHours();
  return hora < 12 ? 'inicio' : 'fim';
}

function obterTimestampReferencia(dados = {}) {
  if (!dados) return null;
  if (dados.atualizadoEm) return dados.atualizadoEm;
  if (dados.criadoEm) return dados.criadoEm;
  return null;
}

function calcularResumoTurnoDiario(dataRegistro, inicioDados = {}, fimDados = {}) {
  const diffPositivo = (campo) => {
    const fimValor = normalizarNumeroDiario(fimDados?.[campo]);
    const inicioValor = normalizarNumeroDiario(inicioDados?.[campo]);
    const delta = fimValor - inicioValor;
    return delta > 0 ? delta : 0;
  };

  const percentualInicio = (campo) =>
    normalizarPercentualDiario(inicioDados?.[campo]);
  const percentualFim = (campo) => {
    const fimValor = normalizarPercentualDiario(fimDados?.[campo]);
    if (fimValor !== null && fimValor !== undefined) return fimValor;
    return normalizarPercentualDiario(inicioDados?.[campo]);
  };

  const resumo = {
    data: dataRegistro,
    plataforma: String(fimDados?.plataforma || inicioDados?.plataforma || 'shopee'),
    nomeLoja: String(fimDados?.nomeLoja || inicioDados?.nomeLoja || ''),
    reclamacoesAbertas: diffPositivo('reclamacoesAbertas'),
    reclamacoesRespondidas: diffPositivo('reclamacoesRespondidas'),
    reclamacoesEncerradas: diffPositivo('reclamacoesEncerradas'),
    pedidosNaoEnviados: diffPositivo('pedidosNaoEnviados'),
    porcentagemReclamacoesInicio: percentualInicio('porcentagemReclamacoes'),
    porcentagemReclamacoesFim: percentualFim('porcentagemReclamacoes'),
    porcentagemCancelamentoInicio: percentualInicio('porcentagemCancelamento'),
    porcentagemCancelamentoFim: percentualFim('porcentagemCancelamento'),
    porcentagemAtrasoInicio: percentualInicio('porcentagemAtraso'),
    porcentagemAtrasoFim: percentualFim('porcentagemAtraso'),
    porcentagemMediacaoInicio: percentualInicio('porcentagemMediacao'),
    porcentagemMediacaoFim: percentualFim('porcentagemMediacao'),
    porcentagemReclamacoes: percentualFim('porcentagemReclamacoes') ?? 0,
    porcentagemCancelamento: percentualFim('porcentagemCancelamento') ?? 0,
    porcentagemAtraso: percentualFim('porcentagemAtraso') ?? 0,
    porcentagemMediacao: percentualFim('porcentagemMediacao') ?? 0,
    inicioRegistradoEm: obterTimestampReferencia(inicioDados),
    fimRegistradoEm: obterTimestampReferencia(fimDados),
    turnoResumo: 'automatico',
  };

  return resumo;
}

function criarAcumuladorPercentual() {
  return { sum: 0, count: 0 };
}

function adicionarPercentual(acumulador, valor) {
  if (!acumulador) return;
  const numero = normalizarPercentualDiario(valor);
  if (numero === null) return;
  acumulador.sum += numero;
  acumulador.count += 1;
}

function mediaPercentual(acumulador) {
  if (!acumulador || !acumulador.count) return null;
  return acumulador.sum / acumulador.count;
}

function obterNumeroDiarioCompat(registro, chaveNova, chaveLegado) {
  if (registro && Object.prototype.hasOwnProperty.call(registro, chaveNova)) {
    return normalizarNumeroDiario(registro[chaveNova]);
  }
  if (registro && Object.prototype.hasOwnProperty.call(registro, chaveLegado)) {
    return normalizarNumeroDiario(registro[chaveLegado]);
  }
  return 0;
}

function agruparRegistrosDiariosUsuario(registros) {
  const mapa = new Map();
  const totaisBase = {
    pedidosNaoEnviados: 0,
    reclamacoesAbertas: 0,
    reclamacoesRespondidas: 0,
    reclamacoesEncerradas: 0,
    percentuais: {
      reclamacoes: criarAcumuladorPercentual(),
      cancelamento: criarAcumuladorPercentual(),
      atraso: criarAcumuladorPercentual(),
      mediacao: criarAcumuladorPercentual(),
    },
  };

  registros.forEach((registro) => {
    const plataforma = String(registro.plataforma || '-');
    const nomeLoja = String(registro.nomeLoja || 'Sem loja');
    const chave = `${plataforma}||${nomeLoja}`;

    if (!mapa.has(chave)) {
      mapa.set(chave, {
        plataforma,
        nomeLoja,
        pedidosNaoEnviados: 0,
        reclamacoesAbertas: 0,
        reclamacoesRespondidas: 0,
        reclamacoesEncerradas: 0,
        percentuais: {
          reclamacoes: criarAcumuladorPercentual(),
          cancelamento: criarAcumuladorPercentual(),
          atraso: criarAcumuladorPercentual(),
          mediacao: criarAcumuladorPercentual(),
        },
      });
    }

    const item = mapa.get(chave);

    const pedidos = normalizarNumeroDiario(registro.pedidosNaoEnviados);
    const abertas = obterNumeroDiarioCompat(registro, 'reclamacoesAbertas', 'reclamacoesAbertas');
    const respondidas = obterNumeroDiarioCompat(registro, 'reclamacoesRespondidas', 'reclamacoesRecorridas');
    const encerradas = obterNumeroDiarioCompat(registro, 'reclamacoesEncerradas', 'reclamacoesRecusadas');

    item.pedidosNaoEnviados += pedidos;
    item.reclamacoesAbertas += abertas;
    item.reclamacoesRespondidas += respondidas;
    item.reclamacoesEncerradas += encerradas;

    totaisBase.pedidosNaoEnviados += pedidos;
    totaisBase.reclamacoesAbertas += abertas;
    totaisBase.reclamacoesRespondidas += respondidas;
    totaisBase.reclamacoesEncerradas += encerradas;

    adicionarPercentual(item.percentuais.reclamacoes, registro.porcentagemReclamacoes);
    adicionarPercentual(item.percentuais.cancelamento, registro.porcentagemCancelamento);
    adicionarPercentual(item.percentuais.atraso, registro.porcentagemAtraso);
    adicionarPercentual(item.percentuais.mediacao, registro.porcentagemMediacao);

    adicionarPercentual(totaisBase.percentuais.reclamacoes, registro.porcentagemReclamacoes);
    adicionarPercentual(totaisBase.percentuais.cancelamento, registro.porcentagemCancelamento);
    adicionarPercentual(totaisBase.percentuais.atraso, registro.porcentagemAtraso);
    adicionarPercentual(totaisBase.percentuais.mediacao, registro.porcentagemMediacao);
  });

  const linhas = Array.from(mapa.values())
    .map((item) => ({
      plataforma: item.plataforma,
      nomeLoja: item.nomeLoja,
      pedidosNaoEnviados: item.pedidosNaoEnviados,
      reclamacoesAbertas: item.reclamacoesAbertas,
      reclamacoesRespondidas: item.reclamacoesRespondidas,
      reclamacoesEncerradas: item.reclamacoesEncerradas,
      porcentagemReclamacoes: mediaPercentual(item.percentuais.reclamacoes),
      porcentagemCancelamento: mediaPercentual(item.percentuais.cancelamento),
      porcentagemAtraso: mediaPercentual(item.percentuais.atraso),
      porcentagemMediacao: mediaPercentual(item.percentuais.mediacao),
    }))
    .sort((a, b) => a.nomeLoja.localeCompare(b.nomeLoja, 'pt-BR'));

  const totais = {
    pedidosNaoEnviados: totaisBase.pedidosNaoEnviados,
    reclamacoesAbertas: totaisBase.reclamacoesAbertas,
    reclamacoesRespondidas: totaisBase.reclamacoesRespondidas,
    reclamacoesEncerradas: totaisBase.reclamacoesEncerradas,
    porcentagemReclamacoes: mediaPercentual(totaisBase.percentuais.reclamacoes),
    porcentagemCancelamento: mediaPercentual(totaisBase.percentuais.cancelamento),
    porcentagemAtraso: mediaPercentual(totaisBase.percentuais.atraso),
    porcentagemMediacao: mediaPercentual(totaisBase.percentuais.mediacao),
  };

  return { linhas, totais };
}

function agruparRegistrosDiariosGestor(registros) {
  const mapa = new Map();
  const totaisPorUsuario = new Map();
  const totaisGerais = {
    pedidosNaoEnviados: 0,
    reclamacoesAbertas: 0,
    reclamacoesRespondidas: 0,
    reclamacoesEncerradas: 0,
    percentuais: {
      reclamacoes: criarAcumuladorPercentual(),
      cancelamento: criarAcumuladorPercentual(),
      atraso: criarAcumuladorPercentual(),
      mediacao: criarAcumuladorPercentual(),
    },
  };

  registros.forEach((registro) => {
    const plataforma = String(registro.plataforma || '-');
    const nomeLoja = String(registro.nomeLoja || 'Sem loja');
    const usuarioUid = registro.usuarioUid || 'desconhecido';
    const usuarioNome = registro.usuarioNome || registro.usuarioEmail || usuarioUid;
    const chave = `${usuarioUid}||${plataforma}||${nomeLoja}`;

    if (!mapa.has(chave)) {
      mapa.set(chave, {
        usuarioUid,
        usuarioNome,
        plataforma,
        nomeLoja,
        pedidosNaoEnviados: 0,
        reclamacoesAbertas: 0,
        reclamacoesRespondidas: 0,
        reclamacoesEncerradas: 0,
        percentuais: {
          reclamacoes: criarAcumuladorPercentual(),
          cancelamento: criarAcumuladorPercentual(),
          atraso: criarAcumuladorPercentual(),
          mediacao: criarAcumuladorPercentual(),
        },
      });
    }
    const item = mapa.get(chave);

    if (!totaisPorUsuario.has(usuarioUid)) {
      totaisPorUsuario.set(usuarioUid, {
        usuarioUid,
        usuarioNome,
        pedidosNaoEnviados: 0,
        reclamacoesAbertas: 0,
        reclamacoesRespondidas: 0,
        reclamacoesEncerradas: 0,
        percentuais: {
          reclamacoes: criarAcumuladorPercentual(),
          cancelamento: criarAcumuladorPercentual(),
          atraso: criarAcumuladorPercentual(),
          mediacao: criarAcumuladorPercentual(),
        },
      });
    }
    const totalUsuario = totaisPorUsuario.get(usuarioUid);

    const pedidos = normalizarNumeroDiario(registro.pedidosNaoEnviados);
    const abertas = obterNumeroDiarioCompat(registro, 'reclamacoesAbertas', 'reclamacoesAbertas');
    const respondidas = obterNumeroDiarioCompat(registro, 'reclamacoesRespondidas', 'reclamacoesRecorridas');
    const encerradas = obterNumeroDiarioCompat(registro, 'reclamacoesEncerradas', 'reclamacoesRecusadas');

    item.pedidosNaoEnviados += pedidos;
    item.reclamacoesAbertas += abertas;
    item.reclamacoesRespondidas += respondidas;
    item.reclamacoesEncerradas += encerradas;

    totalUsuario.pedidosNaoEnviados += pedidos;
    totalUsuario.reclamacoesAbertas += abertas;
    totalUsuario.reclamacoesRespondidas += respondidas;
    totalUsuario.reclamacoesEncerradas += encerradas;

    totaisGerais.pedidosNaoEnviados += pedidos;
    totaisGerais.reclamacoesAbertas += abertas;
    totaisGerais.reclamacoesRespondidas += respondidas;
    totaisGerais.reclamacoesEncerradas += encerradas;

    adicionarPercentual(item.percentuais.reclamacoes, registro.porcentagemReclamacoes);
    adicionarPercentual(item.percentuais.cancelamento, registro.porcentagemCancelamento);
    adicionarPercentual(item.percentuais.atraso, registro.porcentagemAtraso);
    adicionarPercentual(item.percentuais.mediacao, registro.porcentagemMediacao);

    adicionarPercentual(totalUsuario.percentuais.reclamacoes, registro.porcentagemReclamacoes);
    adicionarPercentual(totalUsuario.percentuais.cancelamento, registro.porcentagemCancelamento);
    adicionarPercentual(totalUsuario.percentuais.atraso, registro.porcentagemAtraso);
    adicionarPercentual(totalUsuario.percentuais.mediacao, registro.porcentagemMediacao);

    adicionarPercentual(totaisGerais.percentuais.reclamacoes, registro.porcentagemReclamacoes);
    adicionarPercentual(totaisGerais.percentuais.cancelamento, registro.porcentagemCancelamento);
    adicionarPercentual(totaisGerais.percentuais.atraso, registro.porcentagemAtraso);
    adicionarPercentual(totaisGerais.percentuais.mediacao, registro.porcentagemMediacao);
  });

  const linhas = Array.from(mapa.values())
    .map((item) => ({
      usuarioUid: item.usuarioUid,
      usuarioNome: item.usuarioNome,
      plataforma: item.plataforma,
      nomeLoja: item.nomeLoja,
      pedidosNaoEnviados: item.pedidosNaoEnviados,
      reclamacoesAbertas: item.reclamacoesAbertas,
      reclamacoesRespondidas: item.reclamacoesRespondidas,
      reclamacoesEncerradas: item.reclamacoesEncerradas,
      porcentagemReclamacoes: mediaPercentual(item.percentuais.reclamacoes),
      porcentagemCancelamento: mediaPercentual(item.percentuais.cancelamento),
      porcentagemAtraso: mediaPercentual(item.percentuais.atraso),
      porcentagemMediacao: mediaPercentual(item.percentuais.mediacao),
    }))
    .sort((a, b) => {
      const cmpUsuario = a.usuarioNome.localeCompare(b.usuarioNome, 'pt-BR');
      if (cmpUsuario !== 0) return cmpUsuario;
      const cmpPlataforma = a.plataforma.localeCompare(b.plataforma, 'pt-BR');
      if (cmpPlataforma !== 0) return cmpPlataforma;
      return a.nomeLoja.localeCompare(b.nomeLoja, 'pt-BR');
    });

  const totais = {
    pedidosNaoEnviados: totaisGerais.pedidosNaoEnviados,
    reclamacoesAbertas: totaisGerais.reclamacoesAbertas,
    reclamacoesRespondidas: totaisGerais.reclamacoesRespondidas,
    reclamacoesEncerradas: totaisGerais.reclamacoesEncerradas,
    porcentagemReclamacoes: mediaPercentual(totaisGerais.percentuais.reclamacoes),
    porcentagemCancelamento: mediaPercentual(totaisGerais.percentuais.cancelamento),
    porcentagemAtraso: mediaPercentual(totaisGerais.percentuais.atraso),
    porcentagemMediacao: mediaPercentual(totaisGerais.percentuais.mediacao),
  };

  const totaisUsuarios = Array.from(totaisPorUsuario.values())
    .map((item) => ({
      usuarioUid: item.usuarioUid,
      usuarioNome: item.usuarioNome,
      pedidosNaoEnviados: item.pedidosNaoEnviados,
      reclamacoesAbertas: item.reclamacoesAbertas,
      reclamacoesRespondidas: item.reclamacoesRespondidas,
      reclamacoesEncerradas: item.reclamacoesEncerradas,
      porcentagemReclamacoes: mediaPercentual(item.percentuais.reclamacoes),
      porcentagemCancelamento: mediaPercentual(item.percentuais.cancelamento),
      porcentagemAtraso: mediaPercentual(item.percentuais.atraso),
      porcentagemMediacao: mediaPercentual(item.percentuais.mediacao),
    }))
    .sort((a, b) => a.usuarioNome.localeCompare(b.usuarioNome, 'pt-BR'));

  return { linhas, totais, totaisUsuarios };
}

function agruparResumosEquipeDiario(registros) {
  const mapa = new Map();

  registros.forEach((registro) => {
    const dataRegistro = String(registro.data || '');
    if (!dataRegistro) return;

    const resumoBase = registro.resumoDiario || calcularResumoTurnos(registro.turnos || {});
    if (!resumoBase) return;

    if (!mapa.has(dataRegistro)) {
      mapa.set(dataRegistro, {
        data: dataRegistro,
        totais: {
          reclamacoesAbertas: 0,
          reclamacoesRespondidas: 0,
          reclamacoesEncerradas: 0,
        },
        reputacoes: {
          reclamacoes: { inicio: criarAcumuladorPercentual(), fim: criarAcumuladorPercentual() },
          mediacao: { inicio: criarAcumuladorPercentual(), fim: criarAcumuladorPercentual() },
          atraso: { inicio: criarAcumuladorPercentual(), fim: criarAcumuladorPercentual() },
          cancelamento: { inicio: criarAcumuladorPercentual(), fim: criarAcumuladorPercentual() },
        },
      });
    }

    const agregado = mapa.get(dataRegistro);

    agregado.totais.reclamacoesAbertas += normalizarNumeroDiario(
      resumoBase.totais?.reclamacoesAbertas,
    );
    agregado.totais.reclamacoesRespondidas += normalizarNumeroDiario(
      resumoBase.totais?.reclamacoesRespondidas,
    );
    agregado.totais.reclamacoesEncerradas += normalizarNumeroDiario(
      resumoBase.totais?.reclamacoesEncerradas,
    );

    adicionarPercentual(agregado.reputacoes.reclamacoes.inicio, resumoBase.reputacoes?.reclamacoes?.inicio);
    adicionarPercentual(agregado.reputacoes.reclamacoes.fim, resumoBase.reputacoes?.reclamacoes?.fim);

    adicionarPercentual(agregado.reputacoes.mediacao.inicio, resumoBase.reputacoes?.mediacao?.inicio);
    adicionarPercentual(agregado.reputacoes.mediacao.fim, resumoBase.reputacoes?.mediacao?.fim);

    adicionarPercentual(agregado.reputacoes.atraso.inicio, resumoBase.reputacoes?.atraso?.inicio);
    adicionarPercentual(agregado.reputacoes.atraso.fim, resumoBase.reputacoes?.atraso?.fim);

    adicionarPercentual(agregado.reputacoes.cancelamento.inicio, resumoBase.reputacoes?.cancelamento?.inicio);
    adicionarPercentual(agregado.reputacoes.cancelamento.fim, resumoBase.reputacoes?.cancelamento?.fim);
  });

  const resumirReputacao = (info) => {
    const inicio = mediaPercentual(info.inicio);
    const fim = mediaPercentual(info.fim);
    return {
      inicio,
      fim,
      variacao: inicio === null || fim === null ? null : fim - inicio,
    };
  };

  return Array.from(mapa.values())
    .map((item) => ({
      data: item.data,
      totais: {
        reclamacoesAbertas: item.totais.reclamacoesAbertas,
        reclamacoesRespondidas: item.totais.reclamacoesRespondidas,
        reclamacoesEncerradas: item.totais.reclamacoesEncerradas,
      },
      reputacoes: {
        reclamacoes: resumirReputacao(item.reputacoes.reclamacoes),
        mediacao: resumirReputacao(item.reputacoes.mediacao),
        atraso: resumirReputacao(item.reputacoes.atraso),
        cancelamento: resumirReputacao(item.reputacoes.cancelamento),
      },
    }))
    .sort((a, b) => b.data.localeCompare(a.data));
}

let diarioCadastroDadosOriginais = new Map();
let diarioCadastroRemovidos = new Set();
let diarioTurnoAtual = 'inicio';

function formatarValorInputNumero(valor) {
  if (valor === null || valor === undefined || valor === '') return '';
  const numero = Number(valor);
  return Number.isFinite(numero) ? numero : '';
}

function formatarIdentificacaoLoja(linha) {
  const nome = String(linha?.nomeLoja || 'Loja').trim();
  const plataforma = String(linha?.plataforma || '').trim();
  if (!plataforma || plataforma === '-') {
    return nome;
  }
  return `${nome} (${plataforma})`;
}

function normalizarTurnoDiario(turno) {
  return turno === 'fim' ? 'fim' : 'inicio';
}

function obterTurnoAtualDiario() {
  return normalizarTurnoDiario(diarioTurnoAtual);
}

function definirTurnoAtualDiario(turno) {
  diarioTurnoAtual = normalizarTurnoDiario(turno);
}

function criarEstruturaTurnoVazia() {
  return {
    reclamacoesAbertas: 0,
    reclamacoesRespondidas: 0,
    reclamacoesEncerradas: 0,
    porcentagemReclamacoes: null,
    porcentagemMediacao: null,
    porcentagemAtraso: null,
    porcentagemCancelamento: null,
  };
}

function sanitizarDadosTurno(turno) {
  if (!turno) return criarEstruturaTurnoVazia();
  return {
    reclamacoesAbertas: normalizarNumeroDiario(turno.reclamacoesAbertas),
    reclamacoesRespondidas: normalizarNumeroDiario(turno.reclamacoesRespondidas),
    reclamacoesEncerradas: normalizarNumeroDiario(turno.reclamacoesEncerradas),
    porcentagemReclamacoes: normalizarPercentualDiario(turno.porcentagemReclamacoes),
    porcentagemMediacao: normalizarPercentualDiario(turno.porcentagemMediacao),
    porcentagemAtraso: normalizarPercentualDiario(turno.porcentagemAtraso),
    porcentagemCancelamento: normalizarPercentualDiario(turno.porcentagemCancelamento),
  };
}

function extrairDadosTurnoRegistro(registro, turno) {
  const chave = normalizarTurnoDiario(turno);
  const turnos = registro?.turnos || {};
  if (turnos[chave]) {
    return sanitizarDadosTurno(turnos[chave]);
  }

  const resumo = registro?.resumoDiario || {};
  if (resumo[chave]) {
    return sanitizarDadosTurno(resumo[chave]);
  }

  return criarEstruturaTurnoVazia();
}

function prepararDadosTurnoParaSalvar(registro) {
  return {
    reclamacoesAbertas: normalizarNumeroDiario(registro.reclamacoesAbertas),
    reclamacoesRespondidas: normalizarNumeroDiario(registro.reclamacoesRespondidas),
    reclamacoesEncerradas: normalizarNumeroDiario(registro.reclamacoesEncerradas),
    porcentagemReclamacoes: normalizarPercentualDiario(registro.porcentagemReclamacoes),
    porcentagemMediacao: normalizarPercentualDiario(registro.porcentagemMediacao),
    porcentagemAtraso: normalizarPercentualDiario(registro.porcentagemAtraso),
    porcentagemCancelamento: normalizarPercentualDiario(registro.porcentagemCancelamento),
  };
}

function calcularResumoPercentualTurnos(valorInicio, valorFim) {
  const inicio = normalizarPercentualDiario(valorInicio);
  const fim = normalizarPercentualDiario(valorFim);
  return {
    inicio,
    fim,
    variacao: inicio === null || fim === null ? null : fim - inicio,
  };
}

function calcularResumoTurnos(turnos) {
  const inicio = sanitizarDadosTurno(turnos?.inicio);
  const fim = sanitizarDadosTurno(turnos?.fim);

  if (!turnos?.inicio || !turnos?.fim) {
    return null;
  }

  const diferenca = (campo) => {
    const valorFim = normalizarNumeroDiario(fim[campo]);
    const valorInicio = normalizarNumeroDiario(inicio[campo]);
    const total = valorFim - valorInicio;
    return total >= 0 ? total : 0;
  };

  return {
    geradoEm: new Date().toISOString(),
    inicio,
    fim,
    totais: {
      reclamacoesAbertas: diferenca('reclamacoesAbertas'),
      reclamacoesRespondidas: diferenca('reclamacoesRespondidas'),
      reclamacoesEncerradas: diferenca('reclamacoesEncerradas'),
    },
    reputacoes: {
      reclamacoes: calcularResumoPercentualTurnos(inicio.porcentagemReclamacoes, fim.porcentagemReclamacoes),
      mediacao: calcularResumoPercentualTurnos(inicio.porcentagemMediacao, fim.porcentagemMediacao),
      atraso: calcularResumoPercentualTurnos(inicio.porcentagemAtraso, fim.porcentagemAtraso),
      cancelamento: calcularResumoPercentualTurnos(inicio.porcentagemCancelamento, fim.porcentagemCancelamento),
    },
  };
}

function renderListaValores(containerId, linhas, campo, formatador, opcoes = {}) {
  const container = document.getElementById(containerId);
  if (!container) return;

  if (!linhas.length) {
    container.innerHTML = `<p class="${opcoes.classeVazio || 'text-sm text-white/80'}">${opcoes.textoVazio || 'Sem registros'}</p>`;
    return;
  }

  container.innerHTML = linhas
    .map((linha) => {
      const nome = formatarIdentificacaoLoja(linha);
      const valorFormatado = formatador(linha?.[campo]);
      const valorDisplay =
        valorFormatado === undefined || valorFormatado === null || valorFormatado === ''
          ? '0'
          : valorFormatado;
      return `
        <div class="flex items-center justify-between gap-2">
          <span class="${opcoes.classeLoja || 'font-semibold uppercase tracking-tight'}">${escapeHtml(nome)}</span>
          <span class="${opcoes.classeSeparador || 'text-xs font-semibold uppercase tracking-[0.3em] opacity-70'}">=</span>
          <span class="${opcoes.classeValor || 'font-semibold'}">${escapeHtml(valorDisplay)}</span>
        </div>
      `;
    })
    .join('');
}

function atualizarDashboardDiarioForm() {
  const dados = obterDadosDasLojasEmTela();
  const linhasAgrupadas = dados.length ? agruparRegistrosDiariosUsuario(dados).linhas : [];

  renderListaValores('diarioStatusAbertasLista', linhasAgrupadas, 'reclamacoesAbertas', formatarNumeroPadrao, {
    textoVazio: 'Sem dados registrados',
    classeVazio: 'text-sm text-white/80',
  });

  renderListaValores('diarioStatusRespondidasLista', linhasAgrupadas, 'reclamacoesRespondidas', formatarNumeroPadrao, {
    textoVazio: 'Sem dados registrados',
    classeVazio: 'text-sm text-white/80',
  });

  renderListaValores('diarioStatusEncerradasLista', linhasAgrupadas, 'reclamacoesEncerradas', formatarNumeroPadrao, {
    textoVazio: 'Sem dados registrados',
    classeVazio: 'text-sm text-white/80',
  });

  renderListaValores('diarioReputacaoReclamacaoLista', linhasAgrupadas, 'porcentagemReclamacoes', formatarPercentualPadrao, {
    textoVazio: 'Sem informações do dia',
    classeVazio: 'text-sm text-pink-600/80',
    classeLoja: 'font-semibold text-pink-700 uppercase tracking-tight',
    classeValor: 'font-semibold text-pink-700',
  });

  renderListaValores('diarioReputacaoMediacaoLista', linhasAgrupadas, 'porcentagemMediacao', formatarPercentualPadrao, {
    textoVazio: 'Sem informações do dia',
    classeVazio: 'text-sm text-purple-600/80',
    classeLoja: 'font-semibold text-purple-700 uppercase tracking-tight',
    classeValor: 'font-semibold text-purple-700',
  });

  renderListaValores('diarioReputacaoAtrasoLista', linhasAgrupadas, 'porcentagemAtraso', formatarPercentualPadrao, {
    textoVazio: 'Sem informações do dia',
    classeVazio: 'text-sm text-sky-600/80',
    classeLoja: 'font-semibold text-sky-700 uppercase tracking-tight',
    classeValor: 'font-semibold text-sky-700',
  });

  renderListaValores('diarioReputacaoCanceladoLista', linhasAgrupadas, 'porcentagemCancelamento', formatarPercentualPadrao, {
    textoVazio: 'Sem informações do dia',
    classeVazio: 'text-sm text-fuchsia-600/80',
    classeLoja: 'font-semibold text-fuchsia-700 uppercase tracking-tight',
    classeValor: 'font-semibold text-fuchsia-700',
  });
}

function criarLinhaCadastroDiario(dados = {}) {
  const tabelaBody = document.querySelector('#diarioCadastroTabela tbody');
  if (!tabelaBody) return null;

  const tr = document.createElement('tr');
  tr.className = 'align-top';
  if (dados.docId) tr.dataset.docId = dados.docId;

  const nomeLoja = escapeHtml(dados.nomeLoja || '');
  const plataforma = String(dados.plataforma || 'shopee');
  const abertas = formatarValorInputNumero(dados.reclamacoesAbertas);
  const respondidas = formatarValorInputNumero(dados.reclamacoesRespondidas);
  const encerradas = formatarValorInputNumero(dados.reclamacoesEncerradas);
  const percReclamacao = formatarValorInputNumero(dados.porcentagemReclamacoes);
  const percMediacao = formatarValorInputNumero(dados.porcentagemMediacao);
  const percAtraso = formatarValorInputNumero(dados.porcentagemAtraso);
  const percCancelado = formatarValorInputNumero(dados.porcentagemCancelamento);

  tr.innerHTML = `
    <td class="px-4 py-3 min-w-[160px]">
      <input type="text" data-diario-field="nomeLoja" value="${nomeLoja}" placeholder="Nome da loja" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3">
      <select data-diario-field="plataforma" class="w-full border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-indigo-300 outline-none transition">
        <option value="shopee" ${plataforma === 'shopee' ? 'selected' : ''}>Shopee</option>
        <option value="mercado" ${plataforma === 'mercado' ? 'selected' : ''}>Mercado Livre</option>
        <option value="magalu" ${plataforma === 'magalu' ? 'selected' : ''}>Magalu</option>
        <option value="outros" ${plataforma === 'outros' ? 'selected' : ''}>Outros</option>
      </select>
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" min="0" data-diario-field="reclamacoesAbertas" value="${abertas}" class="w-24 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" min="0" data-diario-field="reclamacoesRespondidas" value="${respondidas}" class="w-24 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" min="0" data-diario-field="reclamacoesEncerradas" value="${encerradas}" class="w-24 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" step="0.01" min="0" data-diario-field="porcentagemReclamacoes" value="${percReclamacao}" class="w-28 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" step="0.01" min="0" data-diario-field="porcentagemMediacao" value="${percMediacao}" class="w-28 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" step="0.01" min="0" data-diario-field="porcentagemAtraso" value="${percAtraso}" class="w-28 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <input type="number" step="0.01" min="0" data-diario-field="porcentagemCancelamento" value="${percCancelado}" class="w-28 border border-gray-300 rounded-lg px-3 py-2 text-right focus:ring-2 focus:ring-indigo-300 outline-none transition" />
    </td>
    <td class="px-4 py-3 text-right">
      <button type="button" class="text-rose-500 hover:text-rose-600" data-diario-remover title="Remover loja">
        <i class="fas fa-trash-alt"></i>
      </button>
    </td>
  `;

  tabelaBody.appendChild(tr);

  tr.querySelectorAll('[data-diario-field]').forEach((elemento) => {
    const evento = elemento.tagName === 'SELECT' ? 'change' : 'input';
    elemento.addEventListener(evento, () => atualizarDashboardDiarioForm());
  });

  const removerBtn = tr.querySelector('[data-diario-remover]');
  if (removerBtn) {
    removerBtn.addEventListener('click', () => {
      const docId = tr.dataset.docId;
      if (docId) diarioCadastroRemovidos.add(docId);
      tr.remove();
      atualizarDashboardDiarioForm();
    });
  }

  return tr;
}

function obterDadosDasLojasEmTela() {
  const linhas = [];
  const rows = document.querySelectorAll('#diarioCadastroTabela tbody tr');
  rows.forEach((tr) => {
    const nomeLoja = (tr.querySelector('[data-diario-field="nomeLoja"]')?.value || '').trim();
    const plataforma = (tr.querySelector('[data-diario-field="plataforma"]')?.value || '').trim() || 'shopee';
    if (!nomeLoja) return;

    linhas.push({
      docId: tr.dataset.docId || '',
      nomeLoja,
      plataforma,
      reclamacoesAbertas: normalizarNumeroDiario(tr.querySelector('[data-diario-field="reclamacoesAbertas"]')?.value),
      reclamacoesRespondidas: normalizarNumeroDiario(tr.querySelector('[data-diario-field="reclamacoesRespondidas"]')?.value),
      reclamacoesEncerradas: normalizarNumeroDiario(tr.querySelector('[data-diario-field="reclamacoesEncerradas"]')?.value),
      porcentagemReclamacoes: normalizarPercentualDiario(tr.querySelector('[data-diario-field="porcentagemReclamacoes"]')?.value),
      porcentagemMediacao: normalizarPercentualDiario(tr.querySelector('[data-diario-field="porcentagemMediacao"]')?.value),
      porcentagemAtraso: normalizarPercentualDiario(tr.querySelector('[data-diario-field="porcentagemAtraso"]')?.value),
      porcentagemCancelamento: normalizarPercentualDiario(tr.querySelector('[data-diario-field="porcentagemCancelamento"]')?.value),
    });
  });
  return linhas;
}

async function obterEstruturaDiariaAnterior(dataAtual) {
  if (!db || !usuarioLogado?.uid) return [];
  try {
    const ref = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiario');
    const ultimoDiaSnap = await ref.orderBy('data', 'desc').where('data', '<', dataAtual).limit(1).get();
    if (ultimoDiaSnap.empty) {
      return [];
    }

    const dadosPrimeiro = ultimoDiaSnap.docs[0]?.data() || {};
    const dataAnterior = String(dadosPrimeiro.data || '');
    if (!dataAnterior) {
      return [];
    }

    const estruturaSnap = await ref.where('data', '==', dataAnterior).get();
    const lojas = [];
    estruturaSnap.forEach((doc) => {
      const dados = doc.data() || {};
      const nomeLoja = String(dados.nomeLoja || '').trim();
      if (!nomeLoja) return;
      lojas.push({
        nomeLoja,
        plataforma: String(dados.plataforma || 'shopee').trim() || 'shopee',
      });
    });

    return lojas;
  } catch (erro) {
    console.warn('Não foi possível recuperar a estrutura do dia anterior para o acompanhamento diário.', erro);
    return [];
  }
}

async function carregarCadastroDiarioDiaAtual() {
  const tabelaBody = document.querySelector('#diarioCadastroTabela tbody');
  if (!tabelaBody || !db || !usuarioLogado?.uid) return;

  const dataRegistro = document.getElementById('diarioData')?.value || obterDataIsoHoje();
  tabelaBody.innerHTML = '<tr><td colspan="10" class="px-4 py-3 text-center text-gray-500">Carregando informações do dia...</td></tr>';
  diarioCadastroDadosOriginais = new Map();
  diarioCadastroRemovidos = new Set();

  try {
    const turnoAtual = obterTurnoAtualDiario();
    const ref = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiario');
    const snap = await ref.get();
    const registros = [];

    snap.forEach((doc) => {
      const dados = doc.data() || {};
      if (String(dados.data || '') !== dataRegistro) return;
      registros.push({ docId: doc.id, ...dados });
      diarioCadastroDadosOriginais.set(doc.id, dados);
    });

    registros.sort((a, b) => {
      const lojaA = String(a.nomeLoja || '').toLocaleUpperCase('pt-BR');
      const lojaB = String(b.nomeLoja || '').toLocaleUpperCase('pt-BR');
      return lojaA.localeCompare(lojaB, 'pt-BR');
    });

    tabelaBody.innerHTML = '';
    if (!registros.length) {
      const estruturaAnterior = await obterEstruturaDiariaAnterior(dataRegistro);
      if (estruturaAnterior.length) {
        estruturaAnterior.forEach((registroBase) => {
          criarLinhaCadastroDiario({
            nomeLoja: registroBase.nomeLoja || '',
            plataforma: registroBase.plataforma || 'shopee',
            reclamacoesAbertas: 0,
            reclamacoesRespondidas: 0,
            reclamacoesEncerradas: 0,
            porcentagemReclamacoes: 0,
            porcentagemMediacao: 0,
            porcentagemAtraso: 0,
            porcentagemCancelamento: 0,
          });
        });
      } else {
        criarLinhaCadastroDiario();
      }
    } else {
      registros.forEach((registro) => {
        const dadosTurno = extrairDadosTurnoRegistro(registro, turnoAtual);
        criarLinhaCadastroDiario({
          docId: registro.docId,
          nomeLoja: registro.nomeLoja || '',
          plataforma: registro.plataforma || 'shopee',
          reclamacoesAbertas: dadosTurno.reclamacoesAbertas,
          reclamacoesRespondidas: dadosTurno.reclamacoesRespondidas,
          reclamacoesEncerradas: dadosTurno.reclamacoesEncerradas,
          porcentagemReclamacoes: dadosTurno.porcentagemReclamacoes,
          porcentagemMediacao: dadosTurno.porcentagemMediacao,
          porcentagemAtraso: dadosTurno.porcentagemAtraso,
          porcentagemCancelamento: dadosTurno.porcentagemCancelamento,
        });
      });
    }
  } catch (erro) {
    console.error('Erro ao carregar o acompanhamento diário do dia selecionado', erro);
    tabelaBody.innerHTML = '<tr><td colspan="10" class="px-4 py-3 text-center text-red-500">Erro ao carregar os registros do dia.</td></tr>';
    return;
  }

  atualizarDashboardDiarioForm();
}

function alternarSubPaginaDiaria(sub) {
  const cadastro = document.getElementById('diarioCadastroSection');
  const resumo = document.getElementById('diarioResumoSection');
  const botoes = document.querySelectorAll('#diariamente [data-diario-sub]');
  botoes.forEach((botao) => {
    const ativo = botao.dataset.diarioSub === sub;
    botao.classList.toggle('bg-indigo-600', ativo);
    botao.classList.toggle('text-white', ativo);
    botao.classList.toggle('bg-indigo-100', !ativo);
    botao.classList.toggle('text-indigo-700', !ativo);
  });

  if (sub === 'resumo') {
    cadastro?.classList.add('hidden');
    resumo?.classList.remove('hidden');
    carregarResumoDiario();
  } else {
    resumo?.classList.add('hidden');
    cadastro?.classList.remove('hidden');
  }
}

async function inicializarAbaDiaria() {
  const container = document.getElementById('diariamente');
  if (!container || container.dataset.initialized) return;

  const dataInput = document.getElementById('diarioData');
  if (dataInput && !dataInput.value) {
    dataInput.value = obterDataIsoHoje();
  }

  const turnoSelect = document.getElementById('diarioTurno');
  if (turnoSelect) {
    if (!turnoSelect.value) {
      const agora = new Date();
      const turnoPadrao = agora.getHours() >= 12 ? 'fim' : 'inicio';
      turnoSelect.value = turnoPadrao;
    }
    definirTurnoAtualDiario(turnoSelect.value);
    if (!turnoSelect.dataset.bound) {
      turnoSelect.addEventListener('change', () => {
        definirTurnoAtualDiario(turnoSelect.value);
        carregarCadastroDiarioDiaAtual().catch((erro) => {
          console.error('Erro ao carregar o acompanhamento diário para o turno selecionado', erro);
        });
      });
      turnoSelect.dataset.bound = 'true';
    }
  } else {
    definirTurnoAtualDiario('inicio');
  }

  const resumoMes = document.getElementById('diarioResumoMes');
  if (resumoMes && !resumoMes.value) {
    resumoMes.value = obterMesIsoAtual();
  }

  const resumoSemana = document.getElementById('diarioResumoSemana');
  if (resumoSemana && !resumoSemana.value) {
    resumoSemana.value = obterSemanaIsoAtual();
  }

  const salvarBtn = document.getElementById('diarioSalvar');
  if (salvarBtn && !salvarBtn.dataset.bound) {
    salvarBtn.addEventListener('click', salvarAcompanhamentoDiario);
    salvarBtn.dataset.bound = 'true';
  }

  const adicionarLojaBtn = document.getElementById('diarioAdicionarLoja');
  if (adicionarLojaBtn && !adicionarLojaBtn.dataset.bound) {
    adicionarLojaBtn.addEventListener('click', () => {
      criarLinhaCadastroDiario();
      atualizarDashboardDiarioForm();
    });
    adicionarLojaBtn.dataset.bound = 'true';
  }

  if (dataInput && !dataInput.dataset.bound) {
    dataInput.addEventListener('change', () => {
      carregarCadastroDiarioDiaAtual().catch((erro) => {
        console.error('Erro ao atualizar o acompanhamento diário do dia selecionado', erro);
      });
    });
    dataInput.dataset.bound = 'true';
  }

  const atualizarResumoBtn = document.getElementById('diarioResumoAtualizar');
  if (atualizarResumoBtn && !atualizarResumoBtn.dataset.bound) {
    atualizarResumoBtn.addEventListener('click', carregarResumoDiario);
    atualizarResumoBtn.dataset.bound = 'true';
  }

  if (resumoMes && !resumoMes.dataset.bound) {
    resumoMes.addEventListener('change', carregarResumoDiario);
    resumoMes.dataset.bound = 'true';
  }

  const exportarSemanaBtn = document.getElementById('diarioResumoExportarSemana');
  if (exportarSemanaBtn && !exportarSemanaBtn.dataset.bound) {
    exportarSemanaBtn.addEventListener('click', exportarResumoDiarioSemana);
    exportarSemanaBtn.dataset.bound = 'true';
  }

  const botoes = document.querySelectorAll('#diariamente [data-diario-sub]');
  botoes.forEach((botao) => {
    if (!botao.dataset.bound) {
      botao.addEventListener('click', () => alternarSubPaginaDiaria(botao.dataset.diarioSub));
      botao.dataset.bound = 'true';
    }
  });

  container.dataset.initialized = 'true';
  await carregarCadastroDiarioDiaAtual();
  alternarSubPaginaDiaria('cadastro');
  await carregarResumoDiario();
}

async function salvarAcompanhamentoDiario() {
  if (!db || !usuarioLogado?.uid) {
    mostrarErro('Não foi possível identificar o usuário logado.');
    return;
  }

  const dataRegistro = document.getElementById('diarioData')?.value || obterDataIsoHoje();
  const registros = obterDadosDasLojasEmTela();
  if (!registros.length) {
    mostrarErro('Informe ao menos uma loja para salvar o acompanhamento diário.');
    return;
  }

  const ref = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiario');
  const turnosRef = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiarioTurnos');
  const resumoRef = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiarioResumo');
  const momentoRegistro = inferirMomentoDiarioPadrao();
  const timestamp = (typeof firebase !== 'undefined' && firebase.firestore?.FieldValue?.serverTimestamp)
    ? () => firebase.firestore.FieldValue.serverTimestamp()
    : () => new Date().toISOString();

  const existentes = new Set(diarioCadastroDadosOriginais.keys());
  const idsMantidos = new Set();
  const operacoes = [];
  let baseResp = null;
  let respEmail = null;
  const turnoAtual = obterTurnoAtualDiario();

  try {
    const bases = await obterBasesUsuario();
    baseResp = bases.baseResp || null;
    respEmail = bases.respEmail || null;
  } catch (erroBases) {
    console.warn('Não foi possível carregar as bases adicionais para o acompanhamento diário', erroBases);
  }

  for (const registro of registros) {
    const plataforma = registro.plataforma || 'shopee';
    const docId = gerarIdDiario(dataRegistro, plataforma, registro.nomeLoja);
    idsMantidos.add(docId);

    const atualizadoEm = timestamp();
    const dadosOriginais = diarioCadastroDadosOriginais.get(registro.docId) || {};
    const turnosOriginais = dadosOriginais.turnos ? { ...dadosOriginais.turnos } : {};
    const dadosTurnoAtual = prepararDadosTurnoParaSalvar(registro);
    turnosOriginais[turnoAtual] = {
      ...dadosTurnoAtual,
      registradoEm: timestamp(),
    };

    const resumoCalculado = calcularResumoTurnos(turnosOriginais);
    const totaisResumo = resumoCalculado?.totais || {};
    const finaisReputacao = resumoCalculado
      ? {
          reclamacoes: resumoCalculado.reputacoes.reclamacoes.fim,
          mediacao: resumoCalculado.reputacoes.mediacao.fim,
          atraso: resumoCalculado.reputacoes.atraso.fim,
          cancelamento: resumoCalculado.reputacoes.cancelamento.fim,
        }
      : {
          reclamacoes: turnosOriginais[turnoAtual]?.porcentagemReclamacoes ?? null,
          mediacao: turnosOriginais[turnoAtual]?.porcentagemMediacao ?? null,
          atraso: turnosOriginais[turnoAtual]?.porcentagemAtraso ?? null,
          cancelamento: turnosOriginais[turnoAtual]?.porcentagemCancelamento ?? null,
        };

    const payloadBase = {
      data: dataRegistro,
      plataforma,
      nomeLoja: registro.nomeLoja,
      turnos: turnosOriginais,
      resumoDiario: resumoCalculado || null,
      turnoAtualizado: turnoAtual,
      reclamacoesAbertas: normalizarNumeroDiario(totaisResumo.reclamacoesAbertas),
      reclamacoesRespondidas: normalizarNumeroDiario(totaisResumo.reclamacoesRespondidas),
      reclamacoesEncerradas: normalizarNumeroDiario(totaisResumo.reclamacoesEncerradas),
      porcentagemReclamacoes: finaisReputacao.reclamacoes,
      porcentagemMediacao: finaisReputacao.mediacao,
      porcentagemAtraso: finaisReputacao.atraso,
      porcentagemCancelamento: finaisReputacao.cancelamento,
      reclamacoesRecorridas: normalizarNumeroDiario(totaisResumo.reclamacoesRespondidas),
      reclamacoesRecusadas: normalizarNumeroDiario(totaisResumo.reclamacoesEncerradas),
      uid: usuarioLogado.uid,
      atualizadoEm,
    };

    if (!existentes.has(docId)) {
      payloadBase.criadoEm = timestamp();
    }

    operacoes.push(ref.doc(docId).set(payloadBase, { merge: true }));

    if (baseResp && respEmail) {
      const payloadGestor = {
        ...payloadBase,
        atualizadoEm: timestamp(),
        origemUid: usuarioLogado.uid,
        responsavelFinanceiroEmail: respEmail,
      };
      if (!existentes.has(docId)) {
        payloadGestor.criadoEm = timestamp();
      }
      operacoes.push(baseResp.collection('acompanhamentoDiario').doc(docId).set(payloadGestor, { merge: true }));
    }

    if (registro.docId && registro.docId !== docId) {
      diarioCadastroRemovidos.add(registro.docId);
    }
    const turnoDocId = gerarIdDiarioTurno(dataRegistro, plataforma, registro.nomeLoja, momentoRegistro);
    const turnoDocRef = turnosRef.doc(turnoDocId);
    const turnoSnap = await turnoDocRef.get();
    const payloadTurno = {
      data: dataRegistro,
      plataforma,
      nomeLoja: registro.nomeLoja,
      momento: momentoRegistro,
      reclamacoesAbertas: registro.reclamacoesAbertas,
      reclamacoesRespondidas: registro.reclamacoesRespondidas,
      reclamacoesEncerradas: registro.reclamacoesEncerradas,
      porcentagemReclamacoes: registro.porcentagemReclamacoes,
      porcentagemMediacao: registro.porcentagemMediacao,
      porcentagemAtraso: registro.porcentagemAtraso,
      porcentagemCancelamento: registro.porcentagemCancelamento,
      reclamacoesRecorridas: registro.reclamacoesRespondidas,
      reclamacoesRecusadas: registro.reclamacoesEncerradas,
      uid: usuarioLogado.uid,
      atualizadoEm: timestamp(),
    };
    if (!turnoSnap.exists) {
      payloadTurno.criadoEm = timestamp();
    }
    operacoes.push(turnoDocRef.set(payloadTurno, { merge: true }));

    if (baseResp && respEmail) {
      const payloadTurnoGestor = {
        ...payloadTurno,
        atualizadoEm: timestamp(),
        origemUid: usuarioLogado.uid,
        responsavelFinanceiroEmail: respEmail,
      };
      if (!turnoSnap.exists) {
        payloadTurnoGestor.criadoEm = timestamp();
      }
      operacoes.push(
        baseResp.collection('acompanhamentoDiarioTurnos').doc(turnoDocId).set(payloadTurnoGestor, { merge: true }),
      );
    }

    if (momentoRegistro === 'fim') {
      const turnoInicioId = gerarIdDiarioTurno(dataRegistro, plataforma, registro.nomeLoja, 'inicio');
      const inicioSnap = await turnosRef.doc(turnoInicioId).get();
      if (inicioSnap.exists) {
        const inicioDados = inicioSnap.data() || {};
        const resumoCalculo = calcularResumoTurnoDiario(dataRegistro, inicioDados, payloadTurno);
        resumoCalculo.uid = usuarioLogado.uid;
        resumoCalculo.usuarioUid = usuarioLogado.uid;
        resumoCalculo.usuarioEmail = usuarioLogado.email || '';
        resumoCalculo.plataforma = plataforma;
        resumoCalculo.nomeLoja = registro.nomeLoja;
        resumoCalculo.atualizadoEm = timestamp();
        const resumoDocRef = resumoRef.doc(docId);
        const resumoSnap = await resumoDocRef.get();
        if (!resumoSnap.exists) {
          resumoCalculo.criadoEm = timestamp();
        }
        operacoes.push(resumoDocRef.set(resumoCalculo, { merge: true }));

        if (baseResp && respEmail) {
          const payloadResumoGestor = {
            ...resumoCalculo,
            atualizadoEm: timestamp(),
            origemUid: usuarioLogado.uid,
            responsavelFinanceiroEmail: respEmail,
          };
          if (!resumoSnap.exists) {
            payloadResumoGestor.criadoEm = timestamp();
          }
          operacoes.push(
            baseResp.collection('acompanhamentoDiarioResumo').doc(docId).set(payloadResumoGestor, { merge: true }),
          );
        }
      }
    }
  }

  const idsParaExcluir = new Set([...existentes, ...diarioCadastroRemovidos].filter((id) => !idsMantidos.has(id)));
  idsParaExcluir.forEach((docId) => {
    operacoes.push(ref.doc(docId).delete());
    if (baseResp && respEmail) {
      operacoes.push(baseResp.collection('acompanhamentoDiario').doc(docId).delete());
    }
    operacoes.push(turnosRef.doc(`${docId}__inicio`).delete());
    operacoes.push(turnosRef.doc(`${docId}__fim`).delete());
    operacoes.push(resumoRef.doc(docId).delete());
    if (baseResp && respEmail) {
      operacoes.push(baseResp.collection('acompanhamentoDiarioTurnos').doc(`${docId}__inicio`).delete());
      operacoes.push(baseResp.collection('acompanhamentoDiarioTurnos').doc(`${docId}__fim`).delete());
      operacoes.push(baseResp.collection('acompanhamentoDiarioResumo').doc(docId).delete());
    }
  });

  try {
    await Promise.all(operacoes);
  } catch (erro) {
    console.error('Erro ao salvar acompanhamento diário', erro);
    mostrarErro('Ocorreu um erro ao salvar as informações do dia. Tente novamente.');
    return;
  }

  mostrarSucesso('Informações diárias salvas com sucesso.');
  await carregarCadastroDiarioDiaAtual();
  await carregarResumoDiario();
}

async function carregarResumoDiario() {
  const tabelaBody = document.querySelector('#diarioResumoTabela tbody');
  const totaisContainer = document.getElementById('diarioResumoTotais');
  if (!tabelaBody) return;

  tabelaBody.innerHTML = '<tr><td colspan="9" class="text-center text-gray-500">Carregando registros...</td></tr>';
  if (totaisContainer) totaisContainer.innerHTML = '';

  try {
    const ref = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiario');
    const snap = await ref.get();
    const mesSelecionado = document.getElementById('diarioResumoMes')?.value || '';
    let inicio = null;
    let fim = null;
    if (mesSelecionado) {
      const [ano, mes] = mesSelecionado.split('-');
      if (ano && mes) {
        const ultimoDia = new Date(ano, mes, 0).getDate();
        inicio = `${mesSelecionado}-01`;
        fim = `${mesSelecionado}-${String(ultimoDia).padStart(2, '0')}`;
      }
    }

    const registros = [];
    snap.forEach((doc) => {
      const dados = doc.data() || {};
      const dataRegistro = String(dados.data || '');
      if (inicio && fim) {
        if (!dataRegistro || dataRegistro < inicio || dataRegistro > fim) return;
      }
      registros.push(dados);
    });

    if (!registros.length) {
      tabelaBody.innerHTML = '<tr><td colspan="9" class="text-center text-gray-500">Nenhum registro encontrado para o período selecionado.</td></tr>';
      return;
    }

    const { linhas, totais } = agruparRegistrosDiariosUsuario(registros);
    renderResumoDiarioTabela(linhas);
    renderResumoDiarioTotais(totais, mesSelecionado);
  } catch (error) {
    console.error('Erro ao carregar acompanhamento diário', error);
    tabelaBody.innerHTML = '<tr><td colspan="9" class="text-center text-red-500">Erro ao carregar os dados.</td></tr>';
  }
}

async function exportarResumoDiarioSemana() {
  if (typeof XLSX === 'undefined') {
    mostrarErro('Biblioteca de exportação indisponível no momento.');
    return;
  }

  if (!db || !usuarioLogado?.uid) {
    mostrarErro('Não foi possível identificar o usuário logado.');
    return;
  }

  const semanaValor = document.getElementById('diarioResumoSemana')?.value || '';
  if (!semanaValor) {
    mostrarErro('Selecione uma semana para exportar.');
    return;
  }

  const intervalo = calcularIntervaloSemana(semanaValor);
  if (!intervalo) {
    mostrarErro('Semana selecionada inválida para exportação.');
    return;
  }

  try {
    const ref = db.collection('uid').doc(usuarioLogado.uid).collection('acompanhamentoDiario');
    const snap = await ref.get();
    const registros = [];

    snap.forEach((doc) => {
      const dados = doc.data() || {};
      const dataRegistro = String(dados.data || '');
      if (!dataRegistro) return;
      if (dataRegistro < intervalo.inicio || dataRegistro > intervalo.fim) return;
      registros.push(dados);
    });

    if (!registros.length) {
      mostrarErro('Nenhum registro encontrado para a semana selecionada.');
      return;
    }

    const { linhas } = agruparRegistrosDiariosUsuario(registros);
    if (!linhas.length) {
      mostrarErro('Não há informações para exportar na semana selecionada.');
      return;
    }

    const cabecalho = [
      'Plataforma',
      'Loja',
      'Abertas',
      'Respondidas',
      'Encerradas',
      '% Reclamação',
      '% Mediação',
      '% Atraso',
      '% Cancelado',
    ];

    const formatarPercentual = (valor) => {
      if (valor === null || valor === undefined || Number.isNaN(Number(valor))) {
        return '-';
      }
      return `${Number(valor).toFixed(2)}%`;
    };

    const linhasPlanilha = linhas.map((linha) => [
      linha.plataforma,
      linha.nomeLoja,
      Number(linha.reclamacoesAbertas || 0),
      Number(linha.reclamacoesRespondidas || 0),
      Number(linha.reclamacoesEncerradas || 0),
      formatarPercentual(linha.porcentagemReclamacoes),
      formatarPercentual(linha.porcentagemMediacao),
      formatarPercentual(linha.porcentagemAtraso),
      formatarPercentual(linha.porcentagemCancelamento),
    ]);

    const worksheet = XLSX.utils.aoa_to_sheet([cabecalho, ...linhasPlanilha]);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Resumo semanal');

    const periodoArquivo =
      intervalo.inicio === intervalo.fim
        ? intervalo.inicio
        : `${intervalo.inicio}_a_${intervalo.fim}`;

    XLSX.writeFile(workbook, `acompanhamento-diario-semanal-${periodoArquivo}.xlsx`);
    mostrarSucesso('Resultado semanal exportado com sucesso.');
  } catch (erro) {
    console.error('Erro ao exportar resultado semanal do acompanhamento diário', erro);
    mostrarErro('Não foi possível exportar o resultado semanal no momento.');
  }
}

function renderResumoDiarioTabela(linhas) {
  const tabelaBody = document.querySelector('#diarioResumoTabela tbody');
  if (!tabelaBody) return;
  tabelaBody.innerHTML = '';

  linhas.forEach((linha) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="px-4 py-2">${escapeHtml(linha.plataforma)}</td>
      <td class="px-4 py-2">${escapeHtml(linha.nomeLoja)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesAbertas)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesRespondidas)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesEncerradas)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemReclamacoes)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemMediacao)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemAtraso)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemCancelamento)}</td>
    `;
    tabelaBody.appendChild(tr);
  });
}

function renderResumoDiarioTotais(totais, mesSelecionado) {
  const container = document.getElementById('diarioResumoTotais');
  if (!container) return;
  const mesLabel = mesSelecionado
    ? formatarMesReferencia(mesSelecionado) || mesSelecionado
    : 'Todos os registros';

  container.innerHTML = `
    <div class="space-y-4">
      <h4 class="text-lg font-semibold text-gray-700">Totais ${escapeHtml(mesLabel)}</h4>
      <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
        <div class="rounded-2xl p-5 text-white shadow-sm bg-rose-500/90">
          <p class="text-sm font-semibold uppercase tracking-wide">Reclamações abertas no período</p>
          <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesAbertas)}</p>
        </div>
        <div class="rounded-2xl p-5 text-white shadow-sm bg-amber-400/90">
          <p class="text-sm font-semibold uppercase tracking-wide">Reclamações respondidas no período</p>
          <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesRespondidas)}</p>
        </div>
        <div class="rounded-2xl p-5 text-white shadow-sm bg-emerald-500/90">
          <p class="text-sm font-semibold uppercase tracking-wide">Reclamações encerradas no período</p>
          <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesEncerradas)}</p>
        </div>
      </div>
      <div>
        <h5 class="text-base font-semibold text-gray-700 mb-3">Médias de reputação</h5>
        <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-4">
          <div class="rounded-2xl p-4 bg-pink-100 border border-pink-200">
            <p class="text-sm font-semibold text-pink-700 uppercase">Reclamação</p>
            <p class="mt-3 text-2xl font-bold text-pink-700">${formatarPercentualPadrao(totais.porcentagemReclamacoes)}</p>
          </div>
          <div class="rounded-2xl p-4 bg-purple-100 border border-purple-200">
            <p class="text-sm font-semibold text-purple-700 uppercase">Mediação</p>
            <p class="mt-3 text-2xl font-bold text-purple-700">${formatarPercentualPadrao(totais.porcentagemMediacao)}</p>
          </div>
          <div class="rounded-2xl p-4 bg-sky-100 border border-sky-200">
            <p class="text-sm font-semibold text-sky-700 uppercase">Atraso</p>
            <p class="mt-3 text-2xl font-bold text-sky-700">${formatarPercentualPadrao(totais.porcentagemAtraso)}</p>
          </div>
          <div class="rounded-2xl p-4 bg-fuchsia-100 border border-fuchsia-200">
            <p class="text-sm font-semibold text-fuchsia-700 uppercase">Cancelado</p>
            <p class="mt-3 text-2xl font-bold text-fuchsia-700">${formatarPercentualPadrao(totais.porcentagemCancelamento)}</p>
          </div>
        </div>
      </div>
    </div>
  `;
}

async function inicializarDiarioGestor() {
  const container = document.getElementById('diariamenteGestor');
  if (!container || container.dataset.initialized) return;

  const mesInput = document.getElementById('diarioGestorMes');
  if (mesInput && !mesInput.value) {
    mesInput.value = obterMesIsoAtual();
  }

  const atualizarBtn = document.getElementById('diarioGestorAtualizar');
  if (atualizarBtn && !atualizarBtn.dataset.bound) {
    atualizarBtn.addEventListener('click', carregarDiarioGestor);
    atualizarBtn.dataset.bound = 'true';
  }

  if (mesInput && !mesInput.dataset.bound) {
    mesInput.addEventListener('change', carregarDiarioGestor);
    mesInput.dataset.bound = 'true';
  }

  container.dataset.initialized = 'true';
  await carregarDiarioGestor();
}

async function carregarDiarioGestor() {
  const tabelaBody = document.querySelector('#diarioGestorTabela tbody');
  const totaisContainer = document.getElementById('diarioGestorTotais');
  const usuariosContainer = document.getElementById('diarioGestorUsuarios');
  const resumoEquipeContainer = document.getElementById('diarioGestorResumoEquipe');
  if (tabelaBody) {
    tabelaBody.innerHTML = '<tr><td colspan="10" class="text-center text-gray-500">Carregando registros...</td></tr>';
  }
  if (totaisContainer) totaisContainer.innerHTML = '';
  if (usuariosContainer) usuariosContainer.innerHTML = '';
  if (resumoEquipeContainer) resumoEquipeContainer.innerHTML = '';

  try {
    const usuariosSnap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .get();
    const usuarios = [];
    usuariosSnap.forEach((doc) => usuarios.push({ uid: doc.id, ...doc.data() }));

    if (!usuarios.length) {
      if (tabelaBody) {
        tabelaBody.innerHTML = '<tr><td colspan="10" class="text-center text-gray-500">Nenhum usuário vinculado encontrado.</td></tr>';
      }
      return;
    }

    const mesSelecionado = document.getElementById('diarioGestorMes')?.value || '';
    let inicio = null;
    let fim = null;
    if (mesSelecionado) {
      const [ano, mes] = mesSelecionado.split('-');
      if (ano && mes) {
        const ultimoDia = new Date(ano, mes, 0).getDate();
        inicio = `${mesSelecionado}-01`;
        fim = `${mesSelecionado}-${String(ultimoDia).padStart(2, '0')}`;
      }
    }

    const registros = [];
    await Promise.all(
      usuarios.map(async (usuario) => {
        const snap = await db.collection('uid').doc(usuario.uid).collection('acompanhamentoDiario').get();
        snap.forEach((doc) => {
          const dados = doc.data() || {};
          const dataRegistro = String(dados.data || '');
          if (inicio && fim) {
            if (!dataRegistro || dataRegistro < inicio || dataRegistro > fim) return;
          }
          registros.push({
            ...dados,
            usuarioUid: usuario.uid,
            usuarioNome: usuario.nome || usuario.email || usuario.uid,
            usuarioEmail: usuario.email || '',
          });
        });
      })
    );

    if (!registros.length) {
      if (tabelaBody) {
        tabelaBody.innerHTML = '<tr><td colspan="10" class="text-center text-gray-500">Nenhum registro encontrado para o período selecionado.</td></tr>';
      }
      if (resumoEquipeContainer) {
        renderResumoEquipeGestor([]);
      }
      return;
    }

    const { linhas, totais, totaisUsuarios } = agruparRegistrosDiariosGestor(registros);
    const resumosEquipe = agruparResumosEquipeDiario(registros);
    renderTabelaDiarioGestor(linhas);
    renderTotaisDiarioGestor(totais, totaisUsuarios, mesSelecionado);
    renderResumoEquipeGestor(resumosEquipe);
  } catch (error) {
    console.error('Erro ao carregar acompanhamento diário do gestor', error);
    if (tabelaBody) {
      tabelaBody.innerHTML = '<tr><td colspan="10" class="text-center text-red-500">Erro ao carregar dados.</td></tr>';
    }
  }
}

function renderTabelaDiarioGestor(linhas) {
  const tabelaBody = document.querySelector('#diarioGestorTabela tbody');
  if (!tabelaBody) return;
  tabelaBody.innerHTML = '';

  linhas.forEach((linha) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="px-4 py-2">${escapeHtml(linha.usuarioNome)}</td>
      <td class="px-4 py-2">${escapeHtml(linha.plataforma)}</td>
      <td class="px-4 py-2">${escapeHtml(linha.nomeLoja)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesAbertas)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesRespondidas)}</td>
      <td class="px-4 py-2 text-right">${formatarNumeroPadrao(linha.reclamacoesEncerradas)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemReclamacoes)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemMediacao)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemAtraso)}</td>
      <td class="px-4 py-2 text-right">${formatarPercentualPadrao(linha.porcentagemCancelamento)}</td>
    `;
    tabelaBody.appendChild(tr);
  });
}

function renderTotaisDiarioGestor(totais, totaisUsuarios, mesSelecionado) {
  const totaisContainer = document.getElementById('diarioGestorTotais');
  const usuariosContainer = document.getElementById('diarioGestorUsuarios');
  const mesLabel = mesSelecionado
    ? formatarMesReferencia(mesSelecionado) || mesSelecionado
    : 'Todos os registros';

  if (totaisContainer) {
    totaisContainer.innerHTML = `
      <div class="space-y-4">
        <h4 class="text-lg font-semibold text-gray-700">Totais gerais ${escapeHtml(mesLabel)}</h4>
        <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          <div class="rounded-2xl p-5 text-white shadow-sm bg-rose-500/90">
            <p class="text-sm font-semibold uppercase tracking-wide">Reclamações abertas</p>
            <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesAbertas)}</p>
          </div>
          <div class="rounded-2xl p-5 text-white shadow-sm bg-amber-400/90">
            <p class="text-sm font-semibold uppercase tracking-wide">Reclamações respondidas</p>
            <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesRespondidas)}</p>
          </div>
          <div class="rounded-2xl p-5 text-white shadow-sm bg-emerald-500/90">
            <p class="text-sm font-semibold uppercase tracking-wide">Reclamações encerradas</p>
            <p class="mt-4 text-3xl font-bold">${formatarNumeroPadrao(totais.reclamacoesEncerradas)}</p>
          </div>
        </div>
        <div>
          <h5 class="text-base font-semibold text-gray-700 mb-3">Médias de reputação</h5>
          <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-4">
            <div class="rounded-2xl p-4 bg-pink-100 border border-pink-200">
              <p class="text-sm font-semibold text-pink-700 uppercase">Reclamação</p>
              <p class="mt-3 text-2xl font-bold text-pink-700">${formatarPercentualPadrao(totais.porcentagemReclamacoes)}</p>
            </div>
            <div class="rounded-2xl p-4 bg-purple-100 border border-purple-200">
              <p class="text-sm font-semibold text-purple-700 uppercase">Mediação</p>
              <p class="mt-3 text-2xl font-bold text-purple-700">${formatarPercentualPadrao(totais.porcentagemMediacao)}</p>
            </div>
            <div class="rounded-2xl p-4 bg-sky-100 border border-sky-200">
              <p class="text-sm font-semibold text-sky-700 uppercase">Atraso</p>
              <p class="mt-3 text-2xl font-bold text-sky-700">${formatarPercentualPadrao(totais.porcentagemAtraso)}</p>
            </div>
            <div class="rounded-2xl p-4 bg-fuchsia-100 border border-fuchsia-200">
              <p class="text-sm font-semibold text-fuchsia-700 uppercase">Cancelado</p>
              <p class="mt-3 text-2xl font-bold text-fuchsia-700">${formatarPercentualPadrao(totais.porcentagemCancelamento)}</p>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  if (usuariosContainer) {
    if (!totaisUsuarios.length) {
      usuariosContainer.innerHTML = '<p class="text-gray-500">Nenhum dado por usuário no período selecionado.</p>';
      return;
    }

    usuariosContainer.innerHTML = `
      <h4 class="text-lg font-semibold text-gray-700 mt-6">Totais por usuário</h4>
      <div class="space-y-4">
        ${totaisUsuarios
          .map((usuario) => `
            <div class="border border-gray-200 rounded-lg p-4">
              <div class="font-semibold text-gray-800 mb-2">${escapeHtml(usuario.usuarioNome)}</div>
              <div class="grid gap-4 md:grid-cols-3">
                <div>
                  <p class="text-sm text-gray-600">Abertas</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarNumeroPadrao(usuario.reclamacoesAbertas)}</p>
                </div>
                <div>
                  <p class="text-sm text-gray-600">Respondidas</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarNumeroPadrao(usuario.reclamacoesRespondidas)}</p>
                </div>
                <div>
                  <p class="text-sm text-gray-600">Encerradas</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarNumeroPadrao(usuario.reclamacoesEncerradas)}</p>
                </div>
              </div>
              <div class="grid gap-4 md:grid-cols-2 xl:grid-cols-4 mt-3">
                <div>
                  <p class="text-sm text-gray-600">% Reclamação</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarPercentualPadrao(usuario.porcentagemReclamacoes)}</p>
                </div>
                <div>
                  <p class="text-sm text-gray-600">% Mediação</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarPercentualPadrao(usuario.porcentagemMediacao)}</p>
                </div>
                <div>
                  <p class="text-sm text-gray-600">% Atraso</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarPercentualPadrao(usuario.porcentagemAtraso)}</p>
                </div>
                <div>
                  <p class="text-sm text-gray-600">% Cancelado</p>
                  <p class="text-lg font-semibold text-gray-700">${formatarPercentualPadrao(usuario.porcentagemCancelamento)}</p>
                </div>
              </div>
            </div>
          `)
          .join('')}
      </div>
    `;
  }
}

function renderResumoEquipeGestor(resumos) {
  const container = document.getElementById('diarioGestorResumoEquipe');
  if (!container) return;

  if (!Array.isArray(resumos) || !resumos.length) {
    container.innerHTML = `
      <div class="rounded-2xl border border-dashed border-indigo-200 bg-indigo-50/30 p-6 text-sm text-indigo-700">
        Registre os dois turnos do acompanhamento diário para gerar o comparativo automático das equipes.
      </div>
    `;
    return;
  }

  const maxDias = 10;
  const dias = resumos.slice(0, maxDias);

  const formatarDataResumo = (valor) => {
    try {
      const data = new Date(`${valor}T00:00:00`);
      if (Number.isNaN(data.valueOf())) return valor;
      return new Intl.DateTimeFormat('pt-BR', {
        day: '2-digit',
        month: 'long',
        year: 'numeric',
      }).format(data);
    } catch (erro) {
      return valor;
    }
  };

  const formatarVariacao = (valor) => {
    if (valor === null || valor === undefined || Number.isNaN(Number(valor))) {
      return 'Variação indisponível';
    }
    const numero = Number(valor);
    const sinal = numero > 0 ? '+' : '';
    return `Variação ${sinal}${numero.toFixed(2)} pp`;
  };

  const renderReputacao = (titulo, info, classe) => {
    const dados = info || { inicio: null, fim: null, variacao: null };
    return `
    <div class="rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
      <p class="text-xs font-semibold uppercase ${classe}">${escapeHtml(titulo)}</p>
      <p class="mt-2 text-base font-semibold text-gray-700">${escapeHtml(
        `${formatarPercentualPadrao(dados.inicio)} → ${formatarPercentualPadrao(dados.fim)}`,
      )}</p>
      <p class="text-xs text-gray-500">${escapeHtml(formatarVariacao(dados.variacao))}</p>
    </div>
  `;
  };

  const cards = dias
    .map((dia) => {
      const abertas = formatarNumeroPadrao(dia.totais.reclamacoesAbertas);
      const respondidas = formatarNumeroPadrao(dia.totais.reclamacoesRespondidas);
      const encerradas = formatarNumeroPadrao(dia.totais.reclamacoesEncerradas);

      return `
        <article class="rounded-3xl border border-indigo-100 bg-gradient-to-br from-white via-white to-indigo-50/40 p-6 shadow">
          <div class="flex flex-col gap-2 md:flex-row md:items-center md:justify-between">
            <div>
              <h5 class="text-lg font-semibold text-gray-800">${escapeHtml(formatarDataResumo(dia.data))}</h5>
              <p class="text-sm text-gray-500">Comparativo entre início (07h) e encerramento (16h30).</p>
            </div>
            <span class="text-xs font-semibold uppercase tracking-[0.3em] text-indigo-500">Resumo diário</span>
          </div>
          <div class="mt-5 grid gap-4 md:grid-cols-3">
            <div class="rounded-xl bg-rose-50 p-4 border border-rose-100">
              <p class="text-xs font-semibold uppercase text-rose-600">Mensagens abertas</p>
              <p class="mt-2 text-2xl font-bold text-rose-700">${escapeHtml(abertas)}</p>
            </div>
            <div class="rounded-xl bg-amber-50 p-4 border border-amber-100">
              <p class="text-xs font-semibold uppercase text-amber-600">Mensagens respondidas</p>
              <p class="mt-2 text-2xl font-bold text-amber-700">${escapeHtml(respondidas)}</p>
            </div>
            <div class="rounded-xl bg-emerald-50 p-4 border border-emerald-100">
              <p class="text-xs font-semibold uppercase text-emerald-600">Mensagens encerradas</p>
              <p class="mt-2 text-2xl font-bold text-emerald-700">${escapeHtml(encerradas)}</p>
            </div>
          </div>
          <div class="mt-5 grid gap-4 md:grid-cols-2 xl:grid-cols-4">
            ${renderReputacao('Reclamação', dia.reputacoes.reclamacoes, 'text-pink-600')}
            ${renderReputacao('Mediação', dia.reputacoes.mediacao, 'text-purple-600')}
            ${renderReputacao('Atraso', dia.reputacoes.atraso, 'text-sky-600')}
            ${renderReputacao('Cancelado', dia.reputacoes.cancelamento, 'text-fuchsia-600')}
          </div>
        </article>
      `;
    })
    .join('');

  container.innerHTML = `
    <div class="space-y-4">
      <h4 class="text-lg font-semibold text-gray-700">Resumo da equipe por dia</h4>
      <div class="space-y-5">${cards}</div>
      ${resumos.length > maxDias
        ? `<p class="text-xs text-gray-500">Exibindo os ${maxDias} resumos mais recentes.</p>`
        : ''}
    </div>
  `;
}

function filtrarPorSKU() {
  const tipoFiltro = document.getElementById('tipoFiltro').value;
  const textoSKU = document.getElementById('filtroSKU').value.trim().toLowerCase();
  const filtroStatus = document.getElementById('filtroStatus').value.toLowerCase();

  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const sku = linha.children[1].textContent.toLowerCase();
    const status = linha.querySelector('.status-only')?.dataset.status.toLowerCase() || '';

    let corresponde = false;

    if (textoSKU === '') {
      corresponde = true;
    } else if (tipoFiltro === 'exata') {
      corresponde = sku === textoSKU;
    } else if (tipoFiltro === 'comeca') {
      corresponde = sku.startsWith(textoSKU);
    } else {
      corresponde = sku.includes(textoSKU);
    }

    const statusCorresponde = !filtroStatus || status === filtroStatus;

  linha.style.display = corresponde && statusCorresponde ? '' : 'none';
  });
}

async function verificarGestorFinanceiro() {
  try {
    const snap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .limit(1)
      .get();
    if (!snap.empty) {
      const btn = document.getElementById('btnAcompanhamentoGestor');
      if (btn) btn.classList.remove('hidden');
    }
  } catch (e) {
    console.error('Erro ao verificar gestor financeiro', e);
  }
}

async function carregarAcompanhamentoGestor() {
  const pedidosBody = document.querySelector('#tabelaPedidosCriticosGestor tbody');
  if (pedidosBody) pedidosBody.innerHTML = '';

  try {
    const usuariosSnap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .get();
    const usuarios = [];
    usuariosSnap.forEach(doc => usuarios.push({ uid: doc.id, ...doc.data() }));

    const selectUsuario = document.getElementById('filtroUsuarioGestor');
    if (selectUsuario && selectUsuario.options.length <= 1) {
      usuarios.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u.uid;
        opt.textContent = u.nome || u.email || u.uid;
        selectUsuario.appendChild(opt);
      });
    }

    const filtroUsuario = selectUsuario ? selectUsuario.value : '';
    const tipoData = document.getElementById('filtroDataTipo')?.value || 'mes';
    let inicio = null, fim = null;
    if (tipoData === 'dia') {
      const dia = document.getElementById('filtroDiaGestor')?.value;
      if (dia) { inicio = dia; fim = dia; }
    } else if (tipoData === 'periodo') {
      inicio = document.getElementById('filtroInicioGestor')?.value;
      fim = document.getElementById('filtroFimGestor')?.value;
    } else {
      const mes = document.getElementById('filtroMesGestor')?.value;
      if (mes) {
        inicio = mes + '-01';
        const [ano, m] = mes.split('-');
        const ultimoDia = new Date(ano, m, 0).getDate();
        fim = `${mes}-${String(ultimoDia).padStart(2,'0')}`;
      }
    }

    const pedidosErrados = [];

    for (const u of usuarios) {
      if (filtroUsuario && u.uid !== filtroUsuario) continue;

      const errSnap = await db.collection('uid').doc(u.uid).collection('pedidosErrados').get();
      errSnap.forEach(e => {
        const d = e.data();
        const dataPedido = d.dia || d.data || d.dataPedido;
        if (inicio && fim && dataPedido && (dataPedido < inicio || dataPedido > fim)) return;
        pedidosErrados.push({ usuario: u.nome || u.email || u.uid, ...d });
      });
    }

    if (pedidosBody) {
      if (!pedidosErrados.length) {
        pedidosBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500">Sem pedidos registrados</td></tr>';
      } else {
        pedidosErrados.forEach(p => {
          const dataPedido = p.dia || p.dataPedido || p.data || '';
          const pedido = p.pedido || p.numeroPedido || p.id || '';
          const sku = p.sku || '';
          const qtd = p.quantidade || p.qtd || 0;
          const esp = Number(p.sobraEsperada || p.metaEsperada || 0);
          const real = Number(p.sobraReal || p.totalLiquido || 0);
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${dataPedido}</td><td>${pedido}</td><td>${sku}</td><td>${qtd}</td><td>R$ ${esp.toFixed(2)}</td><td>R$ ${real.toFixed(2)}</td>`;
          pedidosBody.appendChild(tr);
        });
      }
    }
  } catch (e) {
    console.error('Erro ao carregar acompanhamento do gestor', e);
    if (pedidosBody) pedidosBody.innerHTML = '<tr><td colspan="6" class="text-red-500">Erro ao carregar dados</td></tr>';
  }
}

function atualizarTipoFiltroGestor() {
  const tipo = document.getElementById('filtroDataTipo')?.value;
  const mesEl = document.getElementById('filtroMesGestor');
  const diaEl = document.getElementById('filtroDiaGestor');
  const periodoEl = document.getElementById('filtroPeriodoGestor');
  mesEl?.classList.add('hidden');
  diaEl?.classList.add('hidden');
  periodoEl?.classList.add('hidden');
  if (tipo === 'dia') diaEl?.classList.remove('hidden');
  else if (tipo === 'periodo') periodoEl?.classList.remove('hidden');
  else mesEl?.classList.remove('hidden');
}

async function atualizarResponsavelFinanceiro(btn) {
  const botao = btn || document.getElementById('btnAtualizarRespFin');
  if (botao) toggleLoading(botao, 'Atualizar Responsável');
  try {
    const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
    const dadosUsuario = usuarioDoc.data() || {};
    const respEmail = (dadosUsuario.responsavelFinanceiroEmail || '').trim();
    if (!respEmail) {
      alert('Nenhum responsável financeiro configurado.');
      return;
    }
    const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
    let respDoc;
    if (respSnap.empty) {
      const altSnap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
      if (altSnap.empty) {
        alert('Responsável financeiro não encontrado.');
        return;
      }
      respDoc = altSnap.docs[0];
    } else {
      respDoc = respSnap.docs[0];
    }
    const respData = respDoc.data() || {};
    const responsavelUid = respData.uid || respDoc.id;
    const baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
    const pass = getPassphrase() || usuarioLogado.uid;
    const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value || document.getElementById('filtroMesRegistro')?.value;
    const { decryptString, encryptString } = await import('./crypto.js');
    const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').get();
    for (const doc of snap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      let resumo = doc.data();
      if (resumo.encrypted) {
        try {
          resumo = JSON.parse(await decryptString(resumo.encrypted, pass));
        } catch (e) {
          console.error('Erro ao descriptografar faturamento', e);
          continue;
        }
      }
      const resumoResp = await baseResp.collection('faturamento').doc(dia).get();
      if (!resumoResp.exists) {
        const encResumo = await encryptString(JSON.stringify(resumo), respEmail);
        await baseResp.collection('faturamento').doc(dia).set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
      }
      const lojasSnap = await db.collection(`uid/${usuarioLogado.uid}/faturamento/${dia}/lojas`).get();
      for (const lojaDoc of lojasSnap.docs) {
        const loja = lojaDoc.id;
        const destinoDoc = await baseResp.collection('faturamento').doc(dia).collection('lojas').doc(loja).get();
        if (destinoDoc.exists) continue;
        let dadosLoja = lojaDoc.data();
        if (dadosLoja.encrypted) {
          try {
            dadosLoja = JSON.parse(await decryptString(dadosLoja.encrypted, pass));
          } catch (e) {
            console.error('Erro ao descriptografar faturamento', e);
            continue;
          }
      }
      const encLoja = await encryptString(JSON.stringify(dadosLoja), respEmail);
      await baseResp
        .collection('faturamento')
        .doc(dia)
        .collection('lojas')
        .doc(loja)
        .set({ encrypted: encLoja, uid: usuarioLogado.uid });
      }
    }

    // Copiar SKUs vendidos para o responsável financeiro
    const skusSnap = await db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos').get();
    for (const doc of skusSnap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      const listaSnap = await db.collection(`uid/${usuarioLogado.uid}/skusVendidos/${dia}/lista`).get();
      if (listaSnap.empty) continue;
      await baseResp.collection('skusVendidos').doc(dia).set({ data: dia, uid: usuarioLogado.uid }, { merge: true });
      for (const skuDoc of listaSnap.docs) {
        const dadosSku = skuDoc.data();
        const payload = {
          sku: dadosSku.sku || skuDoc.id,
          total: dadosSku.total || 0,
          valorLiquido: dadosSku.valorLiquido || 0,
          data: dia,
          loja: dadosSku.loja || null,
          uid: usuarioLogado.uid
        };
        const dadoSalvar = respEmail
          ? { encrypted: await encryptString(JSON.stringify(payload), respEmail), uid: usuarioLogado.uid }
          : payload;
        await baseResp
          .collection('skusVendidos')
          .doc(dia)
          .collection('lista')
          .doc(skuDoc.id)
          .set(dadoSalvar);
      }
    }

    alert('Dados enviados ao responsável financeiro.');
  } catch (e) {
    console.error('Erro ao atualizar responsável financeiro', e);
    alert('Erro ao atualizar responsável financeiro.');
  } finally {
    if (botao) toggleLoading(botao, 'Atualizar Responsável');
  }
}

async function gerarPrevisaoProdutosVendidos() {
  if (!produtosVendidosResumo?.length) {
    mostrarErro('Carregue os dados de produtos vendidos antes de gerar a previsão.');
    return;
  }

  const dadosFiltrados = obterProdutosVendidosFiltrados();
  if (!dadosFiltrados.length) {
    mostrarErro('Nenhum SKU disponível para gerar previsão com os filtros atuais.');
    return;
  }

  const inicioValor = document.getElementById('filtroProdutosVendidosInicio')?.value;
  const fimValor = document.getElementById('filtroProdutosVendidosFim')?.value;
  if (!inicioValor || !fimValor) {
    mostrarErro('Informe o período de análise para gerar a previsão.');
    return;
  }

  const inicioData = new Date(`${inicioValor}T00:00:00`);
  const fimData = new Date(`${fimValor}T00:00:00`);
  if (
    Number.isNaN(inicioData.valueOf()) ||
    Number.isNaN(fimData.valueOf()) ||
    fimData.getTime() < inicioData.getTime()
  ) {
    mostrarErro('Período base inválido. Ajuste as datas e tente novamente.');
    return;
  }

  const diferencaMs = fimData.getTime() - inicioData.getTime();
  const diasBaseCalc = Math.floor(diferencaMs / (1000 * 60 * 60 * 24)) + 1;
  const diasBase = Math.max(1, diasBaseCalc);

  let diasFuturos = null;
  if (window.Swal?.fire) {
    const { value, isConfirmed } = await window.Swal.fire({
      title: 'Gerar previsão de vendas',
      input: 'number',
      inputLabel: 'Quantos dias deseja prever?',
      inputValue: 10,
      inputAttributes: {
        min: 1,
        step: 1,
      },
      showCancelButton: true,
      confirmButtonText: 'Gerar',
      cancelButtonText: 'Cancelar',
      inputValidator: (valor) => {
        const numero = Number(valor);
        if (!numero || Number.isNaN(numero) || numero < 1) {
          return 'Informe um número de dias válido (mínimo 1).';
        }
        if (numero > 365) {
          return 'Utilize um horizonte máximo de 365 dias.';
        }
        return undefined;
      },
    });
    if (!isConfirmed) {
      return;
    }
    diasFuturos = Math.round(Number(value));
  } else {
    const resposta = window.prompt('Quantos dias deseja prever? (Ex.: 10 ou 30)', '10');
    if (resposta === null) {
      return;
    }
    const numero = Number(resposta);
    if (!numero || Number.isNaN(numero) || numero < 1) {
      mostrarErro('Informe um número de dias válido para gerar a previsão.');
      return;
    }
    diasFuturos = Math.round(Math.min(numero, 365));
  }

  if (!diasFuturos || Number.isNaN(diasFuturos) || diasFuturos < 1) {
    mostrarErro('Não foi possível gerar a previsão com o horizonte informado.');
    return;
  }

  const ordenados = [...dadosFiltrados].sort((a, b) => b.total - a.total);
  const tabela = document.getElementById('produtosVendidosPrevisaoTabela');
  const resumo = document.getElementById('produtosVendidosPrevisaoResumo');
  const container = document.getElementById('produtosVendidosPrevisaoWrapper');
  if (!tabela || !resumo || !container) {
    mostrarErro('Não foi possível exibir a previsão neste layout.');
    return;
  }

  const moedaFormatter = new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL',
  });
  const formatarData = (valor) => {
    try {
      const data = new Date(`${valor}T00:00:00`);
      if (Number.isNaN(data.valueOf())) return valor;
      return new Intl.DateTimeFormat('pt-BR').format(data);
    } catch (erro) {
      return valor;
    }
  };

  let totalModerado = 0;
  let totalOtimista = 0;
  let totalValorModerado = 0;
  let totalValorOtimista = 0;

  const linhas = ordenados.map((item) => {
    const mediaDiaria = item.total > 0 ? item.total / diasBase : 0;
    const moderadaQuantidade = Math.max(0, Math.round(mediaDiaria * diasFuturos));
    const otimistaQuantidade = Math.max(
      moderadaQuantidade,
      Math.round(moderadaQuantidade * 1.1),
    );
    const valorUnitarioMedio =
      item.total > 0 ? Number(item.valorLiquido || 0) / item.total : 0;
    const valorModerado = moderadaQuantidade * valorUnitarioMedio;
    const valorOtimista = otimistaQuantidade * valorUnitarioMedio;

    totalModerado += moderadaQuantidade;
    totalOtimista += otimistaQuantidade;
    totalValorModerado += valorModerado;
    totalValorOtimista += valorOtimista;

    return `
      <tr>
        <td class="px-4 py-3 font-medium text-gray-700">${item.sku}</td>
        <td class="px-4 py-3 text-right text-gray-900">${moderadaQuantidade.toLocaleString('pt-BR')}</td>
        <td class="px-4 py-3 text-right text-gray-900">${otimistaQuantidade.toLocaleString('pt-BR')}</td>
        <td class="px-4 py-3 text-right text-gray-900">${moedaFormatter.format(valorModerado)}</td>
        <td class="px-4 py-3 text-right text-gray-900">${moedaFormatter.format(valorOtimista)}</td>
      </tr>
    `;
  });

  linhas.push(`
    <tr class="bg-blue-50 font-semibold text-blue-900">
      <td class="px-4 py-3">Total</td>
      <td class="px-4 py-3 text-right">${totalModerado.toLocaleString('pt-BR')}</td>
      <td class="px-4 py-3 text-right">${totalOtimista.toLocaleString('pt-BR')}</td>
      <td class="px-4 py-3 text-right">${moedaFormatter.format(totalValorModerado)}</td>
      <td class="px-4 py-3 text-right">${moedaFormatter.format(totalValorOtimista)}</td>
    </tr>
  `);

  tabela.innerHTML = linhas.join('');

  resumo.innerHTML = `
    <div><strong>Período base:</strong> ${formatarData(inicioValor)} a ${formatarData(fimValor)} (${diasBase} dia${
      diasBase > 1 ? 's' : ''
    })</div>
    <div><strong>Horizonte da previsão:</strong> ${diasFuturos} dia${
      diasFuturos > 1 ? 's' : ''
    }</div>
    <div><strong>Cenários:</strong> moderado com base na média diária e otimista com crescimento de até 10%.</div>
  `;

  container.classList.remove('hidden');
  mostrarSucesso('Previsão gerada com sucesso!');
}

window.carregarRegistrosFaturamento = carregarRegistrosFaturamento;
window.copiarResumoFaturamento = copiarResumoFaturamento;
window.carregarControleVendas = carregarControleVendas;
window.carregarProdutosVendidos = carregarProdutosVendidos;
window.carregarSobras = carregarSobras;
window.carregarPrevisao = carregarPrevisao;
window.gerarPrevisao = gerarPrevisao;
window.renderizarPrevisao = renderizarPrevisao;
window.baixarPrevisaoPdf = baixarPrevisaoPdf;
window.carregarAcompanhamento = carregarAcompanhamento;
window.carregarAcompanhamentoGestor = carregarAcompanhamentoGestor;
window.verificarGestorFinanceiro = verificarGestorFinanceiro;
window.exportarProdutosVendidosExcel = exportarProdutosVendidosExcel;
window.exportarProdutosVendidosPDFDetalhado = exportarProdutosVendidosPDFDetalhado;
window.exportarProdutosVendidosPDFSimplificado = exportarProdutosVendidosPDFSimplificado;
window.exportarRelatorioPorPecaExcel = exportarRelatorioPorPecaExcel;
window.gerarPrevisaoProdutosVendidos = gerarPrevisaoProdutosVendidos;
window.exportarAcompanhamentoExcel = exportarAcompanhamentoExcel;
window.exportarResumoTopSkus = exportarResumoTopSkus;
window.exportarAcompanhamentoPDF = exportarAcompanhamentoPDF;
window.baixarFechamentoMensal = baixarFechamentoMensal;
window.printAcompanhamento = printAcompanhamento;
  window.salvarMetasAcompanhamento = salvarMetasAcompanhamento;
window.atualizarResponsavelFinanceiro = atualizarResponsavelFinanceiro;
window.exportarVendasMes = exportarVendasMes;
window.mostrarDetalhesVendas = mostrarDetalhesVendas;
window.mostrarDetalhesSobra = mostrarDetalhesSobra;
window.mostrarDetalhesFaturamento = mostrarDetalhesFaturamento;
window.alternarSelecaoFaturamento = alternarSelecaoFaturamento;
window.excluirFaturamentosSelecionados = excluirFaturamentosSelecionados;
window.excluirFaturamento = excluirFaturamento;
window.analisarSobrasIA = analisarSobrasIA;
window.exportarCSV = exportarCSV;
window.exportarExcel = exportarExcel;
window.exportarSobrasPDF = exportarSobrasPDF;
window.exportarJSON = exportarJSON;
window.salvarComissaoSobras = salvarComissaoSobras;
window.verificarConexao = verificarConexao;
window.editarMeta = editarMeta;
window.excluirMeta = excluirMeta;
window.atualizarTipoFiltroGestor = atualizarTipoFiltroGestor;
  window.analisarTendenciasIA = analisarTendenciasIA;
  window.atualizarStatusLogistica = atualizarStatusLogistica;
window.atualizarRastreio = atualizarRastreio;
window.atualizarChecklist = atualizarChecklist;
window.aplicarFiltroLogistica = aplicarFiltroLogistica;
  window.processarPlanilha = processarPlanilha;
window.processarConferenciaComissao = processarConferenciaComissao;
window.exportarConferenciaComissaoExcel = exportarConferenciaComissaoExcel;
window.exportarConferenciaComissaoPDF = exportarConferenciaComissaoPDF;
window.toggleExportMenu = toggleExportMenu;
window.salvarAcompanhamentoDiario = salvarAcompanhamentoDiario;
window.carregarResumoDiario = carregarResumoDiario;
window.exportarResumoDiarioSemana = exportarResumoDiarioSemana;
window.alternarSubPaginaDiaria = alternarSubPaginaDiaria;
window.carregarDiarioGestor = carregarDiarioGestor;
window.inicializarAbaDiaria = inicializarAbaDiaria;
window.inicializarDiarioGestor = inicializarDiarioGestor;

</script>
<script src="shared.js"></script>
<!-- Outras bibliotecas (como XLSX) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

</body>
</html>

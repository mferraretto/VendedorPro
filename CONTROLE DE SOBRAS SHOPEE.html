<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sistema de Sobras - Shopee Premium</title>
  
  <!-- Fontes Google -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&display=swap" rel="stylesheet">
  
  <!-- Bibliotecas CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link rel="stylesheet" href="css/styles.css?v=20240826">
<link rel="stylesheet" href="css/tabs-mobile.css?v=20240826">
  <!-- Bibliotecas JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
      <script type="module" src="firebase-config.js"></script>


</head>
<body class="bg-gray-50">
  <div class="app-container">
    <!-- Sidebar -->
  <div id="sidebar-container"></div>



<!-- Top Navbar -->
  <div id="navbar-container"></div>


    <!-- Conteúdo Principal -->
    <div class="main-content space-y-10">
      <div class="page-title">
        <i class="fas fa-check-circle"></i>
        <h1>Vendedor Pro - Vendas e Faturamento</h1>
      </div>
      
      
      <div id="firebase-error" class="card" style="display: none;">
        <div class="card-header">
          <i class="fas fa-exclamation-triangle"></i>
          <h3>Erro de Conexão com o Firebase</h3>
        </div>
        <p id="error-message" style="margin-bottom: 1rem;"></p>
        <button onclick="verificarConexao()" class="btn btn-primary">
          <i class="fas fa-sync-alt"></i> Tentar Reconectar
        </button>
      </div>
      
      <!-- Tab bar removida -->

      <!-- Aba de Importação/Conferência -->
      <div id="importar" class="tab-content active">
 
      </div>

      <!-- Aba de Metas -->
      <div id="metas" class="tab-content">
          </div>

      

      <!-- Aba de Gráficos -->
      <div id="graficos" class="tab-content">
     
      </div>

      <!-- Aba de Histórico -->
      <div id="historico" class="tab-content">
    
      </div>
      
      <!-- Aba de Faturamento -->
      <div id="faturamento" class="tab-content">

      </div>

      <!-- Aba de Vendas Mercado Livre -->
      <div id="vendasML" class="tab-content">

      </div>

      <!-- Aba de Registro de Faturamento -->
      <div id="registroFaturamento" class="tab-content">

      </div>

      <!-- Aba de Controle de Vendas -->
      <div id="controleVendas" class="tab-content">

      </div>

      <!-- Aba de Produtos Vendidos (Gestores/Responsáveis Financeiros) -->
      <div
        id="produtosVendidos"
        class="tab-content"
        data-perfil="gestor,responsavel,gestor financeiro,responsavel financeiro"
      >

      </div>

      <!-- Aba de Sobras -->
      <div id="sobras" class="tab-content">

      </div>

      <!-- Aba de Previsão -->
      <div id="previsao" class="tab-content">

      </div>

      <!-- Aba de Acompanhamento -->
      <div id="acompanhamento" class="tab-content">

      </div>
      <!-- Aba de Acompanhamento Sobras (Gestor) -->
      <div id="acompanhamentoGestor" class="tab-content">

      </div>
    </div>
  </div>

  <!-- Status de conexão -->
  <div id="connectionStatus" class="connection-status offline">
    <div class="status-dot"></div>
    <span>Offline - Trabalhando localmente</span>
  </div>

<script type="module">
    import { firebaseConfig } from './firebase-config.js';
  // =============================================
    // CONFIGURAÇÃO INICIAL E VARIÁVEIS GLOBAIS
    // =============================================
    // Variáveis globais
    let db;
    let metas = {};
    let historico = [];
    let produtos = {};
        let dadosAcompanhamento = [];
    let sobraPorSku = {};
      let resumoSku = {};
      let produtosVendidosResumo = [];
      let produtosVendidosCarregado = false;
      let totalSaquesAcompanhamento = 0;
      let totalComissaoAcompanhamento = 0;
      let totalComissaoPagaAcompanhamento = 0;
      let totalComissaoAPagarAcompanhamento = 0;
      let usuarioLogado = { uid: null, perfil: '' };
      window.usuarioLogado = usuarioLogado;
let pedidosProcessados = [];
let graficoBarras, graficoPizza, graficoPrevisao;
let previsaoDados = {};
let initialTab = null;
const API_URL = 'https://us-central1-matheus-35023.cloudfunctions.net/proxyDeepSeek';

function normalizeDate(value) {
  if (!value) return '';
  if (value instanceof Date && !isNaN(value)) return value.toISOString().split('T')[0];

  const str = String(value).trim();
  if (!str) return '';

  const directDate = new Date(str);
  if (!isNaN(directDate)) return directDate.toISOString().split('T')[0];

  const brMatch = str.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
  if (brMatch) {
    const dia = brMatch[1].padStart(2, '0');
    const mes = brMatch[2].padStart(2, '0');
    const ano = brMatch[3];
    return `${ano}-${mes}-${dia}`;
  }

  const isoMatch = str.match(/\d{4}-\d{2}-\d{2}/);
  if (isoMatch) return isoMatch[0];

  const sanitized = str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/\bhs\b\.?/gi, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();

  const months = {
    janeiro: '01',
    fevereiro: '02',
    marco: '03',
    abril: '04',
    maio: '05',
    junho: '06',
    julho: '07',
    agosto: '08',
    setembro: '09',
    outubro: '10',
    novembro: '11',
    dezembro: '12'
  };

  const ptMatch = sanitized.match(/(\d{1,2})\s+de\s+([a-z]+)\s+de\s+(\d{4})(?:\s+(\d{1,2}:\d{2}))?/);
  if (ptMatch) {
    const dia = ptMatch[1].padStart(2, '0');
    const mes = months[ptMatch[2]];
    const ano = ptMatch[3];
    if (mes) {
      return `${ano}-${mes}-${dia}`;
    }
  }

  return '';
}

function normalizeHeaderKey(key) {
  return String(key || '')
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]/g, '')
    .toLowerCase();
}

function buildHeaderMap(row) {
  return Object.keys(row || {}).reduce((acc, original) => {
    acc[normalizeHeaderKey(original)] = original;
    return acc;
  }, {});
}

function getFieldByKey(row, headerMap, normalizedKey) {
  if (!row || !headerMap) return undefined;
  const actual = headerMap[normalizedKey];
  return actual !== undefined ? row[actual] : undefined;
}

function parseNumber(value) {
  if (typeof value === 'number') {
    if (Number.isFinite(value)) return value;
    return 0;
  }
  if (value === null || value === undefined) return 0;
  const normalized = String(value)
    .replace(/[^0-9,.-]/g, '')
    .replace(/\.(?=\d{3}(?:\D|$))/g, '')
    .replace(',', '.');
  const parsed = parseFloat(normalized);
  return Number.isFinite(parsed) ? parsed : 0;
}

const makeSkuDocId = (sku) => encodeURIComponent(String(sku ?? '').trim());
const makeLegacySkuDocId = (sku) =>
  String(sku ?? '')
    .trim()
    .replace(/[.#$\/\[\]]/g, '_');

function escapeHtml(value) {
  return String(value ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

async function obterBasesUsuario() {
  const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
  const dadosUsuario = usuarioDoc.data() || {};
  const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
  let baseResp = null;
  if (respEmail) {
    try {
      const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
      if (!respSnap.empty) {
        const respDoc = respSnap.docs[0];
        const respData = respDoc.data() || {};
        const responsavelUid = respData.uid || respDoc.id;
        baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
      }
    } catch (err) {
      console.error('Erro ao buscar responsável financeiro', err);
    }
  }

  const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
    ? dadosUsuario.gestoresExpedicaoEmails[0]
    : dadosUsuario.responsavelExpedicaoEmail || null;
  let baseExp = null;
  if (gestorEmail) {
    try {
      const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
      if (!expSnap.empty) {
        const expDoc = expSnap.docs[0];
        const expData = expDoc.data() || {};
        const gestorUid = expData.uid || expDoc.id;
        baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
      }
    } catch (err) {
      console.error('Erro ao buscar base do gestor de expedição', err);
    }
  }

  return { dadosUsuario, respEmail, baseResp, gestorEmail, baseExp };
}

async function processarPlanilhaVendas({
  rows,
  dataReferencia,
  loja,
  plataforma,
  resultadoId,
  progressIds = {},
  rowParser
}) {
  const { containerId, barId, textId } = progressIds || {};
  const progressContainer = containerId ? document.getElementById(containerId) : null;
  const progressBar = barId ? document.getElementById(barId) : null;
  const progressText = textId ? document.getElementById(textId) : null;

  if (progressContainer) progressContainer.classList.remove('hidden');
  if (progressBar) progressBar.style.width = '0%';
  if (progressText) progressText.textContent = '0%';

  const { baseResp, respEmail, gestorEmail, baseExp } = await obterBasesUsuario();
  const { encryptString, decryptString } = await import('./crypto.js');
  const pass = getPassphrase() || usuarioLogado.uid;

  const ref = db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('faturamento')
    .doc(dataReferencia)
    .collection('lojas')
    .doc(loja);

  const doc = await ref.get();
  let operacao = 'substituir';
  let dadosAnteriores = null;

  if (doc.exists) {
    const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
      title: 'Registro existente',
      text: `Já existe um registro para ${loja} em ${dataReferencia}. O que deseja fazer?`,
      showDenyButton: true,
      showCancelButton: true,
      confirmButtonText: 'Substituir',
      denyButtonText: 'Somar',
      cancelButtonText: 'Pular'
    });
    if (!substituir && !somar) {
      if (progressContainer) progressContainer.classList.add('hidden');
      return null;
    }
    operacao = somar ? 'somar' : 'substituir';
    const docData = doc.data();
    if (docData?.encrypted) {
      try {
        dadosAnteriores = JSON.parse(await decryptString(docData.encrypted, pass));
      } catch (err) {
        console.error('Erro ao descriptografar faturamento existente', err);
      }
    } else {
      dadosAnteriores = docData;
    }
  }

  let bruto = 0;
  let liquidoTotal = 0;
  let qtdVendas = 0;
  const skusVendidos = {};
  const faturamentoPorDia = {};
  const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
  const totalRows = rows.length;
  let processedRows = 0;

  const updateProgress = async () => {
    if (!progressBar || !progressText) return;
    const pct = totalRows ? Math.round((processedRows / totalRows) * 100) : 0;
    progressBar.style.width = pct + '%';
    progressText.textContent = pct + '%';
    if (processedRows % 50 === 0) await new Promise(resolve => setTimeout(resolve, 0));
  };

  for (const row of rows) {
    const parsed = typeof rowParser === 'function' ? rowParser(row, { dataReferencia }) : null;
    if (!parsed || !parsed.numeroVenda) {
      processedRows++;
      await updateProgress();
      continue;
    }

    const {
      numeroVenda,
      estado = '',
      sku = '',
      unidades,
      receitaProdutos = 0,
      receitaAcrescimo = 0,
      receitaEnvio = 0,
      taxaParcelamento = 0,
      tarifaVenda = 0,
      tarifasEnvio = 0,
      cancelamentos = 0,
      totalLinha,
      dataVenda: dataVendaOriginal,
      ativo: ativoOverride,
      extrasPedido = {}
    } = parsed;

    const unidadesNumero = Number.isFinite(unidades) ? unidades : parseNumber(unidades);
    const brutoLinha = Number(receitaProdutos || 0) + Number(receitaAcrescimo || 0) + Number(receitaEnvio || 0);
    const liquidoCalculado = brutoLinha - (Number(taxaParcelamento || 0) + Number(tarifaVenda || 0) + Number(tarifasEnvio || 0) + Math.abs(Number(cancelamentos || 0)));
    const liquidoLinha = Number.isFinite(totalLinha) ? Number(totalLinha) : liquidoCalculado;
    const taxasLinha = Math.max(0, brutoLinha - liquidoLinha);
    const dataVenda = normalizeDate(dataVendaOriginal) || dataReferencia;

    const statusLower = String(estado || '').toLowerCase();
    const ativo = typeof ativoOverride === 'boolean'
      ? ativoOverride
      : !(statusLower.includes('cancel') || statusLower.includes('devol') || statusLower.includes('reemb'));

    if (ativo) {
      bruto += brutoLinha;
      liquidoTotal += liquidoLinha;
      qtdVendas += 1;
      if (sku) {
        if (!skusVendidos[sku]) skusVendidos[sku] = { total: 0, valorLiquido: 0 };
        skusVendidos[sku].total += 1;
        skusVendidos[sku].valorLiquido += liquidoLinha;
      }
      const diaResumo = dataVenda || dataReferencia;
      if (diaResumo) {
        if (!faturamentoPorDia[diaResumo]) {
          faturamentoPorDia[diaResumo] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[diaResumo].bruto += brutoLinha;
        faturamentoPorDia[diaResumo].liquido += liquidoLinha;
        faturamentoPorDia[diaResumo].vendas += 1;
      }
    }

    const extrasLimpos = {};
    if (extrasPedido && typeof extrasPedido === 'object') {
      for (const [key, value] of Object.entries(extrasPedido)) {
        if (value !== undefined) extrasLimpos[key] = value;
      }
    }

    const pedidoPayload = {
      pedidoId: numeroVenda,
      numeroVenda,
      status: estado,
      sku,
      loja,
      data: dataReferencia,
      dataVenda,
      horaPagamento: dataVenda,
      unidades: Number.isFinite(unidadesNumero) ? unidadesNumero : 0,
      subtotal: brutoLinha,
      taxas: taxasLinha,
      liquido: liquidoLinha,
      receitaProdutos,
      receitaAcrescimoPreco: receitaAcrescimo,
      receitaEnvio,
      taxaParcelamentoAcrescimo: taxaParcelamento,
      tarifasEnvio,
      tarifaVendaImpostos: tarifaVenda,
      cancelamentosReembolsos: cancelamentos,
      total: Number.isFinite(totalLinha) ? Number(totalLinha) : liquidoLinha,
      plataforma,
      ...extrasLimpos
    };

    const pedidoDocRef = pedidosRef
      .doc(dataReferencia)
      .collection('lista')
      .doc(numeroVenda);
    const pedidoDoc = await pedidoDocRef.get();
    let needsUpdate = true;
    if (pedidoDoc.exists) {
      try {
        const atual = JSON.parse(await decryptString(pedidoDoc.data().encrypted, pass));
        if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
          needsUpdate = false;
        }
      } catch (err) {
        console.error('Erro ao comparar pedido existente', err);
      }
    }
    if (needsUpdate) {
      const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
      await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
      if (baseResp && respEmail) {
        const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
        await baseResp
          .collection('pedidosreais')
          .doc(dataReferencia)
          .collection('lista')
          .doc(numeroVenda)
          .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
      }
      if (baseExp && gestorEmail) {
        const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
        await baseExp
          .collection('pedidosreais')
          .doc(dataReferencia)
          .collection('lista')
          .doc(numeroVenda)
          .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
      }
    }

    processedRows++;
    await updateProgress();
  }

  if (operacao === 'somar' && dadosAnteriores) {
    bruto += Number(dadosAnteriores.valorBruto || 0);
    liquidoTotal += Number(dadosAnteriores.valorLiquido || 0);
    qtdVendas += Number(dadosAnteriores.qtdVendas || 0);
    if (Array.isArray(dadosAnteriores.resumoPorDia)) {
      for (const diaAnterior of dadosAnteriores.resumoPorDia) {
        const chaveDia =
          diaAnterior?.data ||
          diaAnterior?.dia ||
          diaAnterior?.dataVenda ||
          dadosAnteriores.data ||
          dataReferencia;
        if (!chaveDia) continue;
        if (!faturamentoPorDia[chaveDia]) {
          faturamentoPorDia[chaveDia] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[chaveDia].bruto += Number(diaAnterior.valorBruto || diaAnterior.bruto || 0);
        faturamentoPorDia[chaveDia].liquido += Number(diaAnterior.valorLiquido || diaAnterior.liquido || 0);
        faturamentoPorDia[chaveDia].vendas += Number(
          diaAnterior.vendas ||
          diaAnterior.qtdVendas ||
          diaAnterior.quantidade ||
          0
        );
      }
    } else {
      const chaveDiaAnterior = dadosAnteriores.data || dataReferencia;
      if (chaveDiaAnterior) {
        if (!faturamentoPorDia[chaveDiaAnterior]) {
          faturamentoPorDia[chaveDiaAnterior] = { bruto: 0, liquido: 0, vendas: 0 };
        }
        faturamentoPorDia[chaveDiaAnterior].bruto += Number(dadosAnteriores.valorBruto || 0);
        faturamentoPorDia[chaveDiaAnterior].liquido += Number(dadosAnteriores.valorLiquido || 0);
        faturamentoPorDia[chaveDiaAnterior].vendas += Number(
          dadosAnteriores.qtdVendas ||
          dadosAnteriores.vendas ||
          0
        );
      }
    }
  }

  const taxas = Math.max(0, bruto - liquidoTotal);

  const resumoPorDia = Object.entries(faturamentoPorDia)
    .map(([dia, valores]) => {
      const brutoDia = Number(valores?.bruto || 0);
      const liquidoDia = Number(valores?.liquido || 0);
      return {
        data: dia,
        valorBruto: brutoDia,
        valorLiquido: liquidoDia,
        taxas: Math.max(0, brutoDia - liquidoDia),
        vendas: Number(valores?.vendas || 0)
      };
    })
    .sort((a, b) => new Date(a.data) - new Date(b.data));

  const periodoResumo =
    resumoPorDia.length > 0
      ? { inicio: resumoPorDia[0].data, fim: resumoPorDia[resumoPorDia.length - 1].data }
      : { inicio: dataReferencia, fim: dataReferencia };

  const resumoPedidos = {
    data: dataReferencia,
    loja,
    plataforma,
    atualizadoEm:
      typeof firebase !== 'undefined' && firebase.firestore?.FieldValue?.serverTimestamp
        ? firebase.firestore.FieldValue.serverTimestamp()
        : new Date().toISOString(),
    totalLinhas: totalRows,
    totalPedidosAtivos: qtdVendas,
    valorBruto: bruto,
    valorLiquido: liquidoTotal,
    taxas
  };

  await pedidosRef.doc(dataReferencia).set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp && respEmail) {
    await baseResp
      .collection('pedidosreais')
      .doc(dataReferencia)
      .set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  }
  if (baseExp && gestorEmail) {
    await baseExp
      .collection('pedidosreais')
      .doc(dataReferencia)
      .set({ ...resumoPedidos, uid: usuarioLogado.uid }, { merge: true });
  }

  const refSku = db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('skusVendidos')
    .doc(dataReferencia);
  await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp) {
    await baseResp
      .collection('skusVendidos')
      .doc(dataReferencia)
      .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
  }

  for (const [skuItem, dadosSku] of Object.entries(skusVendidos)) {
    const skuId = makeSkuDocId(skuItem);
    const legacySkuId = makeLegacySkuDocId(skuItem);
    const listaCollection = db
      .collection('uid')
      .doc(usuarioLogado.uid)
      .collection('skusVendidos')
      .doc(dataReferencia)
      .collection('lista');
    const docRef = listaCollection.doc(skuId);
    const docSnap = await docRef.get();

    let totalFinal = dadosSku.total;
    let valorLiquidoFinal = dadosSku.valorLiquido;
    if (docSnap.exists) {
      const dadosAnterioresSku = docSnap.data();
      totalFinal += dadosAnterioresSku.total || 0;
      valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
    } else if (legacySkuId !== skuId) {
      const legacyDocRef = listaCollection.doc(legacySkuId);
      const legacySnap = await legacyDocRef.get();
      if (legacySnap.exists) {
        const dadosAnterioresSku = legacySnap.data();
        totalFinal += dadosAnterioresSku.total || 0;
        valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
        try {
          await legacyDocRef.delete();
        } catch (err) {
          console.warn('Não foi possível remover SKU legado', legacySkuId, err);
        }
      }
    }

    await docRef.set({
      sku: skuItem,
      total: totalFinal,
      valorLiquido: valorLiquidoFinal,
      data: dataReferencia,
      loja,
      uid: usuarioLogado.uid
    });

    if (baseResp && respEmail) {
      const skuPayload = {
        sku: skuItem,
        total: totalFinal,
        valorLiquido: valorLiquidoFinal,
        data: dataReferencia,
        loja,
        uid: usuarioLogado.uid
      };
      const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
      const baseRespLista = baseResp
        .collection('skusVendidos')
        .doc(dataReferencia)
        .collection('lista');
      await baseRespLista.doc(skuId).set({ encrypted: encSku, uid: usuarioLogado.uid });
    }

    if (baseExp && gestorEmail) {
      const skuPayload = {
        sku: skuItem,
        total: totalFinal,
        valorLiquido: valorLiquidoFinal,
        data: dataReferencia,
        loja,
        uid: usuarioLogado.uid
      };
      const encSku = await encryptString(JSON.stringify(skuPayload), gestorEmail);
      const baseExpLista = baseExp
        .collection('skusVendidos')
        .doc(dataReferencia)
        .collection('lista');
      await baseExpLista.doc(skuId).set({ encrypted: encSku, uid: usuarioLogado.uid });
    }
  }

  if (progressBar && progressText) {
    progressBar.style.width = '100%';
    progressText.textContent = '100%';
  }

  const lojaPayload = {
    valorBruto: bruto,
    taxasPlataforma: taxas,
    valorLiquido: liquidoTotal,
    qtdVendas,
    loja,
    atualizadoEm: new Date(),
    uid: usuarioLogado.uid
  };
  const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
  await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
  if (baseResp && respEmail) {
    const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
    await baseResp
      .collection('faturamento')
      .doc(dataReferencia)
      .collection('lojas')
      .doc(loja)
      .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
  }

  const resumoPayload = {
    valorBruto: bruto,
    valorLiquido: liquidoTotal,
    taxasPlataforma: taxas,
    vendas: qtdVendas,
    plataforma,
    atualizadoEm: new Date(),
    uid: usuarioLogado.uid,
    resumoPorDia,
    periodoVendas: periodoResumo
  };
  const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
  await db
    .collection('uid')
    .doc(usuarioLogado.uid)
    .collection('faturamento')
    .doc(dataReferencia)
    .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
  if (baseResp && respEmail) {
    const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
    await baseResp
      .collection('faturamento')
      .doc(dataReferencia)
      .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
  }

  await notificarResponsavelFinanceiro(dataReferencia, loja, bruto, liquidoTotal, qtdVendas);

  if (resultadoId) {
    const resultado = document.getElementById(resultadoId);
    if (resultado) {
      const formatCurrency = (valor) =>
        Number(valor || 0).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
      const formatDateBr = (iso) => {
        if (!iso || typeof iso !== 'string') return iso || '';
        const partes = iso.split('-');
        if (partes.length !== 3) return iso;
        return `${partes[2]}/${partes[1]}/${partes[0]}`;
      };
      const periodoTexto =
        periodoResumo.inicio === periodoResumo.fim
          ? formatDateBr(periodoResumo.inicio)
          : `${formatDateBr(periodoResumo.inicio)} até ${formatDateBr(periodoResumo.fim)}`;
      const resumoDiasHtml = resumoPorDia.length
        ? `
          <div class="mt-4">
            <h4 class="font-semibold text-sm text-gray-700 mb-2">Faturamento por dia</h4>
            <div class="overflow-x-auto">
              <table class="min-w-full text-xs text-left text-gray-600">
                <thead class="bg-gray-100 text-gray-700">
                  <tr>
                    <th class="px-3 py-2 font-medium">Data</th>
                    <th class="px-3 py-2 font-medium">Bruto</th>
                    <th class="px-3 py-2 font-medium">Líquido</th>
                    <th class="px-3 py-2 font-medium">Taxas</th>
                    <th class="px-3 py-2 font-medium">Vendas</th>
                  </tr>
                </thead>
                <tbody>
                  ${resumoPorDia
                    .map(
                      (dia) => `
                        <tr class="border-b last:border-none">
                          <td class="px-3 py-2">${formatDateBr(dia.data)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.valorBruto)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.valorLiquido)}</td>
                          <td class="px-3 py-2">${formatCurrency(dia.taxas)}</td>
                          <td class="px-3 py-2">${dia.vendas}</td>
                        </tr>
                      `
                    )
                    .join('')}
                </tbody>
              </table>
            </div>
          </div>
        `
        : `<p class="mt-4 text-sm text-gray-500">Nenhum faturamento ativo encontrado na planilha.</p>`;

      resultado.innerHTML = `
        <div class="alert alert-success">
          <i class="fas fa-check-circle"></i> Faturamento ${escapeHtml(plataforma)} processado com sucesso!<br>
          <strong>Loja:</strong> ${escapeHtml(loja)}<br>
          <strong>Período identificado:</strong> ${periodoTexto}<br>
          <strong>Bruto total:</strong> ${formatCurrency(bruto)}<br>
          <strong>Líquido total:</strong> ${formatCurrency(liquidoTotal)}<br>
          <strong>Vendas:</strong> ${qtdVendas}
        </div>
        ${resumoDiasHtml}
      `;
    }
  }

  mostrarSucesso(`Faturamento ${plataforma} importado com sucesso!`);
  return { bruto, liquidoTotal, qtdVendas };
}

function extrairLinhaMercadoLivre(row, { dataReferencia } = {}) {
  const headerMap = buildHeaderMap(row);
  const numeroVenda = String(getFieldByKey(row, headerMap, 'ndevenda') || '').trim();
  if (!numeroVenda) return null;
  return {
    numeroVenda,
    estado: String(getFieldByKey(row, headerMap, 'estado') || '').trim(),
    sku: String(getFieldByKey(row, headerMap, 'sku') || '').trim(),
    unidades: parseNumber(getFieldByKey(row, headerMap, 'unidades')),
    receitaProdutos: parseNumber(getFieldByKey(row, headerMap, 'receitaporprodutosbrl')),
    receitaAcrescimo: parseNumber(getFieldByKey(row, headerMap, 'receitaporacrescimonoprecopagopelocomprador')),
    receitaEnvio: parseNumber(getFieldByKey(row, headerMap, 'receitaporenviobrl')),
    taxaParcelamento: parseNumber(getFieldByKey(row, headerMap, 'taxadeparcelamentoequivalenteaoacrescimo')),
    tarifaVenda: parseNumber(getFieldByKey(row, headerMap, 'tarifadevendaeimpostosbrl')),
    tarifasEnvio: parseNumber(getFieldByKey(row, headerMap, 'tarifasdeenviobrl')),
    cancelamentos: parseNumber(getFieldByKey(row, headerMap, 'cancelamentoseerembolsosbrl')),
    totalLinha: parseNumber(getFieldByKey(row, headerMap, 'totalbrl')),
    dataVenda: getFieldByKey(row, headerMap, 'datadavenda') || dataReferencia
  };
}

function extrairLinhaTiny(row, { dataReferencia } = {}) {
  const headerMap = buildHeaderMap(row);
  const numeroVenda = String(getFieldByKey(row, headerMap, 'numerodaordemdecompra') || '').trim();
  if (!numeroVenda) return null;
  const quantidade = parseNumber(getFieldByKey(row, headerMap, 'quantidade'));
  const valorUnitario = parseNumber(getFieldByKey(row, headerMap, 'valorunitario'));
  const totalCalculado = Number(valorUnitario || 0) * (Number(quantidade || 0) || 0);
  const dataPrevistaBruta = getFieldByKey(row, headerMap, 'dataprevista');
  const dataPrevistaNormalizada = normalizeDate(dataPrevistaBruta);
  const extras = {};
  if (dataPrevistaNormalizada) {
    extras.dataPrevista = dataPrevistaNormalizada;
  } else if (dataPrevistaBruta) {
    extras.dataPrevistaTexto = String(dataPrevistaBruta);
  }
  if (Number.isFinite(valorUnitario)) {
    extras.valorUnitario = valorUnitario;
  }
  return {
    numeroVenda,
    estado: String(getFieldByKey(row, headerMap, 'situacao') || '').trim(),
    sku: String(getFieldByKey(row, headerMap, 'codigosku') || '').trim(),
    unidades: quantidade,
    receitaProdutos: totalCalculado,
    receitaAcrescimo: 0,
    receitaEnvio: 0,
    taxaParcelamento: 0,
    tarifaVenda: 0,
    tarifasEnvio: 0,
    cancelamentos: 0,
    totalLinha: totalCalculado,
    dataVenda: getFieldByKey(row, headerMap, 'data') || dataReferencia,
    extrasPedido: extras
  };
}

   const tabIds = ['importar','metas','graficos','historico','faturamento','vendasML','registroFaturamento','controleVendas','produtosVendidos','sobras','previsao','acompanhamento','acompanhamentoGestor'];
      const tabsLoaded = Promise.all(
        tabIds.map(t =>
          fetch(`sobras-tabs/${t}.html`)
            .then(res => res.text())
            .then(html => {
              const el = document.getElementById(t);
              if (el) el.innerHTML = html;
            })
            .catch(err => {
              console.error('Erro ao carregar aba', t, err);
              updateConnectionStatus(false);
              return '';
            })
        )
      );

      window.addEventListener('online', () => updateConnectionStatus(true));
      window.addEventListener('offline', () => updateConnectionStatus(false));
      updateConnectionStatus(navigator.onLine);

    // =============================================
    // INICIALIZAÇÃO DO FIREBASE E CONFIGURAÇÕES
    // =============================================
    
    // Inicialização mais robusta do Firebase
    document.addEventListener('DOMContentLoaded', async () => {
      initialTab = new URLSearchParams(window.location.search).get('tab') ||
        (window.location.hash ? window.location.hash.substring(1) : null);
      try {
        const app = !firebase.apps.length ? firebase.initializeApp(window.firebaseConfig) : firebase.app();
        db = firebase.firestore(app);
        const auth = firebase.auth();

        auth.onAuthStateChanged(async user => {
          if (!user) {
            window.location.href = 'index.html?login=1';
            return;
          }
          usuarioLogado.uid = user.uid;
          usuarioLogado.email = user.email;
          try {
            const perfilDoc = await db.collection('usuarios').doc(user.uid).get();
            usuarioLogado.perfil = perfilDoc.exists ? (perfilDoc.data().perfil || '') : '';
          } catch (e) {
            console.error('Erro ao obter perfil do usuário:', e);
          }
          await tabsLoaded;
          window.initTooltips && window.initTooltips();

          await carregarProdutos();
          await carregarMetas();
          carregarHistorico();
          await verificarGestorFinanceiro();
          document.getElementById('filtroSKU').addEventListener('input', filtrarPorSKU);
          document.getElementById('filtroHistorico').addEventListener('input', filtrarHistorico);
          document.getElementById('metaSku').addEventListener('input', atualizarPrecoMinimo);
          document.getElementById('filtroStatus').addEventListener('change', filtrarPorSKU);
          document.getElementById('tipoFiltro').addEventListener('change', filtrarPorSKU);
          document.getElementById('btnLimparFiltros')?.addEventListener('click', limparFiltros);
          if (initialTab && document.getElementById(initialTab)) {
            trocarAba(initialTab);
            if (initialTab === 'sobras') {
              carregarSobras();
            }
          }
        });

        // Configurações importantes para a conexão
        db.settings({
          experimentalForceLongPolling: true
        });

        // Habilita persistência offline
        firebase.firestore().enablePersistence()
          .catch((err) => {
            if (err.code == 'failed-precondition') {
              console.warn("Persistência offline não suportada em múltiplas abas");
            } else if (err.code == 'unimplemented') {
              console.warn("Persistência offline não disponível no navegador");
            }
          });

        // Verifica conexão
        verificarConexao();

      } catch (error) {
        console.error("Erro ao inicializar Firebase:", error);
        mostrarErroFirebase(error);
      }
    });

 // Eventos dependentes do carregamento da navbar
    document.addEventListener('navbarLoaded', () => {
      const darkToggle = document.getElementById('darkModeToggle');
      if (darkToggle) {
        darkToggle.addEventListener('click', function() {
          this.classList.toggle('active');
          document.body.classList.toggle('dark-mode');
        });
      }

      const menuToggle = document.querySelector('.menu-toggle');
      if (menuToggle) {
        menuToggle.addEventListener('click', () => {
          document.querySelector('.sidebar')?.classList.toggle('active');
        });
      }
    });

    // =============================================
    // FUNÇÕES DE GERENCIAMENTO DE CONEXÃO
    // =============================================
    async function consultarDeepSeek(mensagemUser) {
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            model: "deepseek-chat",
            messages: [
              { role: "system", content: "Você é um analista de sobras de produtos da Shopee." },
              { role: "user", content: mensagemUser }
            ]
          })
        });

        const dados = await resposta.json();
        return dados.choices?.[0]?.message?.content || "❌ Sem resposta da IA.";
      } catch (error) {
        console.error("Erro ao consultar DeepSeek:", error);
        updateConnectionStatus(false);
        return "❌ Erro ao se comunicar com o servidor.";
      }
    }

    function verificarConexao() {
      firebase.firestore().enableNetwork()
        .then(() => {
          console.log("Conectado ao Firestore");
          document.getElementById('connectionStatus').className = 'connection-status online';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        })
        .catch((error) => {
          console.error("Erro de conexão:", error);
          document.getElementById('connectionStatus').className = 'connection-status offline';
          document.getElementById('connectionStatus').innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        });
    }

    function mostrarErroFirebase(error) {
      const errorBox = document.getElementById('firebase-error');
      const errorMessage = document.getElementById('error-message');
      
      errorMessage.innerHTML = `<strong>${error.message}</strong><br>(Código: ${error.code})`;
      errorBox.style.display = 'block';

      console.error("Erro Firebase:", error);
      updateConnectionStatus(false);
    }

    function updateConnectionStatus(online) {
      const statusElement = document.getElementById('connectionStatus');
      
      if (online) {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Online</span>';
        statusElement.className = 'connection-status online';
      } else {
        statusElement.innerHTML = '<div class="status-dot"></div> <span>Offline - Trabalhando localmente</span>';
        statusElement.className = 'connection-status offline';
      }
    }

    // =============================================
    // FUNÇÕES UTILITÁRIAS
    // =============================================
    
    function mostrarSucesso(mensagem) {
      const alerta = document.getElementById('alertSuccess');
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';
      
      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    function mostrarErro(mensagem) {
      const alerta = document.getElementById('alertError');
      alerta.querySelector('.alert-content').textContent = mensagem;
      alerta.style.display = 'flex';
      
      setTimeout(() => {
        alerta.style.display = 'none';
      }, 5000);
    }

    function toggleLoading(botao, texto) {
      const btnText = botao.querySelector('span') || botao;
      if (botao.classList.contains('loading')) {
        botao.classList.remove('loading');
        btnText.innerHTML = texto;
      } else {
        botao.classList.add('loading');
        btnText.innerHTML = '<div class="loading"></div> Carregando...';
      }
    }

    async function notificarResponsavelFinanceiro(dataRef, loja, bruto, liquido, qtdVendas) {
      try {
        const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
        const dadosUsuario = usuarioDoc.data() || {};
        const autorNome = dadosUsuario.nome || firebase.auth().currentUser?.email || '';
        const autorEmail = firebase.auth().currentUser?.email || '';
        const respEmail = dadosUsuario.responsavelFinanceiroEmail;
        if (!respEmail) return;
        const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
        if (respSnap.empty) return;
        const respDoc = respSnap.docs[0];
        const respData = respDoc.data() || {};
        const responsavelUid = respData.uid || respDoc.id;
        const descricao = `Faturamento de ${dataRef} da loja ${loja} atualizado. Bruto: R$ ${bruto.toFixed(2)}, Líquido: R$ ${liquido.toFixed(2)}, Vendas: ${qtdVendas}`;
        await db.collection('financeiroAtualizacoes').add({
          descricao,
          autorUid: usuarioLogado.uid,
          autorNome,
          autorEmail,
          dataFaturamento: dataRef,
          destinatarios: [responsavelUid, usuarioLogado.uid],
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          anexos: [],
          tipo: 'faturamento'
        });
      } catch (e) {
        console.error('Erro ao notificar responsável financeiro:', e);
      }
    }

    async function executarComRetry(operacao, maxTentativas = 3, delay = 1000) {
      let tentativas = 0;
      
      while (tentativas < maxTentativas) {
        try {
          return await operacao();
        } catch (error) {
          tentativas++;
          if (tentativas >= maxTentativas) throw error;
          
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Aumenta o delay exponencialmente
        }
      }
    }
    
    function atualizarPrecoMinimo() {
      const sku = document.getElementById('metaSku').value.trim();
      const custo = produtos[sku]; // usa o campo `custo`
          const info = document.getElementById('custoProdutoInfo');
      const metaInput = document.getElementById('metaValor');

      if (!info || !metaInput) return;

      if (custo) {
        const valorFormatado = parseFloat(custo).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
        info.textContent = `Custo (usado como meta): R$ ${valorFormatado}`;
        info.style.color = '#06d6a0';

        metaInput.value = parseFloat(custo).toFixed(2); // preencher automaticamente o campo de meta
      } else {
        info.textContent = '';
        metaInput.value = '';
      }
    }
    
    // =============================================
    // FUNÇÕES DE NAVEGAÇÃO E INTERFACE
    // =============================================
    
    function podeAcessarProdutosVendidos() {
      const perfilRaw = (window.userPerfil || usuarioLogado.perfil || '')
        .toString()
        .toLowerCase();
      const perfilNormalizado = perfilRaw
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .trim();
      const perfisPermitidos = new Set([
        'gestor',
        'responsavel',
        'gestor financeiro',
        'responsavel financeiro',
        'adm',
        'admin',
        'administrador',
      ]);
      return (
        perfisPermitidos.has(perfilNormalizado) ||
        window.isFinanceiroResponsavel === true
      );
    }

    function verificarPermissaoAba(id) {
      if (id !== 'produtosVendidos') {
        return true;
      }
      const autorizado = podeAcessarProdutosVendidos();
      if (!autorizado) {
        if (window.Swal) {
          Swal.fire(
            'Acesso restrito',
            'Esta aba está disponível apenas para gestores ou responsáveis financeiros.',
            'warning',
          );
        } else {
          alert(
            'A aba Produtos Vendidos está disponível apenas para gestores ou responsáveis financeiros.',
          );
        }
      }
      return autorizado;
    }

    window.trocarAba = function trocarAba(id) {
      if (!verificarPermissaoAba(id)) {
        return;
      }

      // Remove a classe 'active' de todas as abas
      document
        .querySelectorAll('.tab-content')
        .forEach((aba) => aba.classList.remove('active'));

      // Ativa a aba correspondente, se existir
      const abaSelecionada = document.getElementById(id);
      if (abaSelecionada) {
        abaSelecionada.classList.add('active');
      } else {
        console.warn(`❌ Aba com ID '${id}' não encontrada.`);
        return;
      }

      // Atualiza gráficos, se necessário
      if (id === 'graficos') {
        setTimeout(atualizarGraficos, 100);
      }
      if (id === 'produtosVendidos') {
        if (!produtosVendidosCarregado) carregarProdutosVendidos();
        else renderProdutosVendidos();
      }
    };


    // =============================================
    // FUNÇÕES DE GERENCIAMENTO DE METAS
    // =============================================
    async function carregarProdutos() {
      try {
let consulta;
        if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
          consulta = db.collectionGroup('produtos');
        } else {
          consulta = db.collection('uid').doc(usuarioLogado.uid).collection('produtos');
        }
        const snapshot = await consulta.get();
        produtos = {};
        const datalist = document.getElementById('listaSkus');
        if (datalist) datalist.innerHTML = '';

        snapshot.forEach(doc => {
          const data = doc.data();
          if (!data.sku) return;
          produtos[data.sku] = data.custo;
          if (datalist) {
            const opt = document.createElement('option');
            const preco = data.custo ? parseFloat(data.custo).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) : '0.00';
            opt.value = data.sku;
            opt.label = `${data.sku} - R$ ${preco}`;
            datalist.appendChild(opt);
          }
        });
      } catch (error) {
        console.error('Erro ao carregar produtos:', error);
      }
    }

    async function carregarMetas() {
      try {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
        
        return await executarComRetry(async () => {
          metas = {};
          // Carrega SKUs e custo dos produtos cadastrados
  let produtosSnapQuery;
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            produtosSnapQuery = db.collectionGroup('produtos');
          } else {
            produtosSnapQuery = db.collection('uid').doc(usuarioLogado.uid).collection('produtos');
          }
          const produtosSnap = await produtosSnapQuery.get();
          produtosSnap.forEach((doc) => {
            const data = doc.data();
            if (data.sku && data.custo !== undefined) {
              metas[data.sku] = {
                valor: parseFloat(data.custo),
                atualizadoEm: new Date()
              };
          produtos[data.sku] = data.custo;
            }
          });

          // Sobrepõe com metas salvas manualmente se existirem
          let metasSnapQuery = db.collection("metasSKU");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            metasSnapQuery = metasSnapQuery.where('uid', '==', usuarioLogado.uid);
          }
          const metasSnap = await metasSnapQuery.get();
          metasSnap.forEach((doc) => {
            const originalSku = doc.id.replaceAll('__', '/');
            metas[originalSku] = {
              valor: doc.data().valor,
              atualizadoEm: doc.data().atualizadoEm?.toDate() || new Date()
            };
          });
          
          renderizarMetas();
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar metas: ${error.message}`);
        console.error("Erro ao carregar metas:", error);
        return false;
      } finally {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
      }
    }

    async function carregarHistorico() {
      try {
        return await executarComRetry(async () => {
          historico = [];
          let histQuery = db.collection("historicoMetas");
          if (!['adm', 'admin'].includes(usuarioLogado.perfil.toLowerCase())) {
            histQuery = histQuery.where('uid', '==', usuarioLogado.uid);
          }
          const snapshot = await histQuery.orderBy("data", "desc").limit(50).get();          
          snapshot.forEach((doc) => {
            historico.push({
              sku: doc.data().sku,
              acao: doc.data().acao,
              valorAnterior: doc.data().valorAnterior,
              valorNovo: doc.data().valorNovo,
              data: doc.data().data.toDate(),
              usuario: doc.data().usuario || 'Sistema'
            });
          });
          
          renderizarHistorico();
          return true;
        });
      } catch (error) {
        mostrarErroFirebase(`Erro ao carregar histórico: ${error.message}`);
        console.error("Erro ao carregar histórico:", error);
        return false;
      }
    }

    async function registrarHistorico(sku, acao, valorAnterior, valorNovo) {
      try {
        await executarComRetry(async () => {
          await db.collection("historicoMetas").add({
            sku: sku,
            acao: acao,
            valorAnterior: valorAnterior,
            valorNovo: valorNovo,
            data: new Date(),
            usuario: "Usuário", // Em um sistema real, pegaria do auth
            uid: usuarioLogado.uid
          });
          
          // Recarregar histórico após adicionar novo registro
          await carregarHistorico();
          return true;
        });
      } catch (error) {
        console.error("Erro ao registrar histórico:", error);
        throw error;
      }
    }

    function renderizarMetas() {
      const tbody = document.querySelector('#tabelaMetas tbody');
      tbody.innerHTML = '';
      
      if (Object.keys(metas).length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align: center;">Nenhuma meta cadastrada</td></tr>';
        return;
      }
      
      for (let sku in metas) {
        const meta = metas[sku];
        const precoProduto = produtos[sku];
        const dataFormatada = meta.atualizadoEm ? meta.atualizadoEm.toLocaleDateString('pt-BR') : 'N/A';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${sku}</td>
          <td>${precoProduto ? 'R$ ' + parseFloat(precoProduto).toLocaleString('pt-BR', { minimumFractionDigits: 2 }) : '-'}</td>
          <td>
            <span class="valorMeta">R$ ${meta.valor.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</span>
            <input class="editInput" type="number" value="${meta.valor}" step="0.01" />
          </td>
          <td>${dataFormatada}</td>
          <td>
            <button onclick="editarMeta(this, '${sku}')" class="btn btn-sm" style="background: rgba(99, 102, 241, 0.1); color: var(--primary);">
              <i class="fas fa-edit"></i>
            </button>
            <button onclick="excluirMeta('${sku}', this)" class="btn btn-sm" style="background: rgba(239, 71, 111, 0.1); color: var(--error);">
              <i class="fas fa-trash-alt"></i>
            </button>
          </td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderizarHistorico() {
      const lista = document.getElementById('listaHistorico');
      lista.innerHTML = '';
      
      if (historico.length === 0) {
        lista.innerHTML = '<div class="history-item" style="text-align: center;">Nenhum registro histórico encontrado</div>';
        return;
      }
      
      historico.forEach(item => {
        const div = document.createElement('div');
        div.className = 'history-item';
        
        let acaoTexto = '';
        let valorTexto = '';
        
        if (item.acao === 'adicionar') {
          acaoTexto = `<span class="badge badge-success">Adicionado</span>`;
          valorTexto = `Novo valor: R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'editar') {
          acaoTexto = `<span class="badge badge-warning">Editado</span>`;
          valorTexto = `De R$ ${item.valorAnterior?.toFixed(2) || '0.00'} para R$ ${item.valorNovo?.toFixed(2) || '0.00'}`;
        } else if (item.acao === 'remover') {
          acaoTexto = `<span class="badge badge-danger">Removido</span>`;
          valorTexto = `Valor anterior: R$ ${item.valorAnterior?.toFixed(2) || '0.00'}`;
        }
        
        div.innerHTML = `
          <div class="flex justify-between items-start flex-wrap gap-4 p-4 rounded-lg shadow transition hover:shadow-xl border border-gray-200 bg-white">
            <div>
              <div class="flex items-center gap-2 mb-2">
                <strong class="text-blue-800">${item.sku}</strong>
                ${acaoTexto}
              </div>
              <div class="text-sm text-gray-600">${valorTexto}</div>
              <div class="text-sm text-gray-500 mt-1">👤 Por: ${item.usuario}</div>
            </div>
            <div class="text-sm text-gray-500 text-right">
              <i class="fas fa-clock"></i>
              ${item.data.toLocaleDateString('pt-BR')}<br>${item.data.toLocaleTimeString('pt-BR')}
            </div>
          </div>
        `;
        
        lista.appendChild(div);
      });
    }

    function filtrarHistorico() {
      const filtro = document.getElementById('filtroHistorico').value.toLowerCase();
      const itens = document.querySelectorAll('#listaHistorico .history-item');
      
      itens.forEach(item => {
        const sku = item.querySelector('strong')?.textContent.toLowerCase() || '';
        item.style.display = sku.includes(filtro) ? '' : 'none';
      });
    }

    async function adicionarMeta() {
      const skuInput = document.getElementById('metaSku');
      const valorInput = document.getElementById('metaValor');
      
      const sku = skuInput.value.trim();
      const valor = parseFloat(valorInput.value);
      
      if (!sku) {
        mostrarErro('Por favor, informe o SKU do produto.');
        skuInput.focus();
        return;
      }
      
      if (isNaN(valor) || valor <= 0) {
        mostrarErro('Por favor, informe um valor válido para a meta (maior que zero).');
        valorInput.focus();
        return;
      }
      if (!produtos[sku]) {
        const usarIA = confirm("SKU não cadastrado. Deseja uma sugestão de meta via IA?");
        
        if (usarIA) {
            try {
                const categoria = prompt("Informe a categoria do produto:");
                if (categoria === null) return;
                
                const custo = prompt("Informe o custo do produto:");
                if (custo === null) return;
                
                const margem = prompt("Informe a margem esperada (%):");
                if (margem === null) return;
                
                const concorrentes = prompt("Informe o preço médio dos concorrentes:");
                if (concorrentes === null) return;

                const promptText = `Sugira uma meta de sobra para: ${categoria} | Custo: R$${custo} | Margem: ${margem}% | Concorrentes: ${concorrentes}`;
                
                const resposta = await consultarDeepSeek(promptText);
                const match = resposta.match(/R\$\s*([\d.,]+)/);
                const valorSugerido = match ? parseFloat(match[1].replace('.', '').replace(',', '.')) : null;
                
                if (valorSugerido && !isNaN(valorSugerido)) {
                    valorInput.value = valorSugerido.toFixed(2);
                    mostrarSucesso(`Sugestão da IA: R$ ${valorSugerido.toFixed(2)}`);
                } else {
                    mostrarErro("Não consegui extrair o valor. Resposta completa: " + resposta);
                }
            } catch (error) {
                mostrarErro(`Erro na consulta: ${error.message}`);
            }
            return;
        }
        }
      try {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
        
        const safeSku = sku.replaceAll('/', '__');
        const metaData = {
          valor: valor,
          atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
          uid: usuarioLogado.uid
        };
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).set(metaData);
          return true;
        });
        
        // Atualizar localmente
        metas[sku] = {
          valor: valor,
          atualizadoEm: new Date()
        };
        
        // Registrar no histórico
        await registrarHistorico(sku, 'adicionar', null, valor);
        
        renderizarMetas();
        
        skuInput.value = '';
        valorInput.value = '';
        document.getElementById('custoProdutoInfo').textContent = '';
        
        mostrarSucesso(`Meta para o SKU ${sku} adicionada com sucesso!`);
        
        // Atualizar gráficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao adicionar meta: ${error.message}`);
        console.error("Erro ao adicionar meta:", error);
      } finally {
        toggleLoading(document.getElementById('btnAdicionarMeta'), '<i class="fas fa-plus"></i> Adicionar Meta');
      }
    }

    async function editarMeta(botao, sku) {
      const tr = botao.closest('tr');
      const span = tr.querySelector('.valorMeta');
      const input = tr.querySelector('.editInput');
      const icon = botao.querySelector('i');
      
      if (input.style.display === 'none') {
        // Iniciar edição
        input.style.display = 'inline-block';
        span.style.display = 'none';
        icon.className = 'fas fa-save';
        input.focus();
      } else {
        // Salvar edição
        const novoValor = parseFloat(input.value);
        
        if (isNaN(novoValor) || novoValor <= 0) {
          mostrarErro('Por favor, informe um valor válido para a meta (maior que zero).');
          input.focus();
          return;
        }
        
        try {
          icon.className = 'fas fa-spinner fa-spin';
          
          const valorAnterior = metas[sku].valor;
          const safeSku = sku.replaceAll('/', '__');
          const metaData = {
            valor: novoValor,
            atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
            uid: usuarioLogado.uid
          };
          
          await executarComRetry(async () => {
            await db.collection("metasSKU").doc(safeSku).set(metaData);
            return true;
          });
          
          // Atualizar localmente
          metas[sku] = {
            valor: novoValor,
            atualizadoEm: new Date()
          };
          
          // Registrar no histórico
          await registrarHistorico(sku, 'editar', valorAnterior, novoValor);
          
          renderizarMetas();
          mostrarSucesso(`Meta para o SKU ${sku} atualizada com sucesso!`);
          
          // Atualizar gráficos se estiver na aba
          if (document.getElementById('graficos').classList.contains('active')) {
            atualizarGraficos();
          }
        } catch (error) {
          mostrarErro(`Erro ao editar meta: ${error.message}`);
          console.error("Erro ao editar meta:", error);
          // Reverter visualmente
          input.value = metas[sku].valor;
        } finally {
          input.style.display = 'none';
          span.style.display = 'inline-block';
          icon.className = 'fas fa-edit';
        }
      }
    }

    async function excluirMeta(sku, botao) {
      if (!confirm(`Tem certeza que deseja excluir a meta do SKU ${sku}?`)) {
        return;
      }
      
      try {
        const icon = botao.querySelector('i');
        icon.className = 'fas fa-spinner fa-spin';
        
        const valorAnterior = metas[sku].valor;
        const safeSku = sku.replaceAll('/', '__');
        
        await executarComRetry(async () => {
          await db.collection("metasSKU").doc(safeSku).delete();
          return true;
        });
        
        // Remover localmente
        delete metas[sku];
        
        // Registrar no histórico
        await registrarHistorico(sku, 'remover', valorAnterior, null);
        
        renderizarMetas();
        mostrarSucesso(`Meta para o SKU ${sku} removida com sucesso!`);
        
        // Atualizar gráficos se estiver na aba
        if (document.getElementById('graficos').classList.contains('active')) {
          atualizarGraficos();
        }
      } catch (error) {
        mostrarErro(`Erro ao excluir meta: ${error.message}`);
        console.error("Erro ao excluir meta:", error);
      }
    }

    // =============================================
    // FUNÇÕES DE PROCESSAMENTO DE PEDIDOS
    // =============================================
    
    function processarPlanilha() {
      const fileInput = document.getElementById('inputExcel');
      const file = fileInput.files[0];
      const feedback = document.getElementById('feedbackImportacao');
      feedback.innerHTML = '';

      if (!file) {
        feedback.innerHTML = '<span class="badge badge-warning">⚠️ Selecione um arquivo</span>';
        return;
      }

      try {
        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');

        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const data = new Uint8Array(e.target.result);
            const wb = XLSX.read(data, { type: 'array' });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            const pedidos = XLSX.utils.sheet_to_json(sheet);

            processarPedidos(pedidos);
            feedback.innerHTML = '<span class="badge badge-success">✔️ Importado com sucesso</span>';
          } catch (error) {
            feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
            console.error("Erro ao ler arquivo:", error);
          } finally {
            toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
          }
        };

        reader.onerror = function() {
          feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
          toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
        };

        reader.readAsArrayBuffer(file);
      } catch (error) {
        feedback.innerHTML = '<span class="badge badge-danger">⚠️ Erro no arquivo</span>';
        console.error("Erro ao processar arquivo:", error);
        toggleLoading(document.getElementById('btnProcessar'), 'Processar Planilha');
      }
    }

    function processarPedidos(pedidos) {
      const contagem = {};
      pedidos.forEach(p => {
        const id = p['ID do pedido'];
        if (id) contagem[id] = (contagem[id] || 0) + 1;
      });

      const tbody = document.querySelector('#resultado tbody');
      tbody.innerHTML = '';
      let totalSobra = 0, totalPercentual = 0, totalPedidos = 0;
      
      pedidosProcessados = [];

      pedidos.forEach(p => {
        const id = p['ID do pedido'];
        if (!id || contagem[id] > 1) return;

        const sku = p['Número de referência SKU'] || '';
        const status = (p['Status do pedido'] || '').toLowerCase();
        if (!sku || status.includes('cancelado') || status.includes('não pago')) return;

        const subtotal = parseFloat(p['Subtotal do produto']) || 0;
        const reembolso = parseFloat(p['Reembolso Shopee']) || 0;
        const cupom = parseFloat(p['Cupom do vendedor']) || 0;
        const comissao = parseFloat(p['Taxa de comissão']) || 0;
        const servico = parseFloat(p['Taxa de serviço']) || 0;
        const sobra = subtotal + reembolso - cupom - comissao - servico;
        const meta = metas[sku]?.valor || 0;
        const percentual = meta ? ((sobra - meta) / meta) * 100 : 0;
       const prazo = p['Prazo de coleta'] || p['Prazo de Coleta'] || '';

        const pedidoData = {
          id, sku, subtotal, reembolso, cupom, comissao, servico, sobra, meta, percentual, status, prazo
        };
        
        pedidosProcessados.push(pedidoData);

        const tr = document.createElement('tr');
        
        // Determinar status e ícones
        let statusText = '';
        let statusIcon = '';
        let rowClass = '';

        if (meta) {
          if (percentual <= -10) {
            statusText = 'Crítico';
            statusIcon = '❌';
            rowClass = 'status-critico';
          } else if (percentual <= -5) {
            statusText = 'Atenção';
            statusIcon = '⚠️';
          } else if (percentual >= 5) {
            statusText = 'Bom';
            statusIcon = '✔️';
            rowClass = 'status-correto';
          } else {
            statusText = 'Normal';
            statusIcon = '✔️';
          }
        } else {
          statusText = 'Sem meta';
          statusIcon = '⚠️';
        }

        tr.className = rowClass;
        tr.innerHTML = `
          <td>${id}</td>
          <td>${sku}</td>
          <td>R$ ${subtotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${reembolso.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${cupom.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${comissao.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td>R$ ${servico.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
          <td><strong>R$ ${sobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</strong><br><small>Meta: R$ ${meta.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</small></td>
          <td>${percentual.toFixed(2)}%</td>
          <td class="status-only" data-status="${statusText}">${statusIcon} ${statusText}</td>
        `;
        
        tbody.appendChild(tr);

        totalSobra += sobra;
        totalPercentual += percentual;
        totalPedidos++;
      });

      // Calcular total esperado com base na quantidade de pedidos por SKU
      const linhas = document.querySelectorAll("#resultado tbody tr");
      let esperadoTotal = 0;
      linhas.forEach(l => {
        const sku = l.children[1].textContent.trim();
        if (metas[sku]) esperadoTotal += metas[sku].valor;
      });
    
      const media = totalPedidos ? (totalPercentual / totalPedidos).toFixed(2) : '0.00';
      const diferencaTotal = totalSobra - esperadoTotal;
      const diferencaPercentual = esperadoTotal ? (diferencaTotal / esperadoTotal) * 100 : 0;

      let diferencaHTML = '';
      if (esperadoTotal > 0) {
        const diferencaClass = diferencaTotal >= 0 ? 'success' : 'danger';
        diferencaHTML = `
          <div style="margin-top: 1rem; padding: 1rem; background: rgba(6, 214, 160, 0.05); border-radius: 12px; border-left: 4px solid var(--${diferencaClass});">
            <h4>
              <span class="badge badge-${diferencaClass}">
                Diferença Total: R$ ${Math.abs(diferencaTotal).toLocaleString('pt-BR', { minimumFractionDigits: 2 })} 
                (${diferencaPercentual.toFixed(2)}%)
                ${diferencaTotal >= 0 ? 'acima' : 'abaixo'} da meta
              </span>
            </h4>
          </div>
        `;
      }

      document.getElementById('totalSobra').innerHTML = `
        <div class="card">
          <div class="card-header">
            <i class="fas fa-coins"></i>
            <h3>Resumo Financeiro</h3>
          </div>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
            <div style="background: rgba(99, 102, 241, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--primary);">
              <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Sobra Total</h4>
              <h2>R$ ${totalSobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>
            
            <div style="background: rgba(6, 214, 160, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--success);">
              <h4 style="color: var(--success); margin-bottom: 0.5rem;">Sobra Esperada</h4>
              <h2>R$ ${esperadoTotal.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</h2>
            </div>
            
            <div style="background: rgba(108, 117, 125, 0.05); padding: 1.5rem; border-radius: 12px; border-left: 4px solid var(--secondary);">
              <h4 style="color: var(--secondary); margin-bottom: 0.5rem;">Média de Desempenho</h4>
              <h2>${media}%</h2>
            </div>
          </div>
          ${diferencaHTML}
        </div>
      `;
        document.getElementById('totalSobra').innerHTML += `
        <div style="margin-top: 1.5rem;">
           
        </div>
    `;
    
    // Salvar dados para análise posterior
    window.dadosParaAnalise = {
        pedidos: pedidosProcessados,
        resumo: {
            totalSobra,
            esperadoTotal,
            media
        }
    };
      const sobras = pedidosProcessados.map(p => {
  return {
    sku: p.sku,
    vendido: p.subtotal,
    sobra: p.sobra,
    meta: p.meta,
    data: new Date().toLocaleDateString()
  };
});

document.getElementById("dadosSobrasIA").value = sobras.map(s => {
  return `SKU: ${s.sku}, Vendido: R$ ${s.vendido.toFixed(2)}, Sobra: R$ ${s.sobra.toFixed(2)}, Meta: R$ ${s.meta?.toFixed(2) || 0}, Data: ${s.data}`;
}).join("\n");
        renderizarTabelaLogistica();
}

      // Atualizar gráficos se estiver na aba
      if (document.getElementById('graficos').classList.contains('active')) {
        atualizarGraficos();
      }
    

    function limparFiltros() {
      document.getElementById("filtroSKU").value = "";
      document.getElementById("filtroStatus").value = "";
      document.getElementById("tipoFiltro").value = "exata";
      filtrarPorSKU();
    }
// =============================================
    // CONTROLE LOGÍSTICO DE PEDIDOS
    // =============================================

    function salvarLogistica() {
      localStorage.setItem('controleLogistica', JSON.stringify(logistica));
    }

    function renderizarTabelaLogistica() {
      const tbody = document.querySelector('#tabelaLogistica tbody');
      if (!tbody) return;
      tbody.innerHTML = '';
      const hoje = new Date();

      pedidosProcessados.forEach(p => {
        if (!logistica[p.id]) {
          logistica[p.id] = {
            status: 'pendente',
            rastreio: '',
            checklist: { itens: false, etiqueta: false, lacre: false },
            prazo: p.prazo || '',
            dataPostagem: null
          };
        }
        const item = logistica[p.id];
        const prazoData = item.prazo ? new Date(item.prazo) : null;
        const prazoProximo = prazoData && (prazoData - hoje) / (1000 * 60 * 60 * 24) <= 1 && item.status !== 'postado';
        const statusLinha = prazoProximo ? 'prazo' : item.status;
        const postadoPrazo = item.status === 'postado' && item.dataPostagem && prazoData ? new Date(item.dataPostagem) <= prazoData : null;

        const tr = document.createElement('tr');
        tr.dataset.status = statusLinha;

        const progresso = (item.status === 'postado' ? 1 : 0) + (item.checklist.itens ? 1 : 0) + (item.checklist.etiqueta ? 1 : 0) + (item.checklist.lacre ? 1 : 0);
        const progressoPercent = (progresso / 4) * 100;
        const corProgresso = progressoPercent === 100 ? 'var(--success)' : (progressoPercent >= 50 ? '#f59e0b' : 'var(--error)');

        tr.innerHTML = `
          <td>${p.id}</td>
          <td class="${statusLinha !== 'postado' ? 'text-red-600 font-bold' : ''}">
            <select onchange="atualizarStatusLogistica('${p.id}', this.value)" class="form-control">
              <option value="pendente"${item.status === 'pendente' ? ' selected' : ''}>Pendente</option>
              <option value="postado"${item.status === 'postado' ? ' selected' : ''}>Postado</option>
            </select>
          </td>
          <td><input type="text" class="form-control" value="${item.rastreio}" onchange="atualizarRastreio('${p.id}', this.value)" placeholder="Código" /></td>
          <td>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','itens', this.checked)" ${item.checklist.itens ? 'checked' : ''}/> Itens</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','etiqueta', this.checked)" ${item.checklist.etiqueta ? 'checked' : ''}/> Etiqueta</label><br>
            <label><input type="checkbox" onchange="atualizarChecklist('${p.id}','lacre', this.checked)" ${item.checklist.lacre ? 'checked' : ''}/> Lacre</label>
          </td>
          <td><div class="progress"><div class="progress-bar" style="width:${progressoPercent}%; background:${corProgresso};"></div></div></td>
          <td>${postadoPrazo === null ? '-' : postadoPrazo ? 'Sim' : 'Não'}</td>
        `;
        tbody.appendChild(tr);
      });

      salvarLogistica();
      verificarAlertasLogistica();
      aplicarFiltroLogistica();
    }

    function atualizarStatusLogistica(id, status) {
      if (!logistica[id]) return;
      logistica[id].status = status;
      if (status === 'postado') {
        logistica[id].dataPostagem = new Date().toISOString().split('T')[0];
      }
      salvarLogistica();
      renderizarTabelaLogistica();
    }

    function atualizarRastreio(id, codigo) {
      if (!logistica[id]) return;
      logistica[id].rastreio = codigo;
      salvarLogistica();
    }

    function atualizarChecklist(id, campo, valor) {
      if (!logistica[id]) return;
      logistica[id].checklist[campo] = valor;
      salvarLogistica();
    }

    function aplicarFiltroLogistica() {
      const filtro = document.getElementById('filtroStatusLogistica')?.value;
      document.querySelectorAll('#tabelaLogistica tbody tr').forEach(tr => {
        tr.style.display = !filtro || tr.dataset.status === filtro ? '' : 'none';
      });
    }

    function verificarAlertasLogistica() {
      const valores = Object.values(logistica);
      const pendentes = valores.filter(v => v.status !== 'postado').length;
      const prazoProximo = valores.filter(v => {
        if (!v.prazo || v.status === 'postado') return false;
        const diff = (new Date(v.prazo) - new Date()) / (1000 * 60 * 60 * 24);
        return diff <= 1;
      }).length;

      const mensagens = [];
      if (pendentes) mensagens.push(`${pendentes} pedidos pendentes de envio`);
      if (prazoProximo) mensagens.push(`${prazoProximo} com prazo de coleta próximo`);
      const alertaEl = document.getElementById('alertasLogistica');
      if (alertaEl) alertaEl.textContent = mensagens.join(' | ');
    }
    // =============================================
    // FUNÇÕES DE GRÁFICOS
    // =============================================
    
    function atualizarGraficos() {
        // Elemento do cabeçalho
        const chartHeader = document.querySelector('.chart-header');
        
        // Limpa o conteúdo anterior
        chartHeader.innerHTML = '<div class="chart-title">Comparação entre Sobra Real e Meta por SKU</div>';
        
        // Verificação de dados
        if (pedidosProcessados.length === 0) {
            document.querySelectorAll('.chart-container').forEach(container => {
                container.innerHTML = '<p style="text-align: center; color: var(--gray); padding: 2rem;">Nenhum dado disponível para exibir gráficos. Processe um arquivo primeiro.</p>';
            });
            
            // Adiciona botão mesmo sem dados (opcional)
            chartHeader.innerHTML += `
                <button onclick="analisarTendenciasIA()" class="btn btn-outline" disabled>
                    <i class="fas fa-chart-line"></i> Analisar Tendências com IA
                </button>
            `;
            return;
        }
        
        // Adiciona botão funcional quando há dados
        chartHeader.innerHTML += `
            <button onclick="analisarTendenciasIA()" class="btn btn-outline">
                <i class="fas fa-chart-line"></i> Analisar Tendências com IA
            </button>
        `;
        
        // Processamento dos dados
        const tipoFiltro = document.getElementById('filtroGrafico').value;
        let dados = agruparPorSKU(pedidosProcessados);
        
        // Aplicar filtro
        if (tipoFiltro === 'top10') {
            dados.sort((a, b) => b.diferencaPercentual - a.diferencaPercentual);
            dados = dados.slice(0, 10);
        } else if (tipoFiltro === 'bottom10') {
            dados.sort((a, b) => a.diferencaPercentual - b.diferencaPercentual);
            dados = dados.slice(0, 10);
        }
        
        // Criar gráficos
        criarGraficoBarras(dados);
        criarGraficoPizza(dados);
    }

    function agruparPorSKU(pedidos) {
      const agrupados = {};
      
      pedidos.forEach(pedido => {
        if (!agrupados[pedido.sku]) {
          agrupados[pedido.sku] = {
            sku: pedido.sku,
            totalSobra: 0,
            totalMeta: 0,
            quantidade: 0
          };
        }
        
        agrupados[pedido.sku].totalSobra += pedido.sobra;
        agrupados[pedido.sku].totalMeta += pedido.meta || 0;
        agrupados[pedido.sku].quantidade += 1;
      });
      
      // Converter para array e calcular diferenças
      return Object.values(agrupados).map(item => {
        const diferenca = item.totalSobra - item.totalMeta;
        const diferencaPercentual = item.totalMeta ? (diferenca / item.totalMeta) * 100 : 0;
        
        return {
          ...item,
          diferenca,
          diferencaPercentual
        };
      });
    } // ← Fechamento correto da função
    async function analisarTendenciasIA() {
        try {
            const prompt = `Analise estes dados de desempenho de produtos:
    ${JSON.stringify(pedidosProcessados.slice(0, 50), null, 2)}

    Identifique:
    1. Tendências sazonais
    2. Produtos com crescimento/declínio consistente
    3. Sugestões de ajuste de estoque
    4. Previsão para próxima semana

    Responda em tópicos curtos e diretos.`;

            const resposta = await consultarDeepSeek(prompt);
            
            // Exibir resultado
            document.querySelector('.chart-header').innerHTML += `
                <div class="card" style="margin-top: 1.5rem;">
                    <div class="card-header">
                        <i class="fas fa-lightbulb"></i>
                        <h3>Análise de Tendências</h3>
                    </div>
                    <div style="padding: 1.5rem;">
                        <pre style="white-space: pre-wrap;">${resposta}</pre>
                    </div>
                </div>
            `;
        } catch (error) {
            mostrarErro(`Erro na análise de tendências: ${error.message}`);
        }
    }
    function criarGraficoBarras(dados) {
      const ctx = document.getElementById('graficoBarras').getContext('2d');
      
      // Destruir gráfico anterior se existir
      if (graficoBarras) {
        graficoBarras.destroy();
      }
      
      // Preparar dados
      const labels = dados.map(item => item.sku);
      const sobras = dados.map(item => item.totalSobra);
      const metas = dados.map(item => item.totalMeta);
      
      graficoBarras = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Sobra Real (R$)',
              data: sobras,
              backgroundColor: 'rgba(249, 115, 22, 0.7)',
              borderColor: 'rgba(249, 115, 22, 1)',
              borderWidth: 1
            },
            {
              label: 'Meta Esperada (R$)',
              data: metas,
              backgroundColor: 'rgba(34, 197, 94, 0.7)',
              borderColor: 'rgba(34, 197, 94, 1)',
              borderWidth: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Valor (R$)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'SKU'
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: 'Comparação entre Sobra Real e Meta por SKU'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  label += 'R$ ' + context.raw.toLocaleString('pt-BR', { minimumFractionDigits: 2 });
                  return label;
                }
              }
            }
          }
        }
      });
    }

    function criarGraficoPizza(dados) {
      const ctx = document.getElementById('graficoPizza').getContext('2d');
      
      // Destruir gráfico anterior se existir
      if (graficoPizza) {
        graficoPizza.destroy();
      }
      
      // Preparar dados - vamos mostrar a diferença percentual
      const labels = dados.map(item => item.sku);
      const diferencas = dados.map(item => item.diferencaPercentual);
      
      // Criar cores baseadas no desempenho
      const backgroundColors = diferencas.map(val => {
        if (val >= 5) return 'rgba(76, 175, 80, 0.7)'; // Verde - acima
        if (val <= -5) return 'rgba(244, 67, 54, 0.7)'; // Vermelho - abaixo
        return 'rgba(255, 193, 7, 0.7)'; // Amarelo - dentro do esperado
      });
      
      graficoPizza = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: diferencas,
            backgroundColor: backgroundColors,
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Desempenho vs Meta por SKU (%)'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.raw || 0;
                  return `${label}: ${value.toFixed(2)}%`;
                }
              }
            }
          }
        }
      });
    }
    window.importarVendasML = async function () {
      const input = document.getElementById('inputVendasML');
      const file = input?.files?.[0];
      if (!file) return mostrarErro('Selecione um arquivo do Mercado Livre para importar.');

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Faturamento Mercado Livre',
        html: `
          <input type="date" id="swal-data-ml" class="swal2-input" />
          <input type="text" id="swal-loja-ml" class="swal2-input" placeholder="Nome da Loja" />
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const data = document.getElementById('swal-data-ml').value;
          const lojaNome = document.getElementById('swal-loja-ml').value.trim();
          if (!data || !/^\d{4}-\d{2}-\d{2}$/.test(data) || lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma data e uma loja válidas.');
          }
          return { data, loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;

      const dataReferencia = form.data;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { range: 5, defval: '' });
          if (!rows.length) {
            mostrarErro('Nenhum dado encontrado na planilha do Mercado Livre.');
            const progressContainer = document.getElementById('progressContainerML');
            if (progressContainer) progressContainer.classList.add('hidden');
            return;
          }

          const resultadoProcessamento = await processarPlanilhaVendas({
            rows,
            dataReferencia,
            loja,
            plataforma: 'Mercado Livre',
            resultadoId: 'resultadoVendasML',
            progressIds: {
              containerId: 'progressContainerML',
              barId: 'progressBarVendasML',
              textId: 'progressTextVendasML'
            },
            rowParser: (row, contexto) => extrairLinhaMercadoLivre(row, contexto)
          });

          if (resultadoProcessamento) {
            input.value = '';
          }
        } catch (err) {
          console.error('Erro ao importar planilha Mercado Livre', err);
          mostrarErro('Erro ao importar planilha do Mercado Livre: ' + err.message);
        }
      };
      reader.readAsArrayBuffer(file);
    };

    window.importarVendasTiny = async function () {
      const input = document.getElementById('inputVendasTiny');
      const file = input?.files?.[0];
      if (!file) return mostrarErro('Selecione um arquivo do Tiny para importar.');

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Pedidos Tiny',
        html: `
          <input type="date" id="swal-data-tiny" class="swal2-input" />
          <input type="text" id="swal-loja-tiny" class="swal2-input" placeholder="Nome da Loja" />
        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const data = document.getElementById('swal-data-tiny').value;
          const lojaNome = document.getElementById('swal-loja-tiny').value.trim();
          if (!data || !/^\d{4}-\d{2}-\d{2}$/.test(data) || lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma data e uma loja válidas.');
          }
          return { data, loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;

      const dataReferencia = form.data;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: 'array' });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
          if (!rows.length) {
            mostrarErro('Nenhum dado encontrado na planilha do Tiny.');
            const progressContainer = document.getElementById('progressContainerTiny');
            if (progressContainer) progressContainer.classList.add('hidden');
            return;
          }

          const resultadoProcessamento = await processarPlanilhaVendas({
            rows,
            dataReferencia,
            loja,
            plataforma: 'Tiny',
            resultadoId: 'resultadoVendasTiny',
            progressIds: {
              containerId: 'progressContainerTiny',
              barId: 'progressBarVendasTiny',
              textId: 'progressTextVendasTiny'
            },
            rowParser: (row, contexto) => extrairLinhaTiny(row, contexto)
          });

          if (resultadoProcessamento) {
            input.value = '';
          }
        } catch (err) {
          console.error('Erro ao importar planilha Tiny', err);
          mostrarErro('Erro ao importar planilha do Tiny: ' + err.message);
        }
      };
      reader.readAsArrayBuffer(file);
    };

    window.importarFaturamento = async function () {
      const input = document.getElementById("inputFaturamento");
      const file = input.files[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Informações de Faturamento',
        html: `\n          <input type="date" id="swal-data" class="swal2-input" />\n          <input type="text" id="swal-loja" class="swal2-input" placeholder="Nome da Loja" />\n        `,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const data = document.getElementById('swal-data').value;
          const lojaNome = document.getElementById('swal-loja').value.trim();
          if (!data || !/^\d{4}-\d{2}-\d{2}$/.test(data) || lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma data e uma loja válidas.');
          }
          return { data, loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;
      const dataReferencia = form.data;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const ref = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .collection('lojas')
            .doc(loja);
          const doc = await ref.get();

          let operacao = "salvar";
          if (doc.exists) {
            const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
              title: 'Registro existente',
              text: 'Já existe um registro para esta loja e data. O que deseja fazer?',
              showDenyButton: true,
              showCancelButton: true,
              confirmButtonText: 'Substituir',
              denyButtonText: 'Somar',
              cancelButtonText: 'Cancelar'
            });
            if (!substituir && !somar) return;
            operacao = somar ? "somar" : "substituir";
          }

            let bruto = 0, taxas = 0, qtdVendas = 0;
            const skusVendidos = {};
            const pedidosErrados = [];

            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('faturamentoProgressBar');
            const progressText = document.getElementById('faturamentoProgressText');
            if (progressContainer && progressBar && progressText) {
              progressContainer.classList.remove('hidden');
              progressBar.style.width = '0%';
              progressText.textContent = '0%';
            }
            const totalRows = rows.length;
            let processedRows = 0;
            const updateProgress = async () => {
              if (progressBar && progressText) {
                const pct = Math.round((processedRows / totalRows) * 100);
                progressBar.style.width = pct + '%';
                progressText.textContent = pct + '%';
                if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
              }
            };

            for (const row of rows) {
            const status = (row['Status do pedido'] || '').toLowerCase();
            if (status.includes('cancelado') || status.includes('não pago')) {
              processedRows++;
              await updateProgress();
              continue;
            }

            const subtotal = parseFloat(row['Subtotal do produto']) || 0;
            const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
            const cupom = parseFloat(row['Cupom do vendedor']) || 0;
            const comissao = parseFloat(row['Taxa de comissão']) || 0;
            const servico = parseFloat(row['Taxa de serviço']) || 0;

            const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

            bruto += subtotal + reembolso;
            taxas += cupom + comissao + servico;
            qtdVendas++;

              const headers = Object.keys(row);
              const headerSKU = headers.find(h => h.trim() === 'Número de referência SKU'); // pega o nome exato
              const sku = headerSKU ? row[headerSKU] : null;
              if (!sku) {
                processedRows++;
                await updateProgress();
                continue;
              }

              if (!skusVendidos[sku]) skusVendidos[sku] = { total: 0, valorLiquido: 0 };
              skusVendidos[sku].total++;
              skusVendidos[sku].valorLiquido += liquidoLinha;

              const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
              const pedidoId = headerPedido ? row[headerPedido] : null;
              const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
              const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
              const metaUnit = metas[sku]?.valor || 0;
              const metaEsperada = metaUnit * (quantidade || 1);
              const sobraReal = liquidoLinha;

              if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                pedidosErrados.push({
                  dia: dataReferencia,
                  loja: loja,
                  pedido: pedidoId,
                  sku: sku,
                  quantidade: quantidade,
                  subtotal: subtotal,
                  sobraReal: sobraReal,
                  totalLiquido: sobraReal,
                  sobraEsperada: metaEsperada,
                  uid: usuarioLogado.uid,
                  critico: true
                });
              }

              processedRows++;
              await updateProgress();
            }
            if (progressBar && progressText) {
              progressBar.style.width = '100%';
              progressText.textContent = '100%';
            }
            if (pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = bruto - taxas;

          if (operacao === "somar" && doc.exists) {
            const anterior = doc.data();
            bruto += anterior.valorBruto || 0;
            taxas += anterior.taxasPlataforma || 0;
            qtdVendas += anterior.qtdVendas || 0;
          }

          // Salvar SKUs vendidos
 const refSku = db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('skusVendidos')
            .doc(dataReferencia);
          await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true }); // garante doc pai e marca usuário
          if (baseResp) {
            await baseResp
              .collection('skusVendidos')
              .doc(dataReferencia)
              .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          for (const [sku, dadosSku] of Object.entries(skusVendidos)) {
            const skuId = makeSkuDocId(sku);
            const legacySkuId = makeLegacySkuDocId(sku);
            const listaCollection = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia)
              .collection('lista');
            const docRef = listaCollection.doc(skuId);
            const docSnap = await docRef.get();

            let totalFinal = dadosSku.total;
            let valorLiquidoFinal = dadosSku.valorLiquido;
            if (docSnap.exists) {
              const dadosAnteriores = docSnap.data();
              totalFinal += dadosAnteriores.total || 0;
              valorLiquidoFinal += dadosAnteriores.valorLiquido || 0;
            } else if (legacySkuId !== skuId) {
              const legacyDocRef = listaCollection.doc(legacySkuId);
              const legacySnap = await legacyDocRef.get();
              if (legacySnap.exists) {
                const dadosAnteriores = legacySnap.data();
                totalFinal += dadosAnteriores.total || 0;
                valorLiquidoFinal += dadosAnteriores.valorLiquido || 0;
                try {
                  await legacyDocRef.delete();
                } catch (err) {
                  console.warn('Não foi possível remover SKU legado', legacySkuId, err);
                }
              }
            }

            await docRef.set({
              sku: sku,
              total: totalFinal,
              valorLiquido: valorLiquidoFinal,
              data: dataReferencia,
              loja: loja,
              uid: usuarioLogado.uid
            });

            if (legacySkuId !== skuId) {
              listaCollection.doc(legacySkuId).delete().catch(() => {});
            }

            if (baseResp && respEmail) {
              const skuPayload = {
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              };
              const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
              const baseRespLista = baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista');
              await baseRespLista
                .doc(skuId)
                .set({ encrypted: encSku, uid: usuarioLogado.uid });
              if (legacySkuId !== skuId) {
                baseRespLista.doc(legacySkuId).delete().catch(() => {});
              }
            }
          }
          
          const pass = getPassphrase() || usuarioLogado.uid;

          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          for (const row of rows) {
            const statusPedido = row['Status do pedido'] || '';
            const headersPedido = Object.keys(row);
            const headerSku = headersPedido.find(h => h.trim() === 'Número de referência SKU');
            const skuPedido = headerSku ? row[headerSku] : null;
           const headerPedidoId = headersPedido.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
           const pedidoId = headerPedidoId ? row[headerPedidoId] : null;
           const headerPagamento = headersPedido.find(h => h.toLowerCase().includes('hora do pagamento'));
           const horaPagamento = headerPagamento ? row[headerPagamento] : null;
           const headerPrevEnvio = headersPedido.find(h => h.toLowerCase().includes('data prevista') && h.toLowerCase().includes('envio'));
           let dataPrevistaEnvio = headerPrevEnvio ? row[headerPrevEnvio] : null;
           dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);
           const headerRastreamento = headersPedido.find(h => h.toLowerCase().includes('rastreamento'));
           const numeroRastreamento = headerRastreamento ? String(row[headerRastreamento]).trim() : '';
            const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
            const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
            const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
            const comissaoPedido = parseFloat(row['Taxa de comissão']) || 0;
            const servicoPedido = parseFloat(row['Taxa de serviço']) || 0;
            const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
            const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;
            if (!pedidoId) continue;
            const pedidoPayload = {
              pedidoId,
              status: statusPedido,
              sku: skuPedido,
              loja,
              data: dataReferencia,
              horaPagamento,
              subtotal: subtotalPedido,
              taxas: taxasPedido,
              liquido: liquidoPedido,
              reembolso: reembolsoPedido
            };
            if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
            if (numeroRastreamento) {
              pedidoPayload.numeroRastreamento = numeroRastreamento;
              pedidoPayload.etiquetaImpressa = true;
            }

            const pedidoDocRef = pedidosRef
              .doc(dataReferencia)
              .collection('lista')
              .doc(pedidoId);
            const pedidoDoc = await pedidoDocRef.get();
            let needsUpdate = true;
            if (pedidoDoc.exists) {
              try {
                const atual = JSON.parse(
                  await decryptString(pedidoDoc.data().encrypted, pass)
                );
                if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                  needsUpdate = false;
                }
              } catch (e) {
                console.error('Erro ao comparar pedido existente', e);
              }
            }
            if (needsUpdate) {
              const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
              await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
              if (baseResp && respEmail) {
                const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                await baseResp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
              }
              if (baseExp && gestorEmail) {
                const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                await baseExp
                  .collection('pedidosreais')
                  .doc(dataReferencia)
                  .collection('lista')
                  .doc(pedidoId)
                  .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
              }
            }
          }

          const lojaPayload = {
            valorBruto: bruto,
            taxasPlataforma: taxas,
            valorLiquido: liquido,
            qtdVendas: qtdVendas,
            loja: loja,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid
         };
          const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
          await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
          if (baseResp && respEmail) {
            const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja)
              .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
          }

          const resumoPayload = {
            valorBruto: bruto,
            valorLiquido: liquido,
            taxasPlataforma: taxas,
            vendas: qtdVendas,
            atualizadoEm: new Date(),
            uid: usuarioLogado.uid
        };
          const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
await db
            .collection('uid')
            .doc(usuarioLogado.uid)
            .collection('faturamento')
            .doc(dataReferencia)
            .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
          if (baseResp && respEmail) {
            const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
            await baseResp
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
          }
          document.getElementById("resultadoFaturamento").innerHTML = `
            <div class="alert alert-success">
              <i class="fas fa-check-circle"></i>
              Faturamento de <strong>${dataReferencia}</strong> da loja <strong>${loja}</strong> registrado com sucesso.<br>
              <strong>Bruto:</strong> R$ ${bruto.toFixed(2)}<br>
              <strong>Taxas:</strong> R$ ${taxas.toFixed(2)}<br>
              <strong>Líquido:</strong> R$ ${liquido.toFixed(2)}<br>
              <strong>Qtd. Vendas:</strong> ${qtdVendas}
            </div>
          `;
          await notificarResponsavelFinanceiro(dataReferencia, loja, bruto, liquido, qtdVendas);

        } catch (err) {
          mostrarErro("Erro ao importar: " + err.message);
          console.error(err);
        }
      };

      reader.readAsArrayBuffer(file);
    };

    window.importarFaturamentoMassa = async function () {
      const input = document.getElementById("inputFaturamentoMassa");
      const file = input?.files?.[0];
      if (!file) return mostrarErro("Selecione um arquivo para importar.");

      const { value: form, isConfirmed } = await Swal.fire({
        title: 'Importação em Massa',
        html: `<input type="text" id="swal-loja-massa" class="swal2-input" placeholder="Nome da Loja" />`,
        focusConfirm: false,
        showCancelButton: true,
        confirmButtonText: 'Continuar',
        preConfirm: () => {
          const lojaNome = document.getElementById('swal-loja-massa').value.trim();
          if (lojaNome.length < 2) {
            Swal.showValidationMessage('Informe uma loja válida.');
          }
          return { loja: lojaNome };
        }
      });
      if (!isConfirmed || !form) return;
      const loja = form.loja;

      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, { type: "array" });
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(sheet);
          if (!rows.length) {
            mostrarErro("A planilha está vazia.");
            return;
          }

          const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
          const dadosUsuario = usuarioDoc.data() || {};
          const respEmail = dadosUsuario.responsavelFinanceiroEmail || null;
          let baseResp = null;
          if (respEmail) {
            const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
            if (!respSnap.empty) {
              const respDoc = respSnap.docs[0];
              const respData = respDoc.data() || {};
              const responsavelUid = respData.uid || respDoc.id;
              baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const gestorEmail = Array.isArray(dadosUsuario.gestoresExpedicaoEmails)
            ? dadosUsuario.gestoresExpedicaoEmails[0]
            : dadosUsuario.responsavelExpedicaoEmail || null;
          let baseExp = null;
          if (gestorEmail) {
            const expSnap = await db.collection('usuarios').where('email', '==', gestorEmail).limit(1).get();
            if (!expSnap.empty) {
              const expDoc = expSnap.docs[0];
              const expData = expDoc.data() || {};
              const gestorUid = expData.uid || expDoc.id;
              baseExp = db.collection('uid').doc(gestorUid).collection('uid').doc(usuarioLogado.uid);
            }
          }

          const progressContainer = document.getElementById('progressContainer');
          const progressBar = document.getElementById('faturamentoProgressBar');
          const progressText = document.getElementById('faturamentoProgressText');
          const massaModal = document.getElementById('massaFaturamentoModal');
          const massaStatus = document.getElementById('massaFaturamentoStatus');
          const massaCloseBtn = document.getElementById('massaModalClose');
          const massaProgressBar = document.getElementById('massaProgressBar');
          const massaProgressText = document.getElementById('massaProgressText');

          const atualizarStatusModal = (mensagem, classe) => {
            if (!massaStatus) return;
            massaStatus.textContent = mensagem;
            massaStatus.classList.remove('text-blue-600', 'text-green-600', 'text-red-600');
            if (classe) massaStatus.classList.add(classe);
          };

          const progressTargets = [
            {
              bar: progressBar,
              text: progressText,
              onShow: () => {
                if (progressContainer) progressContainer.classList.remove('hidden');
              }
            },
            {
              bar: massaProgressBar,
              text: massaProgressText,
              onShow: () => {
                if (massaModal) massaModal.style.display = 'block';
                atualizarStatusModal('Processando planilha. Não feche esta janela até finalizar.', 'text-blue-600');
                if (massaCloseBtn) {
                  massaCloseBtn.classList.add('hidden');
                  massaCloseBtn.disabled = false;
                }
              }
            }
          ];

          progressTargets.forEach(({ bar, text, onShow }) => {
            if (typeof onShow === 'function') onShow();
            if (bar) bar.style.width = '0%';
            if (text) text.textContent = '0%';
          });

          const setProgress = (pct) => {
            progressTargets.forEach(({ bar, text }) => {
              if (bar) bar.style.width = pct + '%';
              if (text) text.textContent = pct + '%';
            });
          };

          const totalRows = rows.length;
          let processedRows = 0;
          const updateProgress = async () => {
            const pct = totalRows ? Math.round((processedRows / totalRows) * 100) : 0;
            setProgress(pct);
            if (processedRows % 50 === 0) await new Promise(r => setTimeout(r, 0));
          };

          const grupos = {};
          const rowsSemData = [];
          const extrairDataPagamento = (valor) => {
            if (valor === undefined || valor === null) return null;
            const texto = String(valor).trim();
            if (!texto) return null;
            const match = texto.match(/(\d{4}-\d{2}-\d{2})/);
            return match ? match[1] : null;
          };

          for (const row of rows) {
            const headers = Object.keys(row);
            const dataPagamento = extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('hora do pagamento'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data do pedido'))
                .map(h => row[h])[0]
            ) || extrairDataPagamento(
              headers
                .filter(h => h.toLowerCase().includes('data de criação'))
                .map(h => row[h])[0]
            );

            if (!dataPagamento) {
              rowsSemData.push(row);
              processedRows++;
              await updateProgress();
              continue;
            }

            if (!grupos[dataPagamento]) {
              grupos[dataPagamento] = {
                rows: [],
                bruto: 0,
                taxas: 0,
                qtdVendas: 0,
                skusVendidos: {},
                pedidosErrados: []
              };
            }

            const grupo = grupos[dataPagamento];
            grupo.rows.push({ row, headers });

            const status = (row['Status do pedido'] || '').toLowerCase();
            const ativo = !(status.includes('cancelado') || status.includes('não pago'));
            if (ativo) {
              const subtotal = parseFloat(row['Subtotal do produto']) || 0;
              const reembolso = parseFloat(row['Reembolso Shopee']) || 0;
              const cupom = parseFloat(row['Cupom do vendedor']) || 0;
              const comissao = parseFloat(row['Taxa de comissão']) || 0;
              const servico = parseFloat(row['Taxa de serviço']) || 0;
              const liquidoLinha = subtotal + reembolso - cupom - comissao - servico;

              grupo.bruto += subtotal + reembolso;
              grupo.taxas += cupom + comissao + servico;
              grupo.qtdVendas++;

              const headerSku = headers.find(h => h.trim() === 'Número de referência SKU')
                || headers.find(h => h.trim() === 'Nº de referência do SKU principal');
              const sku = headerSku ? row[headerSku] : null;

              if (sku) {
                if (!grupo.skusVendidos[sku]) grupo.skusVendidos[sku] = { total: 0, valorLiquido: 0 };
                grupo.skusVendidos[sku].total++;
                grupo.skusVendidos[sku].valorLiquido += liquidoLinha;

                const headerPedido = headers.find(h => h.toLowerCase().includes('pedido') && h.toLowerCase().includes('id'));
                const pedidoId = headerPedido ? row[headerPedido] : null;
                const headerQtd = headers.find(h => h.toLowerCase().includes('quantidade'));
                const quantidade = headerQtd ? parseInt(row[headerQtd]) || 0 : 0;
                const metaUnit = metas[sku]?.valor || 0;
                const metaEsperada = metaUnit * (quantidade || 1);
                const sobraReal = liquidoLinha;

                if (metaEsperada && sobraReal < metaEsperada * 0.9) {
                  grupo.pedidosErrados.push({
                    dia: dataPagamento,
                    loja: loja,
                    pedido: pedidoId,
                    sku: sku,
                    quantidade: quantidade,
                    subtotal: subtotal,
                    sobraReal: sobraReal,
                    totalLiquido: sobraReal,
                    sobraEsperada: metaEsperada,
                    uid: usuarioLogado.uid,
                    critico: true
                  });
                }
              }
            }

            processedRows++;
            await updateProgress();
          }

          if (!Object.keys(grupos).length) {
            mostrarErro('Nenhum registro com data de pagamento foi encontrado.');
            atualizarStatusModal('Nenhum registro com data de pagamento foi encontrado.', 'text-red-600');
            if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');
            return;
          }

          const { encryptString, decryptString } = await import('./crypto.js');
          const pass = getPassphrase() || usuarioLogado.uid;
          const pedidosRef = db.collection('uid').doc(usuarioLogado.uid).collection('pedidosreais');
          const resultados = [];

          for (const [dataReferencia, grupo] of Object.entries(grupos)) {
            const ref = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .collection('lojas')
              .doc(loja);
            const doc = await ref.get();
            let operacao = 'salvar';
            let dadosAnteriores = null;

            if (doc.exists) {
              const { isConfirmed: substituir, isDenied: somar } = await Swal.fire({
                title: 'Registro existente',
                text: `Já existe um registro para ${loja} em ${dataReferencia}. O que deseja fazer?`,
                showDenyButton: true,
                showCancelButton: true,
                confirmButtonText: 'Substituir',
                denyButtonText: 'Somar',
                cancelButtonText: 'Pular'
              });
              if (!substituir && !somar) {
                resultados.push({ data: dataReferencia, loja, status: 'ignorado' });
                continue;
              }
              operacao = somar ? 'somar' : 'substituir';
              const docData = doc.data();
              if (docData?.encrypted) {
                try {
                  dadosAnteriores = JSON.parse(await decryptString(docData.encrypted, pass));
                } catch (e) {
                  console.error('Erro ao descriptografar faturamento existente', e);
                }
              } else {
                dadosAnteriores = docData;
              }
            }

            if (operacao === 'somar' && dadosAnteriores) {
              grupo.bruto += dadosAnteriores.valorBruto || 0;
              grupo.taxas += dadosAnteriores.taxasPlataforma || 0;
              grupo.qtdVendas += dadosAnteriores.qtdVendas || 0;
            }

            if (grupo.pedidosErrados.length) {
              const errRef = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('pedidosErrados');
              await Promise.all(grupo.pedidosErrados.map(p => errRef.add(p)));
            }

            const liquido = grupo.bruto - grupo.taxas;

            const refSku = db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('skusVendidos')
              .doc(dataReferencia);
            await refSku.set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp) {
              await baseResp
                .collection('skusVendidos')
                .doc(dataReferencia)
                .set({ data: dataReferencia, uid: usuarioLogado.uid }, { merge: true });
            }

            for (const [sku, dadosSku] of Object.entries(grupo.skusVendidos)) {
              const skuId = makeSkuDocId(sku);
              const legacySkuId = makeLegacySkuDocId(sku);
              const listaCollection = db
                .collection('uid')
                .doc(usuarioLogado.uid)
                .collection('skusVendidos')
                .doc(dataReferencia)
                .collection('lista');
              const docRef = listaCollection.doc(skuId);
              const docSnap = await docRef.get();

              let totalFinal = dadosSku.total;
              let valorLiquidoFinal = dadosSku.valorLiquido;
              if (docSnap.exists) {
                const dadosAnterioresSku = docSnap.data();
                totalFinal += dadosAnterioresSku.total || 0;
                valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
              } else if (legacySkuId !== skuId) {
                const legacyDocRef = listaCollection.doc(legacySkuId);
                const legacySnap = await legacyDocRef.get();
                if (legacySnap.exists) {
                  const dadosAnterioresSku = legacySnap.data();
                  totalFinal += dadosAnterioresSku.total || 0;
                  valorLiquidoFinal += dadosAnterioresSku.valorLiquido || 0;
                  try {
                    await legacyDocRef.delete();
                  } catch (err) {
                    console.warn('Não foi possível remover SKU legado', legacySkuId, err);
                  }
                }
              }

              await docRef.set({
                sku: sku,
                total: totalFinal,
                valorLiquido: valorLiquidoFinal,
                data: dataReferencia,
                loja: loja,
                uid: usuarioLogado.uid
              });

              if (legacySkuId !== skuId) {
                listaCollection.doc(legacySkuId).delete().catch(() => {});
              }

              if (baseResp && respEmail) {
                const skuPayload = {
                  sku: sku,
                  total: totalFinal,
                  valorLiquido: valorLiquidoFinal,
                  data: dataReferencia,
                  loja: loja,
                  uid: usuarioLogado.uid
                };
                const encSku = await encryptString(JSON.stringify(skuPayload), respEmail);
                const baseRespLista = baseResp
                  .collection('skusVendidos')
                  .doc(dataReferencia)
                  .collection('lista');
                await baseRespLista
                  .doc(skuId)
                  .set({ encrypted: encSku, uid: usuarioLogado.uid });
                if (legacySkuId !== skuId) {
                  baseRespLista.doc(legacySkuId).delete().catch(() => {});
                }
              }
            }

            for (const { row, headers } of grupo.rows) {
              const headersLower = headers.map(h => h.toLowerCase());
              const headerPedidoId = headersLower.find((h) => h.includes('pedido') && h.includes('id'));
              const pedidoHeaderOriginal = headerPedidoId ? headers[headersLower.indexOf(headerPedidoId)] : null;
              const pedidoId = pedidoHeaderOriginal ? row[pedidoHeaderOriginal] : null;
              if (!pedidoId) continue;

              const headerPagamento = headersLower.find(h => h.includes('hora do pagamento'));
              const pagamentoOriginal = headerPagamento ? headers[headersLower.indexOf(headerPagamento)] : null;
              const horaPagamento = pagamentoOriginal ? row[pagamentoOriginal] : null;

              const headerCancelar = headersLower.find(h => h.includes('cancelar motivo'));
              const cancelarOriginal = headerCancelar ? headers[headersLower.indexOf(headerCancelar)] : null;
              const cancelarMotivoBruto = cancelarOriginal ? row[cancelarOriginal] : null;
              const cancelarMotivo = cancelarMotivoBruto ? String(cancelarMotivoBruto).trim() : '';

              const headerSkuPrimarioIdx = headersLower.findIndex(h =>
                h.includes('número de referência sku') || h.includes('numero de referencia sku')
              );
              const headerSkuPrincipalIdx = headersLower.findIndex(h =>
                h.includes('nº de referência do sku principal') ||
                h.includes('n° de referência do sku principal') ||
                h.includes('no de referência do sku principal') ||
                h.includes('n o de referência do sku principal')
              );
              const headerSkuPrimario = headerSkuPrimarioIdx >= 0 ? headers[headerSkuPrimarioIdx] : null;
              const headerSkuPrincipal = headerSkuPrincipalIdx >= 0 ? headers[headerSkuPrincipalIdx] : null;
              let numeroReferenciaSku = headerSkuPrimario ? row[headerSkuPrimario] : null;
              numeroReferenciaSku = numeroReferenciaSku !== null && numeroReferenciaSku !== undefined
                ? String(numeroReferenciaSku).trim()
                : '';
              const skuPrincipalValorBruto = headerSkuPrincipal ? row[headerSkuPrincipal] : null;
              const skuPrincipalValor = skuPrincipalValorBruto !== null && skuPrincipalValorBruto !== undefined
                ? String(skuPrincipalValorBruto).trim()
                : '';
              if (!numeroReferenciaSku && skuPrincipalValor) {
                numeroReferenciaSku = skuPrincipalValor;
              }

              const headerQtd = headersLower.find(h => h.includes('quantidade'));
              const qtdOriginal = headerQtd ? headers[headersLower.indexOf(headerQtd)] : null;
              const quantidade = qtdOriginal ? parseFloat(row[qtdOriginal]) || 0 : 0;

              const subtotalPedido = parseFloat(row['Subtotal do produto']) || 0;
              const reembolsoPedido = parseFloat(row['Reembolso Shopee']) || 0;
              const cupomPedido = parseFloat(row['Cupom do vendedor']) || 0;
              const comissaoPedido = parseFloat(row['Taxa de comissão']) || 0;
              const servicoPedido = parseFloat(row['Taxa de serviço']) || 0;
              const taxasPedido = cupomPedido + comissaoPedido + servicoPedido;
              const liquidoPedido = subtotalPedido + reembolsoPedido - taxasPedido;

              const headerPrevEnvio = headersLower.find(h => h.includes('data prevista') && h.includes('envio'));
              const prevEnvioOriginal = headerPrevEnvio ? headers[headersLower.indexOf(headerPrevEnvio)] : null;
              let dataPrevistaEnvio = prevEnvioOriginal ? row[prevEnvioOriginal] : null;
              dataPrevistaEnvio = normalizeDate(dataPrevistaEnvio);

              const headerRastreamento = headersLower.find(h => h.includes('rastreamento'));
              const rastreamentoOriginal = headerRastreamento ? headers[headersLower.indexOf(headerRastreamento)] : null;
              const numeroRastreamento = rastreamentoOriginal ? String(row[rastreamentoOriginal]).trim() : '';

              const statusPedido = row['Status do pedido'] || '';

              const pedidoPayload = {
                pedidoId,
                status: statusPedido,
                loja,
                data: dataReferencia,
                horaPagamento,
                quantidade,
                subtotal: subtotalPedido,
                cupom: cupomPedido,
                reembolso: reembolsoPedido,
                comissao: comissaoPedido,
                servico: servicoPedido,
                taxas: taxasPedido,
                liquido: liquidoPedido
              };
              if (numeroReferenciaSku) pedidoPayload.sku = numeroReferenciaSku;
              if (cancelarMotivo) pedidoPayload.cancelarMotivo = cancelarMotivo;

              const dadosPlanilhaPedido = {
                'Status do pedido': statusPedido,
                'Cancelar Motivo': cancelarMotivo || null,
                'Número de referência SKU': numeroReferenciaSku || null,
                Quantidade: quantidade,
                'Subtotal do produto': subtotalPedido,
                'Cupom do vendedor': cupomPedido,
                'Reembolso Shopee': reembolsoPedido,
                'Taxa de comissão': comissaoPedido,
                'Taxa de serviço': servicoPedido
              };
              if (headerSkuPrincipal) {
                dadosPlanilhaPedido['Nº de referência do SKU principal'] = skuPrincipalValor || null;
              }
              pedidoPayload.dadosPlanilha = dadosPlanilhaPedido;
              if (dataPrevistaEnvio) pedidoPayload.dataPrevistaEnvio = dataPrevistaEnvio;
              if (numeroRastreamento) {
                pedidoPayload.numeroRastreamento = numeroRastreamento;
                pedidoPayload.etiquetaImpressa = true;
              }

              const pedidoDocRef = pedidosRef
                .doc(dataReferencia)
                .collection('lista')
                .doc(pedidoId);
              const pedidoDoc = await pedidoDocRef.get();
              let needsUpdate = true;
              if (pedidoDoc.exists) {
                try {
                  const atual = JSON.parse(
                    await decryptString(pedidoDoc.data().encrypted, pass)
                  );
                  if (JSON.stringify(atual) === JSON.stringify(pedidoPayload)) {
                    needsUpdate = false;
                  }
                } catch (e) {
                  console.error('Erro ao comparar pedido existente', e);
                }
              }

              if (needsUpdate) {
                const encPedido = await encryptString(JSON.stringify(pedidoPayload), pass);
                await pedidoDocRef.set({ encrypted: encPedido, uid: usuarioLogado.uid });
                if (baseResp && respEmail) {
                  const encPedidoResp = await encryptString(JSON.stringify(pedidoPayload), respEmail);
                  await baseResp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoResp, uid: usuarioLogado.uid });
                }
                if (baseExp && gestorEmail) {
                  const encPedidoExp = await encryptString(JSON.stringify(pedidoPayload), gestorEmail);
                  await baseExp
                    .collection('pedidosreais')
                    .doc(dataReferencia)
                    .collection('lista')
                    .doc(pedidoId)
                    .set({ encrypted: encPedidoExp, uid: usuarioLogado.uid });
                }
              }
            }

            const lojaPayload = {
              valorBruto: grupo.bruto,
              taxasPlataforma: grupo.taxas,
              valorLiquido: liquido,
              qtdVendas: grupo.qtdVendas,
              loja: loja,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid
            };
            const encLoja = await encryptString(JSON.stringify(lojaPayload), pass);
            await ref.set({ encrypted: encLoja, uid: usuarioLogado.uid });
            if (baseResp && respEmail) {
              const encLojaResp = await encryptString(JSON.stringify(lojaPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .collection('lojas')
                .doc(loja)
                .set({ encrypted: encLojaResp, uid: usuarioLogado.uid });
            }

            const resumoPayload = {
              valorBruto: grupo.bruto,
              valorLiquido: liquido,
              taxasPlataforma: grupo.taxas,
              vendas: grupo.qtdVendas,
              atualizadoEm: new Date(),
              uid: usuarioLogado.uid
            };
            const encResumo = await encryptString(JSON.stringify(resumoPayload), pass);
            await db
              .collection('uid')
              .doc(usuarioLogado.uid)
              .collection('faturamento')
              .doc(dataReferencia)
              .set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
            if (baseResp && respEmail) {
              const encResumoResp = await encryptString(JSON.stringify(resumoPayload), respEmail);
              await baseResp
                .collection('faturamento')
                .doc(dataReferencia)
                .set({ encrypted: encResumoResp, uid: usuarioLogado.uid }, { merge: true });
            }

            resultados.push({
              data: dataReferencia,
              loja,
              status: 'ok',
              bruto: grupo.bruto,
              taxas: grupo.taxas,
              liquido,
              qtd: grupo.qtdVendas
            });
            await notificarResponsavelFinanceiro(dataReferencia, loja, grupo.bruto, liquido, grupo.qtdVendas);
          }

          setProgress(100);
          atualizarStatusModal('Processamento concluído com sucesso!', 'text-green-600');
          if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');

          const sucesso = resultados.filter(r => r.status === 'ok');
          const ignorados = resultados.filter(r => r.status === 'ignorado');

          let html = '';
          if (sucesso.length) {
            html += '<div class="alert alert-success">';
            html += '<i class="fas fa-check-circle"></i> Faturamentos processados:';
            html += '<ul class="mt-2 space-y-1">';
            html += sucesso
              .map(r => `<li><strong>${r.data}</strong> - ${r.loja}: Bruto R$ ${r.bruto.toFixed(2)}, Taxas R$ ${r.taxas.toFixed(2)}, Líquido R$ ${r.liquido.toFixed(2)}, Vendas ${r.qtd}</li>`)
              .join('');
            html += '</ul></div>';
          }
          if (ignorados.length || rowsSemData.length) {
            html += '<div class="alert alert-warning mt-4">';
            html += '<i class="fas fa-exclamation-triangle"></i> Atenção:';
            if (ignorados.length) {
              html += `<br>${ignorados.length} dia(s) foram ignorados por opção do usuário.`;
            }
            if (rowsSemData.length) {
              html += `<br>${rowsSemData.length} registro(s) sem data de pagamento foram desconsiderados.`;
            }
            html += '</div>';
          }

          document.getElementById('resultadoFaturamento').innerHTML = html || '<div class="alert alert-info"><i class="fas fa-info-circle"></i> Nenhum faturamento foi processado.</div>';
          input.value = '';
        } catch (err) {
          mostrarErro('Erro ao importar: ' + err.message);
          console.error(err);
          atualizarStatusModal('Ocorreu um erro durante o processamento.', 'text-red-600');
          if (massaCloseBtn) massaCloseBtn.classList.remove('hidden');
        }
      };

      reader.readAsArrayBuffer(file);
    };

    // =============================================
    // FUNÇÕES DE EXPORTAÇÃO
    // =============================================

    function toggleExportMenu() {
      const menu = document.getElementById('exportMenu');
      if (menu) {
        menu.classList.toggle('show');
      }
    }

    document.addEventListener('click', function(e) {
      const menu = document.getElementById('exportMenu');
      const btn = document.getElementById('btnExportar');
      if (!menu || !btn) return;
      if (!btn.contains(e.target) && !menu.contains(e.target)) {
        menu.classList.remove('show');
      }
    });
    
    function exportarCSV() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }
      
      try {
        // Cabeçalhos
        let csv = 'ID do Pedido;SKU;Subtotal;Reembolso;Cupom;Comissão;Serviço;Sobra;Meta;% vs Meta;Status\n';
        
        // Dados
        pedidosProcessados.forEach(pedido => {
          const status = pedido.meta ? 
            (pedido.percentual <= -10 ? 'Crítico' : 
             pedido.percentual <= -5 ? 'Atenção' : 
             pedido.percentual >= 5 ? 'Bom' : 'Normal') : 'Sem meta';
          
          csv += `"${pedido.id}";"${pedido.sku}";"${pedido.subtotal.toFixed(2)}";"${pedido.reembolso.toFixed(2)}";"${pedido.cupom.toFixed(2)}";"${pedido.comissao.toFixed(2)}";"${pedido.servico.toFixed(2)}";"${pedido.sobra.toFixed(2)}";"${pedido.meta.toFixed(2)}";"${pedido.percentual.toFixed(2)}";"${status}"\n`;
        });
        
        const blob = new Blob(["\uFEFF" + csv], { type: 'text/csv;charset=utf-8;' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.csv`);
        
        mostrarSucesso('Arquivo CSV exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar CSV: ${error.message}`);
        console.error("Erro ao exportar CSV:", error);
      }
    }
    async function carregarRegistrosFaturamento(idContainer = "listaFaturamento", idFiltroMes = "filtroMes") {
 let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const container = document.getElementById(idContainer);
      container.innerHTML = "";

      const filtroMes = document.getElementById(idFiltroMes)?.value;

      for (const docData of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoData, mesData] = docData.id.split("-");
          if (anoFiltro !== anoData || mesFiltro !== mesData) continue;
        }

const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
                const { decryptString } = await import('./crypto.js');
        let bruto = 0, liquido = 0, qtd = 0;

        for (const sub of subSnap.docs) {
          const dataSub = sub.data();
          let d = dataSub;
          if (dataSub.encrypted) {
            try {
              const txt = await decryptString(dataSub.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          qtd += d.qtdVendas || 0;
        }

        const card = document.createElement("div");
        card.className = "bg-white rounded-2xl shadow-lg p-4 border border-gray-200 hover:shadow-xl transition";

        card.innerHTML = `
          <div class="text-sm text-gray-500 mb-2 flex items-center gap-2">
            <i class="fas fa-calendar-alt text-blue-600"></i>
            <span class="font-semibold">${docData.id}</span>
          </div>

          <div class="text-2xl font-bold text-blue-800 mb-1">💰 Bruto: R$ ${bruto.toLocaleString('pt-BR')}</div>
          <div class="text-xl font-semibold text-green-600 mb-1">🔻 Líquido: R$ ${liquido.toLocaleString('pt-BR')}</div>
          <div class="text-base text-gray-600 mb-4">🛒 Vendas: ${qtd}</div>

          <div class="flex justify-between items-center mt-4">
            <button onclick='mostrarDetalhesFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-search"></i> Ver Detalhes
            </button>
            <button onclick='excluirFaturamento("${docData.id}")'
              class="btn btn-outline">
              <i class="fas fa-trash-alt"></i> Excluir
            </button>
          </div>

          <div id="detalhes-${docData.id}" class="mt-3 text-sm text-gray-700" style="display:none;"></div>
        `;

        container.appendChild(card);
      }
    }

    async function mostrarDetalhesFaturamento(dataRef) {
      const detalhesEl = document.getElementById("detalhes-" + dataRef);
      if (detalhesEl.style.display === "block") {
        detalhesEl.style.display = "none";
        return;
      }

      detalhesEl.innerHTML = `<div class="text-sm text-gray-500">🔄 Carregando...</div>`;
      detalhesEl.style.display = "block";

      const { decryptString } = await import('./crypto.js');
 let refs = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('faturamento')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataRef)
          .get();
        q.forEach(doc => {
          refs.push(db.collection(`uid/${doc.ref.parent.parent.id}/faturamento/${dataRef}/lojas`));
        });
      } else {
        refs.push(db.collection(`uid/${usuarioLogado.uid}/faturamento/${dataRef}/lojas`));
      }
      let html = "";
 for (const r of refs) {
        const snap = await r.get();
        for (const doc of snap.docs) {
          let d = doc.data();
        if (d.encrypted) {
          try {
            const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
            d = JSON.parse(txt);
          } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
        }
        const loja = d.loja || "Desconhecida";
        const bruto = d.valorBruto?.toLocaleString("pt-BR") || "0,00";
        const liquido = d.valorLiquido?.toLocaleString("pt-BR") || "0,00";
        const vendas = d.qtdVendas || 0;

        html += `
          <div class="mt-1 text-sm text-gray-800 border-t pt-1">
            <strong>${loja}</strong>: Bruto R$ ${bruto} | Líquido R$ ${liquido} | Vendas: ${vendas}
          </div>
        `;
       }
      }

      detalhesEl.innerHTML = html;
    }

    async function excluirFaturamento(data) {
        if (!confirm(`Tem certeza que deseja excluir o faturamento do dia ${data}?`)) return;
        if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
          const snap = await db.collectionGroup('faturamento')
            .where(firebase.firestore.FieldPath.documentId(), '==', data)
            .get();
          for (const doc of snap.docs) {
            await db.collection(`uid/${doc.ref.parent.parent.id}/faturamento`).doc(data).delete();
          }
        } else {
          await db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').doc(data).delete();
        }
        mostrarSucesso("Registro excluído com sucesso.");
        carregarRegistrosFaturamento();
      }

    function exportarJSON() {
      if (pedidosProcessados.length === 0) {
        mostrarErro('Nenhum dado disponível para exportar. Processe um arquivo primeiro.');
        return;
      }
      
      try {
        const data = {
          geradoEm: new Date().toISOString(),
          pedidos: pedidosProcessados,
          resumo: {
            totalSobra: pedidosProcessados.reduce((sum, p) => sum + p.sobra, 0),
            totalMeta: pedidosProcessados.reduce((sum, p) => sum + (p.meta || 0), 0)
          }
        };
        
        const json = JSON.stringify(data, null, 2);
        const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
        saveAs(blob, `relatorio_sobras_${new Date().toISOString().slice(0,10)}.json`);
        
        mostrarSucesso('Arquivo JSON exportado com sucesso!');
      } catch (error) {
        mostrarErro(`Erro ao exportar JSON: ${error.message}`);
        console.error("Erro ao exportar JSON:", error);
      }
    }
    window.analisarSobrasComIA = async function analisarSobrasComIA() {
      try {
        const linhas = document.querySelectorAll("#tabelaSobras tbody tr");
        let dados = [];

        linhas.forEach(linha => {
          const colunas = linha.querySelectorAll("td");
          if (colunas.length >= 5) {
            dados.push({
              sku: colunas[0].innerText.trim(),
              nome: colunas[1].innerText.trim(),
              vendido: parseInt(colunas[2].innerText) || 0,
              sobra: parseInt(colunas[3].innerText) || 0,
              data: colunas[4].innerText.trim()
            });
          }
        });

        const prompt = `
    Você é um especialista em controle de estoque e sobras da Shopee.

    Receberá uma lista com SKUs, nomes, vendidos e sobras.

    Analise:
    🔹 1. Valide se a sobra registrada faz sentido
    🔹 2. Detecte padrões incomuns (ex: sobra alta sem venda)
    🔹 3. Gere resumo por SKU com observações
    🔹 4. Sugira ações (ex: revisar, repor, ignorar)

    Dados:
    ${JSON.stringify(dados, null, 2)}
    `;

        const resposta = await consultarDeepSeek(prompt);
        document.getElementById("resultadoIA").innerText = resposta;
      } catch (erro) {
        console.error("Erro IA sobras:", erro);
        document.getElementById("resultadoIA").innerText = "Erro ao analisar sobras com IA.";
      }
   };
    async function analisarSobrasIA() {
      const prompt = `
    Sou um sistema de controle de sobras da Shopee. Com base nos dados abaixo, analise se os SKUs estão performando bem, identifique padrões incomuns e sugira ações como promoções, reposição ou atenção especial.

    Dados:
    ${document.getElementById("dadosSobrasIA").value}

    Gere um resumo inteligente com insights práticos.
    `;

      document.getElementById("resultadoIA").innerHTML = "⌛ Analisando com IA...";
      
      try {
        const resposta = await fetch(API_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ pergunta: prompt })
        });

        const data = await resposta.json();
        const output = data.choices?.[0]?.message?.content || data.resposta || "⚠️ Resposta não recebida.";

        document.getElementById("resultadoIA").innerHTML = output;
      } catch (error) {
        document.getElementById("resultadoIA").innerHTML = "❌ Erro ao consultar IA: " + error.message;
        console.error("Erro IA:", error);
        updateConnectionStatus(false);
      }
    }
    function renderProdutosVendidos() {
      const tabela = document.getElementById('produtosVendidosTabela');
      if (!tabela) return;

      const formatCurrency = (valor) =>
        Number(valor || 0).toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL',
        });

      const filtroSku = (document
        .getElementById('filtroSkuProdutosVendidos')?.value || '')
        .trim()
        .toLowerCase();
      const statusEl = document.getElementById('produtosVendidosStatus');
      const totalEl = document.getElementById('produtosVendidosTotalUnidades');
      const totalLiquidoEl = document.getElementById(
        'produtosVendidosTotalLiquido',
      );

      const dadosFiltrados = produtosVendidosResumo.filter((item) => {
        if (!filtroSku) return true;
        return item.todosSkus.some((sku) =>
          sku.toLowerCase().includes(filtroSku),
        );
      });

      if (!dadosFiltrados.length) {
        tabela.innerHTML =
          '<tr><td colspan="4" class="py-6 text-center text-gray-500">Nenhum SKU encontrado.</td></tr>';
        if (statusEl) {
          if (produtosVendidosResumo.length && filtroSku) {
            statusEl.textContent = 'Nenhum SKU corresponde ao filtro aplicado.';
          } else if (produtosVendidosResumo.length) {
            statusEl.textContent =
              'Nenhum dado encontrado para o período selecionado.';
          } else {
            statusEl.textContent = 'Nenhum dado encontrado.';
          }
        }
        if (totalEl) totalEl.textContent = '0';
        if (totalLiquidoEl) totalLiquidoEl.textContent = formatCurrency(0);
        return;
      }

      const ordenados = [...dadosFiltrados].sort((a, b) => b.total - a.total);
      const linhas = ordenados
        .map((item) => {
          const totalFormatado = item.total.toLocaleString('pt-BR');
          const valorLiquidoFormatado = formatCurrency(item.valorLiquido);
          const vendidosChips = item.vendidosPorSku
            .map(
              ([sku, qtd]) =>
                `<span class="inline-flex items-center gap-1 rounded-full bg-indigo-50 px-2 py-1 text-xs font-medium text-indigo-700"><span>${escapeHtml(
                  sku,
                )}</span><span class="font-semibold text-gray-600">${qtd.toLocaleString(
                  'pt-BR',
                )}</span></span>`,
            )
            .join('');
          const vendidosHtml = vendidosChips
            ? `<div class="mt-2 flex flex-wrap gap-2">${vendidosChips}</div>`
            : '';
          const principaisDetalhes = Array.isArray(
            item.principaisVinculadosDetalhes,
          )
            ? item.principaisVinculadosDetalhes
            : [];
          let extrasHtml = '';
          if (principaisDetalhes.length) {
            const linhasPrincipais = principaisDetalhes
              .map(({ sku, quantidade }) => {
                const quantidadeFormatada = Number(quantidade || 0).toLocaleString(
                  'pt-BR',
                );
                return `<div class="flex items-center justify-between gap-2 rounded-lg bg-indigo-50 px-2 py-1 text-[11px] text-indigo-700"><span class="font-medium">${escapeHtml(
                  sku,
                )}</span><span class="font-semibold text-gray-600">${quantidadeFormatada}</span></div>`;
              })
              .join('');
            extrasHtml = `
              <div class="mt-2 text-xs text-gray-500">
                <div class="font-medium text-gray-600">Principais vinculados</div>
                <div class="mt-1 space-y-1">${linhasPrincipais}</div>
              </div>
            `.trim();
          } else {
            const extrasLista = item.grupoCompleto
              .filter(
                (skuExtra) =>
                  !item.vendidosPorSku.some(
                    ([skuVend]) =>
                      skuVend.toLowerCase() === skuExtra.toLowerCase(),
                  ),
              )
              .map((skuExtra) => escapeHtml(skuExtra));
            extrasHtml = extrasLista.length
              ? `<div class="mt-1 text-xs text-gray-400">Associados: ${extrasLista.join(
                  ', ',
                )}</div>`
              : '';
          }
          const usuariosTexto = item.usuarios
            .map(([nome, qtd]) =>
              `${escapeHtml(nome)} (${qtd.toLocaleString('pt-BR')})`,
            )
            .join('<br>');
          return `
            <tr class="divide-x divide-gray-100">
              <td class="py-3 px-4 font-semibold text-gray-700">
                <div>${escapeHtml(item.sku)}</div>
                ${vendidosHtml}
                ${extrasHtml}
              </td>
              <td class="py-3 px-4 text-center font-medium text-gray-800">${totalFormatado}</td>
              <td class="py-3 px-4 text-right font-medium text-gray-800">${valorLiquidoFormatado}</td>
              <td class="py-3 px-4 text-sm text-gray-600 leading-5">${
                usuariosTexto || '<span class="text-gray-400">-</span>'
              }</td>
            </tr>`;
        })
        .join('');

      tabela.innerHTML = linhas;

      if (statusEl) {
        statusEl.textContent = `${ordenados.length} SKU${
          ordenados.length > 1 ? 's' : ''
        } encontrados.`;
      }
      if (totalEl) {
        const total = ordenados.reduce((acc, item) => acc + item.total, 0);
        totalEl.textContent = total.toLocaleString('pt-BR');
      }
      if (totalLiquidoEl) {
        const totalLiquido = ordenados.reduce(
          (acc, item) => acc + Number(item.valorLiquido || 0),
          0,
        );
        totalLiquidoEl.textContent = formatCurrency(totalLiquido);
      }
    }

    async function carregarProdutosVendidos() {
      const tabela = document.getElementById('produtosVendidosTabela');
      const statusEl = document.getElementById('produtosVendidosStatus');
      const totalEl = document.getElementById('produtosVendidosTotalUnidades');
      const totalLiquidoEl = document.getElementById(
        'produtosVendidosTotalLiquido',
      );
      produtosVendidosResumo = [];
      produtosVendidosCarregado = false;

      if (tabela) {
        tabela.innerHTML =
          '<tr><td colspan="4" class="py-6 text-center text-gray-500">Carregando...</td></tr>';
      }
      if (statusEl) {
        statusEl.textContent = 'Carregando dados de produtos vendidos...';
      }
      if (totalEl) totalEl.textContent = '0';
      if (totalLiquidoEl)
        totalLiquidoEl.textContent = Number(0).toLocaleString('pt-BR', {
          style: 'currency',
          currency: 'BRL',
        });

      const inicioInput = document.getElementById(
        'filtroProdutosVendidosInicio',
      );
      const fimInput = document.getElementById('filtroProdutosVendidosFim');
      const hoje = new Date();
      const ano = hoje.getFullYear();
      const mes = String(hoje.getMonth() + 1).padStart(2, '0');
      const dia = String(hoje.getDate()).padStart(2, '0');
      const primeiroDiaMes = `${ano}-${mes}-01`;
      const hojeIso = `${ano}-${mes}-${dia}`;

      if (inicioInput && !inicioInput.value) inicioInput.value = primeiroDiaMes;
      if (fimInput && !fimInput.value) fimInput.value = hojeIso;

      const dataInicio = inicioInput?.value || null;
      const dataFim = fimInput?.value || null;
      if (dataInicio && dataFim && dataInicio > dataFim) {
        if (statusEl)
          statusEl.textContent =
            'Período inválido: a data inicial é maior que a final.';
        if (tabela)
          tabela.innerHTML =
            '<tr><td colspan="4" class="py-6 text-center text-red-500">Ajuste o período selecionado.</td></tr>';
        return;
      }

      try {
        const responsavelEmail = (usuarioLogado.email || '').trim();
        if (!responsavelEmail) {
          if (statusEl)
            statusEl.textContent =
              'Não foi possível identificar o responsável financeiro.';
          if (tabela)
            tabela.innerHTML =
              '<tr><td colspan="4" class="py-6 text-center text-gray-500">Usuário não autenticado.</td></tr>';
          return;
        }

        const usuariosMap = new Map();
        const usuariosSnap = await db
          .collection('usuarios')
          .where('responsavelFinanceiroEmail', '==', responsavelEmail)
          .get();
        usuariosSnap.forEach((doc) => {
          const dados = doc.data() || {};
          usuariosMap.set(doc.id, {
            nome: dados.nome || dados.email || doc.id,
            email: dados.email || '',
          });
        });

        const uidSnap = await db
          .collection('uid')
          .where('responsavelFinanceiroEmail', '==', responsavelEmail)
          .get();
        uidSnap.forEach((doc) => {
          if (!usuariosMap.has(doc.id)) {
            const dados = doc.data() || {};
            usuariosMap.set(doc.id, {
              nome: dados.nome || dados.email || doc.id,
              email: dados.email || '',
            });
          }
        });

        if (!usuariosMap.size) {
          if (statusEl)
            statusEl.textContent =
              'Nenhum usuário associado a este responsável financeiro.';
          if (tabela)
            tabela.innerHTML =
              '<tr><td colspan="4" class="py-6 text-center text-gray-500">Sem usuários vinculados.</td></tr>';
          return;
        }

        const normalizarSku = (valor) =>
          String(valor || '')
            .trim()
            .toUpperCase();
        const principalPorSku = new Map();
        const grupoPorPrincipal = new Map();
        const principaisVinculadosPendentes = [];
        const principaisVinculadosPorPrincipal = new Map();
        try {
          const associadosSnap = await db.collection('skuAssociado').get();
          associadosSnap.forEach((doc) => {
            const dados = doc.data() || {};
            const skuPrincipal = String(
              dados.skuPrincipal || doc.id || '',
            ).trim();
            if (!skuPrincipal) return;
            const principalNormalizado = normalizarSku(skuPrincipal);
            principalPorSku.set(principalNormalizado, skuPrincipal);
            const grupoAtual = grupoPorPrincipal.get(skuPrincipal) || new Set();
            const vinculadosAtuais =
              principaisVinculadosPorPrincipal.get(skuPrincipal) || new Set();
            grupoAtual.add(skuPrincipal);
            (dados.associados || []).forEach((skuAssoc) => {
              const associado = String(skuAssoc || '').trim();
              if (!associado) return;
              principalPorSku.set(normalizarSku(associado), skuPrincipal);
              grupoAtual.add(associado);
            });

            (dados.principaisVinculados || []).forEach((skuPrincipalVinc) => {
              const principalVinculado = String(skuPrincipalVinc || '').trim();
              if (!principalVinculado) return;
              grupoAtual.add(principalVinculado);
              vinculadosAtuais.add(principalVinculado);
              principaisVinculadosPendentes.push({
                origem: skuPrincipal,
                vinculado: principalVinculado,
              });
            });

            grupoPorPrincipal.set(skuPrincipal, grupoAtual);
            principaisVinculadosPorPrincipal.set(
              skuPrincipal,
              vinculadosAtuais,
            );
          });
        } catch (assErr) {
          console.error('Erro ao carregar SKUs associados', assErr);
        }

        if (principaisVinculadosPendentes.length) {
          let houveAlteracao = true;
          while (houveAlteracao) {
            houveAlteracao = false;
            for (const relacionamento of principaisVinculadosPendentes) {
              const { origem, vinculado } = relacionamento;
              const grupoOrigem = grupoPorPrincipal.get(origem);
              if (!grupoOrigem) continue;

              const setPrincipaisOrigem =
                principaisVinculadosPorPrincipal.get(origem) || new Set();
              if (!principaisVinculadosPorPrincipal.has(origem)) {
                principaisVinculadosPorPrincipal.set(origem, setPrincipaisOrigem);
              }

              if (!grupoOrigem.has(vinculado)) {
                grupoOrigem.add(vinculado);
                houveAlteracao = true;
              }

              const normalizadoVinculado = normalizarSku(vinculado);
              const principalAtual = principalPorSku.get(normalizadoVinculado);
              if (principalAtual !== origem) {
                principalPorSku.set(normalizadoVinculado, origem);
                houveAlteracao = true;
              }

              const grupoVinculado = grupoPorPrincipal.get(vinculado);
              if (grupoVinculado && grupoVinculado !== grupoOrigem) {
                grupoVinculado.forEach((skuItem) => {
                  const jaPossui = grupoOrigem.has(skuItem);
                  grupoOrigem.add(skuItem);
                  const normalizadoItem = normalizarSku(skuItem);
                  if (principalPorSku.get(normalizadoItem) !== origem) {
                    principalPorSku.set(normalizadoItem, origem);
                  }
                  if (!jaPossui) houveAlteracao = true;
                });
                grupoPorPrincipal.set(vinculado, grupoOrigem);
              } else if (!grupoVinculado) {
                grupoPorPrincipal.set(vinculado, grupoOrigem);
              }

              const setPrincipaisVinculado =
                principaisVinculadosPorPrincipal.get(vinculado);
              if (setPrincipaisVinculado && setPrincipaisVinculado !== setPrincipaisOrigem) {
                const tamanhoAntes = setPrincipaisOrigem.size;
                setPrincipaisVinculado.forEach((sku) =>
                  setPrincipaisOrigem.add(sku),
                );
                if (setPrincipaisOrigem.size !== tamanhoAntes) {
                  houveAlteracao = true;
                }
              }

              if (!setPrincipaisOrigem.has(vinculado)) {
                setPrincipaisOrigem.add(vinculado);
                houveAlteracao = true;
              }

              principaisVinculadosPorPrincipal.set(origem, setPrincipaisOrigem);
              principaisVinculadosPorPrincipal.set(vinculado, setPrincipaisOrigem);
            }
          }
        }

        const agregados = new Map();
        for (const [uid, info] of usuariosMap.entries()) {
          try {
            const vendasSnap = await db
              .collection('uid')
              .doc(uid)
              .collection('skusVendidos')
              .get();

            for (const docDia of vendasSnap.docs) {
              const dataDoc = docDia.id || '';
              if (dataInicio && dataDoc && dataDoc < dataInicio) continue;
              if (dataFim && dataDoc && dataDoc > dataFim) continue;

              const listaSnap = await docDia.ref.collection('lista').get();
              listaSnap.forEach((itemDoc) => {
                const dados = itemDoc.data() || {};
                const skuOriginal = String(
                  dados.sku || itemDoc.id || '',
                ).trim();
                if (!skuOriginal) return;
                const total = Number(dados.total || 0);
                if (!Number.isFinite(total) || total <= 0) return;
                const valorLiquido = Number(
                  dados.valorLiquido ?? dados.liquido ?? 0,
                );
                const valorLiquidoNumero = Number.isFinite(valorLiquido)
                  ? valorLiquido
                  : 0;

                const principal =
                  principalPorSku.get(normalizarSku(skuOriginal)) ||
                  skuOriginal;
                if (!agregados.has(principal)) {
                  agregados.set(principal, {
                    sku: principal,
                    total: 0,
                    valorLiquido: 0,
                    usuarios: new Map(),
                    vendidosPorSku: new Map(),
                    grupoOficial:
                      grupoPorPrincipal.get(principal) ||
                      new Set([principal]),
                    principaisVinculados:
                      principaisVinculadosPorPrincipal.get(principal) ||
                      new Set(),
                    principaisVinculadosQuantidades: new Map(),
                  });
                }

                const registro = agregados.get(principal);
                registro.total += total;
                registro.valorLiquido += valorLiquidoNumero;
                const nomeUsuario = info.nome || info.email || uid;
                registro.usuarios.set(
                  nomeUsuario,
                  (registro.usuarios.get(nomeUsuario) || 0) + total,
                );
                registro.vendidosPorSku.set(
                  skuOriginal,
                  (registro.vendidosPorSku.get(skuOriginal) || 0) + total,
                );

                const principaisDoRegistro =
                  registro.principaisVinculados instanceof Set
                    ? registro.principaisVinculados
                    : new Set(registro.principaisVinculados || []);
                if (principaisDoRegistro.size) {
                  const skuNormalizado = normalizarSku(skuOriginal);
                  let principalEncontrado = null;
                  principaisDoRegistro.forEach((principalVinculado) => {
                    if (principalEncontrado) return;
                    if (
                      normalizarSku(principalVinculado) === skuNormalizado
                    ) {
                      principalEncontrado = principalVinculado;
                    }
                  });
                  if (principalEncontrado) {
                    const mapaQuantidades =
                      registro.principaisVinculadosQuantidades instanceof Map
                        ? registro.principaisVinculadosQuantidades
                        : new Map(
                            registro.principaisVinculadosQuantidades || [],
                          );
                    const acumulado =
                      mapaQuantidades.get(principalEncontrado) || 0;
                    mapaQuantidades.set(principalEncontrado, acumulado + total);
                    registro.principaisVinculadosQuantidades = mapaQuantidades;
                  }
                }
              });
            }
          } catch (loopErr) {
            console.error('Erro ao processar vendas do usuário', uid, loopErr);
          }
        }

        produtosVendidosResumo = Array.from(agregados.values()).map((item) => {
          const vendidosPorSku = Array.from(item.vendidosPorSku.entries()).sort(
            (a, b) => a[0].localeCompare(b[0], 'pt-BR'),
          );
          const grupoCompleto = Array.from(item.grupoOficial.values()).sort((
            a,
            b,
          ) => a.localeCompare(b, 'pt-BR'));
          const principaisVinculadosFonte =
            item.principaisVinculados instanceof Set
              ? item.principaisVinculados
              : new Set(item.principaisVinculados || []);
          const principaisVinculados = Array.from(
            principaisVinculadosFonte.values(),
          ).sort((a, b) => a.localeCompare(b, 'pt-BR'));
          const mapaQuantidadesPrincipais =
            item.principaisVinculadosQuantidades instanceof Map
              ? item.principaisVinculadosQuantidades
              : new Map(item.principaisVinculadosQuantidades || []);
          const principaisVinculadosDetalhes = principaisVinculados.map(
            (sku) => ({
              sku,
              quantidade: mapaQuantidadesPrincipais.get(sku) || 0,
            }),
          );
          const todosSkus = Array.from(
            new Set([
              ...grupoCompleto,
              ...vendidosPorSku.map(([sku]) => sku),
              item.sku,
            ]),
          ).sort((a, b) => a.localeCompare(b, 'pt-BR'));

          return {
            sku: item.sku,
            total: item.total,
            valorLiquido: item.valorLiquido,
            usuarios: Array.from(item.usuarios.entries()),
            vendidosPorSku,
            grupoCompleto,
            todosSkus,
            principaisVinculados,
            principaisVinculadosDetalhes,
          };
        });

        produtosVendidosCarregado = true;
        renderProdutosVendidos();
        if (statusEl && !produtosVendidosResumo.length) {
          statusEl.textContent =
            'Nenhum SKU encontrado para o período selecionado.';
        }

        const skuInput = document.getElementById('filtroSkuProdutosVendidos');
        if (skuInput && !skuInput.dataset.listenerAdded) {
          skuInput.addEventListener('input', renderProdutosVendidos);
          skuInput.dataset.listenerAdded = 'true';
        }
      } catch (err) {
        console.error('Erro ao carregar produtos vendidos', err);
        if (statusEl)
          statusEl.textContent =
            'Erro ao carregar dados de produtos vendidos.';
        if (tabela)
          tabela.innerHTML =
            '<tr><td colspan="4" class="py-6 text-center text-red-500">Erro ao carregar dados.</td></tr>';
      }
    }

    function obterProdutosVendidosParaExportacao() {
      return [...produtosVendidosResumo]
        .sort((a, b) => b.total - a.total)
        .map((item) => ({
          skuPrincipal: item.sku,
          skusAgrupados: item.todosSkus.join(', '),
          quantidadeTotal: item.total,
          valorLiquido: Number(item.valorLiquido || 0),
          skusVendidos: item.vendidosPorSku
          .map(
            ([sku, qtd]) => `${sku} (${qtd.toLocaleString('pt-BR')})`,
          )
          .join('; '),
        usuarios: item.usuarios
          .map(
            ([nome, qtd]) => `${nome} (${qtd.toLocaleString('pt-BR')})`,
          )
          .join('; '),
      }));
    }

    function exportarProdutosVendidosExcel() {
      if (!produtosVendidosResumo.length) {
        mostrarErro('Nenhum dado disponível para exportar.');
        return;
      }
      if (typeof XLSX === 'undefined') {
        mostrarErro('Biblioteca de exportação para Excel indisponível.');
        return;
      }

      const linhas = obterProdutosVendidosParaExportacao().map((linha) => ({
        'SKU Principal': linha.skuPrincipal,
        'SKUs Agrupados': linha.skusAgrupados,
        'Quantidade Vendida': linha.quantidadeTotal,
        'Valor Líquido (R$)': linha.valorLiquido,
        'Detalhe por SKU': linha.skusVendidos,
        'Usuários Responsáveis': linha.usuarios,
      }));

      const ws = XLSX.utils.json_to_sheet(linhas);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'ProdutosVendidos');
      const hoje = new Date().toISOString().slice(0, 10);
      XLSX.writeFile(wb, `produtos_vendidos_${hoje}.xlsx`);
      mostrarSucesso('Arquivo Excel gerado com sucesso.');
    }

    function exportarProdutosVendidosPDF() {
      if (!produtosVendidosResumo.length) {
        mostrarErro('Nenhum dado disponível para exportar.');
        return;
      }
      if (typeof html2pdf === 'undefined') {
        mostrarErro('Biblioteca de exportação para PDF indisponível.');
        return;
      }

      const ordenados = [...produtosVendidosResumo].sort(
        (a, b) => b.total - a.total,
      );
      const linhas = ordenados
        .map((item) => {
          const vendidos = item.vendidosPorSku
            .map(
              ([sku, qtd]) =>
                `${escapeHtml(sku)} (${qtd.toLocaleString('pt-BR')})`,
            )
            .join('<br>');
          const associados = item.grupoCompleto
            .map((sku) => escapeHtml(sku))
            .join(', ');
          const usuarios = item.usuarios
            .map(
              ([nome, qtd]) =>
                `${escapeHtml(nome)} (${qtd.toLocaleString('pt-BR')})`,
            )
            .join('<br>');
          const valorLiquido = Number(item.valorLiquido || 0).toLocaleString(
            'pt-BR',
            { style: 'currency', currency: 'BRL' },
          );
          return `
            <tr class="pdf-row">
              <td class="col-sku">
                <strong>${escapeHtml(item.sku)}</strong>
                <div style="margin-top:2px;font-size:10px;color:#555;">
                  Grupo: ${associados || '-'}
                </div>
              </td>
              <td class="col-detalhes">${vendidos || '-'}</td>
              <td class="col-quantidade">${item.total.toLocaleString(
                'pt-BR',
              )}</td>
              <td class="col-valor">${valorLiquido}</td>
              <td class="col-usuarios">${usuarios || '-'}</td>
            </tr>`;
        })
        .join('');

      const wrapper = document.createElement('div');
      const dataGeracao = new Date().toLocaleString('pt-BR');
      wrapper.innerHTML = `
        <div style="font-family: 'Inter', Arial, sans-serif;">
          <h2 style="margin-bottom:8px;">Produtos Vendidos</h2>
          <p style="margin-top:0;margin-bottom:16px;font-size:11px;color:#555;">
            Relatório gerado em ${dataGeracao}
          </p>
          <style>
            .pdf-table {
              width: 100%;
              border-collapse: collapse;
              font-size: 11px;
              table-layout: fixed;
            }
            .pdf-table th,
            .pdf-table td {
              page-break-inside: avoid;
              break-inside: avoid;
              padding: 6px;
              border: 1px solid #ddd;
              vertical-align: top;
              word-wrap: break-word;
              word-break: break-word;
            }
            .pdf-table thead th {
              background: #f3f4f6;
              color: #1f2937;
            }
            .pdf-table tbody td strong {
              display: block;
              margin-bottom: 4px;
            }
            .pdf-table .col-sku { width: 18%; }
            .pdf-table .col-detalhes { width: 28%; }
            .pdf-table .col-quantidade { width: 14%; text-align: right; }
            .pdf-table .col-valor { width: 16%; text-align: right; }
            .pdf-table .col-usuarios { width: 24%; }
          </style>
          <table class="pdf-table">
            <thead>
              <tr class="pdf-row">
                <th class="col-sku" style="text-align:left;">SKU Principal</th>
                <th class="col-detalhes" style="text-align:left;">Detalhe dos SKUs Vendidos</th>
                <th class="col-quantidade">Quantidade Vendida</th>
                <th class="col-valor">Valor Líquido</th>
                <th class="col-usuarios" style="text-align:left;">Usuários Responsáveis</th>
              </tr>
            </thead>
            <tbody>${linhas}</tbody>
          </table>
        </div>`;

      const opt = {
        margin: 0.5,
        filename: `produtos_vendidos_${new Date()
          .toISOString()
          .slice(0, 10)}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'cm', format: 'a4', orientation: 'portrait' },
        pagebreak: { mode: ['avoid-all', 'css', 'legacy'] },
      };

      html2pdf().set(opt).from(wrapper).save();
      mostrarSucesso('Arquivo PDF gerado com sucesso.');
    }

    async function carregarControleVendas() {
      const container = document.getElementById("listaControleVendas");
      const resumoContainer = document.getElementById("resumoMensalVendas");
      const projecaoContainer = document.getElementById("cardsProjecao");
      const filtroMes = document.getElementById("filtroMesVendas")?.value;
      container.innerHTML = "🔄 Carregando...";
      if (resumoContainer) resumoContainer.innerHTML = "";
      if (projecaoContainer) projecaoContainer.innerHTML = "🔄 Carregando...";

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      if (projecaoContainer) {
        const hoje = new Date();
        const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
        const anoMesPrev = proxMes.toISOString().slice(0, 7);
        try {
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            const prevSnap = await db.collectionGroup('previsoes')
              .where(firebase.firestore.FieldPath.documentId(), '==', anoMesPrev)
              .get();
            const totalPrev = {};
            prevSnap.forEach(doc => {
              const dados = doc.data();
              if (dados.skus) {
                Object.entries(dados.skus).forEach(([sku, info]) => {
                  totalPrev[sku] = (totalPrev[sku] || 0) + (info.total || 0);
                });
              }
            });
            if (Object.keys(totalPrev).length) {
              projecaoContainer.innerHTML = Object.entries(totalPrev)
                .map(([sku, total]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${total.toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
            }
          } else {
            const prevDoc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMesPrev).get();
            if (prevDoc.exists) {
              const dados = prevDoc.data();
              projecaoContainer.innerHTML = Object.entries(dados.skus || {})
                .map(([sku, info]) => `<div class="bg-yellow-100 text-yellow-800 p-4 rounded shadow flex justify-between"><span>${sku}</span><span class="font-bold">${(info.total || 0).toFixed(0)}</span></div>`)
                .join('');
            } else {
              projecaoContainer.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
            }
          }
        } catch (err) {
          console.error('Erro ao carregar previsão', err);
          projecaoContainer.innerHTML = '<p class="text-red-500">Erro ao carregar previsão.</p>';
        }
      }

      container.innerHTML = "";
      const totaisSku = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id; // Ex: 2025-07-21
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split("-");
          const [anoDoc, mesDoc] = dataDoc.split("-");
          if (anoFiltro !== anoDoc || mesFiltro !== mesDoc) continue;
        }

 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`);
        const listaSnap = await listaRef.get();
        if (listaSnap.empty) continue;

        let htmlSKUs = "";
        let totalDia = 0;

        listaSnap.forEach(docSKU => {
          const { sku, total, loja } = docSKU.data();
          const skuKey = sku || docSKU.id;
          totalDia += total || 0;
          htmlSKUs += `
      <div class="text-sm text-gray-700">
        <strong>${skuKey}</strong> (${loja || "-"}) — ${total || 0} unid.
      </div>`;
          totaisSku[skuKey] = (totaisSku[skuKey] || 0) + (total || 0);
        });

        const card = document.createElement("div");
        card.className = "bg-white rounded-lg shadow p-4 border border-gray-200";
        card.innerHTML = `
          <div class="text-center font-bold bg-blue-100 text-blue-800 py-2 rounded mb-2">${dataDoc}</div>
          <div class="mb-2 text-sm text-gray-600">🧾 Total do dia: <strong>${totalDia}</strong> unidades</div>
          ${htmlSKUs}
          <div class="text-right mt-2">
        <button onclick="verDetalhesDia('${dataDoc}')" class="text-blue-600 text-sm underline">🔍 Ver mais</button>
      </div>
        `;
        container.appendChild(card);
      }

      if (container.innerHTML === "") {
        container.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o período selecionado.</p>`;
      }
      if (resumoContainer) {
        if (Object.keys(totaisSku).length) {
          const cards = Object.entries(totaisSku)
            .sort((a, b) => b[1] - a[1])
            .map(([sku, total]) =>
              `<div class="bg-white rounded-lg shadow p-4 border border-gray-200 flex justify-between"><span>${sku}</span><span class="font-bold">${total}</span></div>`
            ).join("");
          resumoContainer.innerHTML = cards;
        } else {
          resumoContainer.innerHTML = `<p class="text-gray-500">Nenhum dado encontrado para o período selecionado.</p>`;
        }
      }
    }

    async function carregarSobras() {
      await tabsLoaded;
      if (!usuarioLogado.uid) {
        console.error('Usuário não autenticado');
        return;
      }
      const tbody = document.getElementById('listaSobras');
      if (tbody) tbody.innerHTML = '<tr><td colspan="9">Carregando...</td></tr>';
      try {
        const pedidos = [];
        const addPedidos = (snap, usuario) => {
          snap.forEach(doc => pedidos.push({ usuario, ...doc.data() }));
        };
        const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('pedidosErrados').get();
        addPedidos(snap, usuarioLogado.email || usuarioLogado.uid);
        const respSnap = await db.collection('usuarios').where('responsavelFinanceiroEmail', '==', usuarioLogado.email).get();
        for (const docSnap of respSnap.docs) {
          const nome = docSnap.data().nome || docSnap.data().email || docSnap.id;
          const errSnap = await db.collection('uid').doc(docSnap.id).collection('pedidosErrados').get();
          addPedidos(errSnap, nome);
        }
        if (tbody) {
          if (!pedidos.length) {
            tbody.innerHTML = '<tr><td colspan="9" class="text-center text-gray-500">Sem pedidos</td></tr>';
            return;
          }
          const format = v => Number(v || 0).toLocaleString('pt-BR', { minimumFractionDigits: 2 });
          tbody.innerHTML = '';
          pedidos.forEach(d => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${d.usuario || ''}</td><td>${d.dia || ''}</td><td>${d.loja || d.shop || ''}</td><td>${d.pedido || d.idPedido || d.numeroPedido || ''}</td><td>${d.sku || ''}</td><td>${d.quantidade || d.qtd || 0}</td><td>R$ ${format(d.subtotal)}</td><td>R$ ${format(d.sobraReal || d.totalLiquido)}</td><td>R$ ${format(d.sobraEsperada || d.metaEsperada)}</td>`;
            tbody.appendChild(tr);
          });
        }
      } catch (e) {
        console.error('Erro ao carregar sobras', e);
        if (tbody) tbody.innerHTML = '<tr><td colspan="9" class="text-red-500">Erro ao carregar dados</td></tr>';
      }
    }

    async function carregarPrevisao() {
      await tabsLoaded;
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const cards = document.getElementById('cardsPrevisao');
      if (!selectSku || !cards) return;
      cards.innerHTML = '🔄 Carregando...';
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const doc = await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).get();
      if (doc.exists) {
        previsaoDados = doc.data() || {};
        const skus = Object.keys(previsaoDados.skus || {});
        selectSku.innerHTML = '<option value="todos">Todos</option>' + skus.map(s => `<option value="${s}">${s}</option>`).join('');
        cards.innerHTML = '';
        renderizarPrevisao();
        renderizarTopSkus();
      } else {
        previsaoDados = { skus: {} };
        selectSku.innerHTML = '<option value="todos">Todos</option>';
        cards.innerHTML = '🔄 Gerando previsão inicial...';
        await gerarPrevisao({ topN: 5, silencioso: true });
      }
    }

    function renderizarPrevisao() {
      const selectSku = document.getElementById('filtroSkuPrevisao');
      const sku = selectSku?.value || 'todos';
      const cards = document.getElementById('cardsPrevisao');
      const tabela = document.getElementById('tabelaPrevisao');
      const ctx = document.getElementById('graficoPrevisao')?.getContext('2d');
      if (!cards || !tabela || !ctx) return;

      let diario = {};
      let totalBase = 0;
      if (sku === 'todos') {
        for (const info of Object.values(previsaoDados.skus || {})) {
          totalBase += info.total || 0;
          for (const [data, val] of Object.entries(info.diario || {})) {
            diario[data] = (diario[data] || 0) + val;
          }
        }
      } else if (previsaoDados.skus && previsaoDados.skus[sku]) {
        const info = previsaoDados.skus[sku];
        totalBase = info.total || 0;
        diario = info.diario || {};
      }

      const pess = totalBase * 0.85;
      const otm = totalBase * 1.15;
      cards.innerHTML = `
        <div class="bg-red-100 text-red-800 p-4 rounded shadow text-center">
          <div class="font-bold">Pessimista</div><div>${pess.toFixed(0)}</div>
        </div>
        <div class="bg-blue-100 text-blue-800 p-4 rounded shadow text-center">
          <div class="font-bold">Base</div><div>${totalBase.toFixed(0)}</div>
        </div>
        <div class="bg-green-100 text-green-800 p-4 rounded shadow text-center">
          <div class="font-bold">Otimista</div><div>${otm.toFixed(0)}</div>
        </div>`;

      const labels = Object.keys(diario).sort();
      const dados = labels.map(d => diario[d]);
      if (graficoPrevisao) graficoPrevisao.destroy();
      graficoPrevisao = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: [{ label: 'Previsão diária', data: dados, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.3)', tension: 0.2 }] },
        options: { responsive: true, maintainAspectRatio: false }
      });

      tabela.innerHTML = `
        <table class="min-w-full text-sm text-left">
          <thead><tr><th class="px-2 py-1 border">Data</th><th class="px-2 py-1 border">Qtde</th></tr></thead>
          <tbody>
            ${labels.map(d => `<tr><td class="px-2 py-1 border">${d}</td><td class="px-2 py-1 border">${diario[d].toFixed(0)}</td></tr>`).join('')}
          </tbody>
        </table>`;
    }

    function renderizarTopSkus() {
      const container = document.getElementById('topSkusPrevisao');
      if (!container) return;
      const dadosSkus = Object.entries(previsaoDados.skus || {});
      if (!dadosSkus.length) {
        container.innerHTML = '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
        return;
      }

      const cenarios = [
        { titulo: 'Pessimista', fator: 0.85 },
        { titulo: 'Base', fator: 1 },
        { titulo: 'Otimista', fator: 1.15 }
      ];

      const tabelas = cenarios.map(c => {
        const lista = dadosSkus
          .map(([sku, info]) => {
            const quantidade = (info.total || 0) * c.fator;
            const preco = produtos[sku] || 0;
            const sobraUnit = metas[sku]?.valor || 0;
            const bruto = quantidade * preco;
            const sobra = quantidade * sobraUnit;
            return { sku, quantidade, bruto, sobra };
          })
          .sort((a, b) => b.quantidade - a.quantidade)
          .slice(0, 10);

        if (!lista.length) {
          return '<p class="text-gray-500">Nenhuma previsão disponível.</p>';
        }

        const linhas = lista.map(item => `
            <tr>
              <td class="px-2 py-1 border">${item.sku}</td>
              <td class="px-2 py-1 border">${item.quantidade.toFixed(0)}</td>
              <td class="px-2 py-1 border">R$ ${item.bruto.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
              <td class="px-2 py-1 border">R$ ${item.sobra.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}</td>
            </tr>`).join('');

        return `
          <div class="overflow-x-auto">
            <h4 class="font-bold mb-2 text-center">Top 10 SKUs projeção ${c.titulo}</h4>
            <table class="min-w-full text-sm text-left">
              <thead>
                <tr>
                  <th class="px-2 py-1 border">SKU</th>
                  <th class="px-2 py-1 border">Quantidade</th>
                  <th class="px-2 py-1 border">Bruto Esperado<br>(Valor de venda)</th>
                  <th class="px-2 py-1 border">Sobra Esperada<br>(Sobra esperada x quantidade)</th>
                </tr>
              </thead>
              <tbody>
                ${linhas}
              </tbody>
            </table>
          </div>`;
      }).join('');

      container.innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4">${tabelas}</div>`;
    }

    function baixarPrevisaoPdf() {
      if (typeof html2pdf === 'undefined') {
        mostrarErro('Biblioteca de exportação para PDF indisponível.');
        return;
      }

      const area = document.getElementById('previsaoExportarArea');
      if (!area) {
        mostrarErro('Seção de previsão não encontrada para exportação.');
        return;
      }

      if (!area.querySelector('table')) {
        mostrarErro('Nenhuma previsão disponível para exportar.');
        return;
      }

      const botao = document.getElementById('btnExportarPrevisaoPdf');
      let textoOriginal;
      if (botao) {
        textoOriginal = botao.innerHTML;
        botao.disabled = true;
        botao.classList.add('opacity-70', 'cursor-not-allowed');
        botao.innerHTML = '<i class="fas fa-spinner fa-spin"></i><span> Gerando...</span>';
      }

      const tempContainer = document.createElement('div');
      tempContainer.style.padding = '24px';
      tempContainer.style.backgroundColor = '#ffffff';
      tempContainer.style.fontFamily = "'Inter', Arial, sans-serif";
      tempContainer.style.color = '#111827';
      tempContainer.style.maxWidth = '900px';
      tempContainer.style.margin = '0 auto';

      const titulo = document.createElement('div');
      const dataGeracao = new Date().toLocaleString('pt-BR');
      titulo.innerHTML = `
        <h2 style="margin: 0 0 8px 0; font-size: 20px; font-weight: 600;">Resumo de Previsão de Vendas</h2>
        <p style="margin: 0 0 16px 0; font-size: 12px; color: #6b7280;">Gerado em ${dataGeracao}</p>
      `;
      tempContainer.appendChild(titulo);

      const clone = area.cloneNode(true);
      clone.style.backgroundColor = '#ffffff';
      clone.style.padding = '0';
      clone.style.margin = '0';
      clone.style.width = '100%';

      const cardsClone = clone.querySelector('#cardsPrevisao');
      if (cardsClone) {
        cardsClone.style.display = 'grid';
        const colunas = Math.min(3, Math.max(1, cardsClone.children.length));
        cardsClone.style.gridTemplateColumns = `repeat(${colunas}, minmax(0, 1fr))`;
        cardsClone.style.gap = '16px';
      }

      clone.querySelectorAll('.bg-red-100, .bg-blue-100, .bg-green-100').forEach((el) => {
        el.style.borderRadius = '12px';
        el.style.padding = '16px';
        el.style.textAlign = 'center';
        el.style.boxShadow = '0 1px 2px rgba(15, 23, 42, 0.12)';
      });

      const topSkusClone = clone.querySelector('#topSkusPrevisao');
      if (topSkusClone) {
        const grid = topSkusClone.querySelector('.grid');
        if (grid) {
          grid.style.display = 'grid';
          grid.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
          grid.style.gap = '16px';
        }
        topSkusClone.querySelectorAll('table').forEach((table) => {
          table.style.width = '100%';
          table.style.borderCollapse = 'collapse';
        });
        topSkusClone.querySelectorAll('th, td').forEach((celula) => {
          celula.style.border = '1px solid #d1d5db';
          celula.style.padding = '8px';
          celula.style.fontSize = '12px';
        });
        topSkusClone.querySelectorAll('h4').forEach((tituloTabela) => {
          tituloTabela.style.fontSize = '14px';
          tituloTabela.style.marginBottom = '8px';
        });
      }

      tempContainer.appendChild(clone);
      document.body.appendChild(tempContainer);

      const opcoes = {
        margin: 0.5,
        filename: `previsao_vendas_${new Date().toISOString().slice(0, 10)}.pdf`,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true },
        jsPDF: { unit: 'cm', format: 'a4', orientation: 'portrait' },
        pagebreak: { mode: ['avoid-all', 'css', 'legacy'] },
      };

      const restaurarEstado = () => {
        if (tempContainer.parentNode) {
          tempContainer.parentNode.removeChild(tempContainer);
        }
        if (botao) {
          botao.disabled = false;
          botao.classList.remove('opacity-70', 'cursor-not-allowed');
          if (textoOriginal) {
            botao.innerHTML = textoOriginal;
          }
        }
      };

      html2pdf()
        .set(opcoes)
        .from(tempContainer)
        .save()
        .then(() => {
          mostrarSucesso('Arquivo PDF gerado com sucesso.');
        })
        .catch((erro) => {
          console.error('Erro ao exportar previsão para PDF:', erro);
          mostrarErro('Não foi possível gerar o PDF da previsão.');
        })
        .finally(restaurarEstado);
    }

    function gerarDatas(qtd, endDate = new Date()) {
      const datas = [];
      for (let i = qtd; i > 0; i--) {
        const d = new Date(endDate);
        d.setDate(d.getDate() - i);
        datas.push(d.toISOString().slice(0,10));
      }
      return datas;
    }

    function calcularBeta(arr) {
      const n = arr.length;
      const xMean = (n + 1) / 2;
      const yMean = arr.reduce((a, b) => a + b, 0) / n;
      let num = 0, den = 0;
      for (let i = 0; i < n; i++) {
        num += (i + 1 - xMean) * (arr[i] - yMean);
        den += Math.pow(i + 1 - xMean, 2);
      }
      return den ? num / den : 0;
    }

    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    function winsorize(arr, low = 0.05, high = 0.95) {
      const sorted = [...arr].sort((a, b) => a - b);
      const n = sorted.length;
      const lowVal = sorted[Math.floor(n * low)];
      const highVal = sorted[Math.ceil(n * high) - 1];
      return arr.map(v => clamp(v, lowVal, highVal));
    }

    function percentile(arr, p) {
      if (!arr.length) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = (sorted.length - 1) * p;
      const lower = Math.floor(idx);
      const upper = Math.ceil(idx);
      const weight = idx - lower;
      return sorted[lower] * (1 - weight) + (sorted[upper] || sorted[lower]) * weight;
    }

    async function gerarPrevisao(opcoes = {}) {
      const { topN, silencioso } = opcoes;
      const btn = document.getElementById('btnGerarPrevisao');
      if (btn) { btn.disabled = true; btn.innerText = 'Gerando...'; }
      const hoje = new Date();
      const proxMes = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 1);
      const anoMes = proxMes.toISOString().slice(0,7);
      const diasProxMes = new Date(proxMes.getFullYear(), proxMes.getMonth()+1, 0).getDate();
      const datas30 = gerarDatas(30, hoje);
      const datas90 = gerarDatas(90, hoje);
      const ref = db.collection(`uid/${usuarioLogado.uid}/skusVendidos`);
      const snap = await ref.get();
      const serieSkus = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        if (!datas90.includes(dataDoc)) continue;
        const listaSnap = await doc.ref.collection('lista').get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total } = skuDoc.data();
          const skuKey = sku || skuDoc.id;
          if (!serieSkus[skuKey]) serieSkus[skuKey] = {};
          serieSkus[skuKey][dataDoc] = (serieSkus[skuKey][dataDoc] || 0) + (total || 0);
        }
      }

      let skuKeys = Object.keys(serieSkus);
      if (topN) {
        const totais = skuKeys.map(sku => ({
          sku,
          total: datas30.reduce((s, d) => s + (serieSkus[sku][d] || 0), 0)
        }));
        skuKeys = totais.sort((a, b) => b.total - a.total).slice(0, topN).map(t => t.sku);
      }

      const previsao = { skus: {}, totalGeral: 0 };
      for (const sku of skuKeys) {
        const serie = serieSkus[sku] || {};
        const arr90 = datas90.map(d => serie[d] || 0);
        const arr90w = winsorize(arr90, 0.05, 0.95);
        const arr30 = arr90w.slice(-30);
        const arr7 = arr30.slice(-7);
        const avg30 = arr30.reduce((a,b)=>a+b,0) / arr30.length;
        const avg7 = arr7.reduce((a,b)=>a+b,0) / arr7.length;

        let w30 = 0.6;
        let w7 = 0.4;
        const nDados = Object.keys(serie).length;
        if (nDados < 30) {
          const f30 = Math.min(nDados / 30, 1);
          const f7 = Math.min(nDados / 7, 1);
          w30 *= f30;
          w7 *= f7;
          const wsum = w30 + w7;
          if (wsum > 0) { w30 /= wsum; w7 /= wsum; }
        }
        const base = w30 * avg30 + w7 * avg7;

        let beta = 0;
        if (nDados >= 14) beta = calcularBeta(arr30);
        const lowBase = avg30 < 1 && avg7 < 1;
        if (lowBase) beta = 0;

        const globalMean = arr90w.reduce((s,v)=>s+v,0) / arr90w.length;
        const weeks = Math.min(12, Math.floor(nDados / 7));
        let lambda = Math.min(1, weeks / 12);
        if (nDados < 7 || lowBase) lambda = 0;
        const fatores = {};
        for (let w=0; w<7; w++) {
          const vals = datas90
            .map((d,i)=>({d, v: arr90w[i]}))
            .filter(({d})=>new Date(d).getDay()===w)
            .map(({v})=>v);
          const m = vals.length ? vals.reduce((a,b)=>a+b,0)/vals.length : 0;
          const fatorWd = globalMean ? m/globalMean : 1;
          const saz = 1 + lambda * (fatorWd - 1);
          fatores[w] = clamp(saz, 0.85, 1.20);
        }

        const p95 = percentile(arr90w, 0.95);
        const diario = {};
        let total = 0;
        for (let i=1; i<=diasProxMes; i++) {
          const d = new Date(proxMes.getFullYear(), proxMes.getMonth(), i);
          const wd = d.getDay();
          const trendRaw = beta * i;
          const trend = clamp(trendRaw * 0.5, -0.2*base/30, 0.2*base/30);
          const saz = fatores[wd] || 1;
          let val = (base + trend) * saz;
          val = clamp(Math.round(Math.max(0, val)), 0, Math.round(p95 * 1.2));
          const ds = d.toISOString().slice(0,10);
          diario[ds] = val;
          total += val;
        }
        previsao.skus[sku] = { diario, total, p95 };
        previsao.totalGeral += total;
      }

      await db.collection('uid').doc(usuarioLogado.uid).collection('previsoes').doc(anoMes).set(previsao);
      if (btn) { btn.disabled = false; btn.innerHTML = '<i class="fas fa-sync-alt"></i> Gerar previsão'; }
      if (!silencioso) Swal.fire('Sucesso','Previsão gerada!','success');
      carregarPrevisao();
      carregarControleVendas();
    }
    window.verDetalhesDia = async function (dataDoc) {
let uids = [];
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        const q = await db.collectionGroup('skusVendidos')
          .where(firebase.firestore.FieldPath.documentId(), '==', dataDoc)
          .get();
        q.forEach(doc => uids.push(doc.ref.parent.parent.id));
      } else {
        uids.push(usuarioLogado.uid);
      }

      const agrupadoPorLoja = {};
      let sobraEsperada = 0;
      let valorLiquidoTotal = 0;

      for (const uid of uids) {
        const ref = db.collection(`uid/${uid}/skusVendidos/${dataDoc}/lista`);
        const snap = await ref.get();
        for (const doc of snap.docs) {
          const { sku, total, loja, valorLiquido: valorSku } = doc.data();
          if (!agrupadoPorLoja[loja]) agrupadoPorLoja[loja] = [];

          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(uid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dados = querySnap.docs[0].data();
              custo = Number(dados.custo || 0);

            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }
          sobraEsperada += (total || 0) * custo;
          valorLiquidoTotal += Number(valorSku || 0);
          agrupadoPorLoja[loja].push({ sku, total, custo, valorLiquido: valorSku || 0 });
        }
      }

      // 🧾 Montar HTML
      let html = `<strong>📅 Detalhes de ${dataDoc}</strong><br><br>`;
      for (const loja in agrupadoPorLoja) {
        html += `<strong>🏪 Loja: ${loja}</strong>`;
        html += `<table style="width:100%; border-collapse: collapse; margin: 8px 0;">
          <thead>
            <tr style="background:#f0f0f0;">
              <th style="border:1px solid #ddd; padding:4px;">SKU</th>
              <th style="border:1px solid #ddd; padding:4px;">Unidades</th>
              <th style="border:1px solid #ddd; padding:4px;">Sobra Esperada</th>
              <th style="border:1px solid #ddd; padding:4px;">Valor Líquido</th>
            </tr>
          </thead>
          <tbody>`;
        agrupadoPorLoja[loja].forEach(({ sku, total, custo, valorLiquido }) => {
          const sobraItem = (total || 0) * (custo || 0);
          html += `<tr>
            <td style="border:1px solid #ddd; padding:4px;">${sku}</td>
            <td style="border:1px solid #ddd; padding:4px;">${total}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${sobraItem.toFixed(2)}</td>
            <td style="border:1px solid #ddd; padding:4px;">R$ ${(valorLiquido || 0).toFixed(2)}</td>
          </tr>`;
        });
        html += `</tbody></table>`;
      }

      html += `<hr><strong>📦 Sobra Esperada:</strong> R$ ${sobraEsperada.toFixed(2)}<br>`;
      html += `<strong>💰 Valor Líquido Real:</strong> R$ ${valorLiquidoTotal.toFixed(2)}<br>`;

      Swal.fire({
        title: 'Detalhamento por Loja',
        html: html,
        icon: 'info',
        confirmButtonText: 'Fechar'
      });
    };

    async function exportarVendasMes() {
      const filtroMes = document.getElementById('filtroMesVendas')?.value;
      if (!filtroMes) {
        alert('Selecione um mês para exportar.');
        return;
      }

      let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('skusVendidos');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos');
      }
      const snap = await ref.get();

      const dados = [];
      const resumo = {};

      for (const doc of snap.docs) {
        const dataDoc = doc.id;
        const [anoDoc, mesDoc] = dataDoc.split('-');
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        if (anoDoc !== anoFiltro || mesDoc !== mesFiltro) continue;

        const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        const listaSnap = await db.collection(`uid/${ownerUid}/skusVendidos/${dataDoc}/lista`).get();
        for (const skuDoc of listaSnap.docs) {
          const { sku, total, loja, valorLiquido } = skuDoc.data();
          let custo = 0;
          try {
            const produtosRef = db.collection('uid').doc(ownerUid).collection('produtos');
            const querySnap = await produtosRef.where('sku', '==', sku).limit(1).get();
            if (!querySnap.empty) {
              const dadosProd = querySnap.docs[0].data();
              custo = Number(dadosProd.custo || 0);
            }
          } catch (e) {
            console.warn(`Erro ao buscar custo do SKU ${sku}:`, e);
          }

          const sobraEsperada = (total || 0) * (custo || 0);
          const sobraReal = Number(valorLiquido || 0);
          const chave = sku || skuDoc.id;

          dados.push({
            Data: dataDoc,
            Loja: loja || '-',
            SKU: chave,
            Unidades: total || 0,
            SobraEsperada: sobraEsperada,
            SobraReal: sobraReal
          });

          if (!resumo[chave]) resumo[chave] = { sku: chave, total: 0, prejuizo: 0 };
          resumo[chave].total += total || 0;
          resumo[chave].prejuizo += (sobraEsperada - sobraReal);
        }
      }

      if (!dados.length) {
        alert('Nenhum dado de vendas encontrado para o mês selecionado.');
        return;
      }

      const itemsResumo = Object.values(resumo);
      const maiorEntrada = itemsResumo.reduce((a, b) => (b.total > a.total ? b : a));
      const menorEntrada = itemsResumo.reduce((a, b) =>
        (b.total > 0 && b.total < a.total ? b : a), { total: Infinity });
      const maiorPrejuizo = itemsResumo.reduce((a, b) => (b.prejuizo > a.prejuizo ? b : a));

      const resumoSheet = [
        { Resumo: 'Maior entrada', SKU: maiorEntrada.sku, Unidades: maiorEntrada.total },
        { Resumo: 'Menor entrada', SKU: menorEntrada.sku, Unidades: menorEntrada.total },
        { Resumo: 'Maior prejuízo', SKU: maiorPrejuizo.sku, Valor: maiorPrejuizo.prejuizo.toFixed(2) }
      ];

      const wsDados = XLSX.utils.json_to_sheet(dados);
      const wsResumo = XLSX.utils.json_to_sheet(resumoSheet);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsDados, 'Vendas');
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');
      XLSX.writeFile(wb, `vendas_${filtroMes}.xlsx`);
    }

    async function exportarFaturamentoExcel() {
 let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      for (const docData of snap.docs) {
 const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? docData.ref.parent.parent.id
          : usuarioLogado.uid;
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${docData.id}/lojas`);
        const subSnap = await subRef.get();
       for (const sub of subSnap.docs) {
          let d = sub.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          dataExport.push({
            Data: docData.id,
            Loja: d.loja || "Desconhecida",
            Bruto: d.valorBruto || 0,
            Taxas: d.taxasPlataforma || 0,
            Líquido: d.valorLiquido || 0,
            Vendas: d.qtdVendas || 0
          });
       }
      }

      if (dataExport.length === 0) {
        alert("Nenhum dado de faturamento encontrado.");
        return;
      }

      const ws = XLSX.utils.json_to_sheet(dataExport);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, "Faturamento");
      XLSX.writeFile(wb, "faturamento.xlsx");
    }
    
    async function carregarAcompanhamento() {
      const tbody = document.querySelector('#tabelaAcompanhamento tbody');
      const resumoEl = document.getElementById('resumoAcompanhamento');
      tbody.innerHTML = '<tr><td colspan="4">🔄 Carregando...</td></tr>';
      resumoEl.innerHTML = '';
 const metaBrutoDiario = parseFloat(localStorage.getItem('metaBrutoDiario')) || 0;
      const metaLiquidoDiario = parseFloat(localStorage.getItem('metaLiquidoDiario')) || 0;
     const metaBrutoInput = document.getElementById('metaBrutoDiario');
      if (metaBrutoInput) metaBrutoInput.value = metaBrutoDiario || '';
      const metaLiquidoInput = document.getElementById('metaLiquidoDiario');
      if (metaLiquidoInput) metaLiquidoInput.value = metaLiquidoDiario || '';
      
    let ref;
      if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
        ref = db.collectionGroup('faturamento');
      } else {
        ref = db.collection('uid').doc(usuarioLogado.uid).collection('faturamento');
      }
      const snap = await ref.get();
      const { decryptString } = await import('./crypto.js');

      const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value;
      const normalizarMes = valor => {
        if (!valor) return '';
        if (valor instanceof Date) {
          return `${valor.getFullYear()}-${String(valor.getMonth() + 1).padStart(2, '0')}`;
        }
        if (typeof valor?.toDate === 'function') {
          const dt = valor.toDate();
          return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(2, '0')}`;
        }
        const texto = String(valor);
        const match = texto.match(/(\d{4})[-/_](\d{1,2})/);
        if (match) {
          return `${match[1]}-${match[2].padStart(2, '0')}`;
        }
        return '';
      };
      const extrairMesReferencia = (docId, dadosSaque) => {
        const candidatos = [];
        if (docId) candidatos.push(docId);
        const campos = ['anoMes', 'mesReferencia', 'mes', 'competencia', 'data', 'dataReferencia'];
        for (const campo of campos) {
          if (dadosSaque && Object.prototype.hasOwnProperty.call(dadosSaque, campo)) {
            const normalizado = normalizarMes(dadosSaque[campo]);
            if (normalizado) return normalizado;
            if (typeof dadosSaque[campo] === 'string') candidatos.push(dadosSaque[campo]);
          }
        }
        for (const candidato of candidatos) {
          const normalizado = normalizarMes(candidato);
          if (normalizado) return normalizado;
        }
        return '';
      };
      let dados = [];
      dadosAcompanhamento = [];
      sobraPorSku = {};
      resumoSku = {};
      let totalBruto = 0, totalLiquido = 0, totalVendas = 0, totalSobra = 0;
      let totalSaques = 0,
        totalComissaoPrevista = 0,
        totalComissaoPaga = 0;
      const ownerUidsFiltro = new Set();

      for (const doc of snap.docs) {
        if (filtroMes) {
          const [anoFiltro, mesFiltro] = filtroMes.split('-');
          const [ano, mes] = doc.id.split('-');
          if (ano !== anoFiltro || mes !== mesFiltro) continue;
        }

  const ownerUid = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())
          ? doc.ref.parent.parent.id
          : usuarioLogado.uid;
        if (ownerUid) ownerUidsFiltro.add(ownerUid);
        const subRef = db.collection(`uid/${ownerUid}/faturamento/${doc.id}/lojas`);
        const subSnap = await subRef.get();
        let bruto = 0, liquido = 0, vendas = 0;
         for (const s of subSnap.docs) {
          let d = s.data();
          if (d.encrypted) {
            try {
              const txt = await decryptString(d.encrypted, getPassphrase() || usuarioLogado.uid);
              d = JSON.parse(txt);
            } catch (e) { console.error('Erro ao descriptografar faturamento', e); }
          }
          bruto += d.valorBruto || 0;
          liquido += d.valorLiquido || 0;
          vendas += d.qtdVendas || 0;
        }

        let sobraDia = 0;
        try {
           let listaRef = db.collection(`uid/${ownerUid}/skusVendidos/${doc.id}/lista`);

          const listaSnap = await listaRef.get();
          listaSnap.forEach(item => {
            const { sku, total, valorLiquido } = item.data();
            const custo = Number(produtos[sku] || 0);
            const quantidade = total || 0;
            const valor = quantidade * custo;
            const liquidoSku = valorLiquido || 0;
            sobraDia += valor;
            sobraPorSku[sku] = (sobraPorSku[sku] || 0) + valor;
            resumoSku[sku] = resumoSku[sku] || { vendas: 0, sobra: 0, liquido: 0 };
            resumoSku[sku].vendas += quantidade;
            resumoSku[sku].sobra += valor;
            resumoSku[sku].liquido += liquidoSku;
          });
        } catch (e) {
          console.warn('Erro ao calcular sobra esperada do dia', e);
        }

        dados.push({ data: doc.id, bruto, liquido, vendas, sobra: sobraDia });
        totalBruto += bruto;
        totalLiquido += liquido;
        totalVendas += vendas;
        totalSobra += sobraDia;
      }

      if (!ownerUidsFiltro.size && usuarioLogado?.uid) ownerUidsFiltro.add(usuarioLogado.uid);
      const mesSelecionado = filtroMes || (dados.length ? normalizarMes(dados[0].data) : '');
      let encontrouSaquesMensais = false;
      if (mesSelecionado && ownerUidsFiltro.size) {
        for (const uidFiltro of ownerUidsFiltro) {
          try {
            const resumoRef = db.collection('usuarios').doc(uidFiltro).collection('comissoes').doc(mesSelecionado);
            const resumoSnap = await resumoRef.get();
            let totalSaquesDetalhados = 0;
            let totalComissaoDetalhada = 0;
            let possuiDetalhes = false;
            try {
              const saquesSnap = await resumoRef.collection('saques').get();
              if (!saquesSnap.empty) {
                encontrouSaquesMensais = true;
                for (const saqueDoc of saquesSnap.docs) {
                  const dadosMensais = saqueDoc.data() || {};
                  const valorSaque = Number(dadosMensais.valor) || 0;
                  totalSaquesDetalhados += valorSaque;
                  const comissaoPagaDoc = Number(dadosMensais.comissaoPaga);
                  const percentualPago = Number(dadosMensais.percentualPago);
                  if (Number.isFinite(comissaoPagaDoc)) {
                    totalComissaoDetalhada += comissaoPagaDoc;
                  } else if (Number.isFinite(percentualPago) && percentualPago > 0) {
                    totalComissaoDetalhada += valorSaque * percentualPago;
                  }
                }
                possuiDetalhes = true;
              }
            } catch (e) {
              console.error('Erro ao carregar saques mensais detalhados', e);
            }
            if (resumoSnap.exists()) {
              let utilizouResumo = false;
              const dadosResumo = resumoSnap.data() || {};
              const totalSacadoResumo = Number(dadosResumo.totalSacado);
              const comissaoPrevistaResumo = Number(dadosResumo.comissaoPrevista);
              const comissaoJaPagaResumo = Number(
                dadosResumo.comissaoJaPaga ?? dadosResumo.comissaoRecebida,
              );
              const ajusteFinalResumo = Number(dadosResumo.ajusteFinal);
              let comissaoPagaResumo = Number.isFinite(comissaoJaPagaResumo)
                ? comissaoJaPagaResumo
                : NaN;
              if (
                !Number.isFinite(comissaoPagaResumo) &&
                Number.isFinite(comissaoPrevistaResumo) &&
                Number.isFinite(ajusteFinalResumo)
              ) {
                comissaoPagaResumo = comissaoPrevistaResumo - ajusteFinalResumo;
              }
              if (Number.isFinite(totalSacadoResumo)) {
                totalSaques += totalSacadoResumo;
                utilizouResumo = true;
              }
              if (Number.isFinite(comissaoPrevistaResumo)) {
                totalComissaoPrevista += comissaoPrevistaResumo;
                utilizouResumo = true;
              }
              if (Number.isFinite(comissaoPagaResumo)) {
                totalComissaoPaga += comissaoPagaResumo;
                utilizouResumo = true;
              }
              if (utilizouResumo) {
                encontrouSaquesMensais = true;
              } else if (possuiDetalhes) {
                totalSaques += totalSaquesDetalhados;
                totalComissaoPrevista += totalComissaoDetalhada;
                totalComissaoPaga += totalComissaoDetalhada;
              }
            } else if (possuiDetalhes) {
              totalSaques += totalSaquesDetalhados;
              totalComissaoPrevista += totalComissaoDetalhada;
              totalComissaoPaga += totalComissaoDetalhada;
            }
          } catch (e) {
            console.error('Erro ao carregar resumo de saques mensais', e);
          }
        }
      }
      if (!encontrouSaquesMensais) {
        try {
          let refSaques;
          if (["adm","admin"].includes(usuarioLogado.perfil.toLowerCase())) {
            refSaques = db.collectionGroup('saques');
          } else {
            refSaques = db.collection('uid').doc(usuarioLogado.uid).collection('saques');
          }
          const snapSaques = await refSaques.get();
          for (const docS of snapSaques.docs) {
            const ownerUidSaques = ["adm","admin"].includes(usuarioLogado.perfil.toLowerCase()) ? docS.ref.parent.parent.id : usuarioLogado.uid;
            if (!ownerUidSaques) continue;
            if (ownerUidsFiltro.size && !ownerUidsFiltro.has(ownerUidSaques)) continue;
            let dadosSaque = docS.data();
            if (dadosSaque.encrypted) {
              try {
                const txt = await decryptString(dadosSaque.encrypted, getPassphrase() || `chave-${dadosSaque.uid || ownerUidSaques || usuarioLogado.uid}`);
                dadosSaque = JSON.parse(txt);
              } catch (e) {
                console.error('Erro ao descriptografar saque', e);
                continue;
              }
            }
            const mesDoc = extrairMesReferencia(docS.id, dadosSaque);
            if (mesSelecionado && mesDoc && mesDoc !== mesSelecionado) continue;
            if (mesSelecionado && !mesDoc) continue;
            const valorSaqueTotal = Number(dadosSaque.valorTotal || dadosSaque.valor || 0) || 0;
            totalSaques += valorSaqueTotal;
            try {
              const subRefSaque = db.collection(`uid/${ownerUidSaques}/saques/${docS.id}/lojas`);
              const subSnapSaque = await subRefSaque.get();
              for (const lojaDoc of subSnapSaque.docs) {
                let dadosLoja = lojaDoc.data();
                if (dadosLoja.encrypted) {
                  try {
                    const txtLoja = await decryptString(dadosLoja.encrypted, getPassphrase() || `chave-${dadosSaque.uid || ownerUidSaques}`);
                    dadosLoja = JSON.parse(txtLoja);
                  } catch (e) {
                    console.error('Erro ao descriptografar loja saque', e);
                    continue;
                  }
                }
                const valorLoja = parseFloat(dadosLoja.valor) || 0;
                const comissaoPct = parseFloat(dadosLoja.comissao) || 0;
                if (comissaoPct) {
                  const valorComissao = (valorLoja * comissaoPct) / 100;
                  totalComissaoPrevista += valorComissao;
                  totalComissaoPaga += valorComissao;
                }
              }
            } catch (e) {
              console.error('Erro ao carregar comissão dos saques', e);
            }
          }
        } catch (e) {
          console.error('Erro ao carregar saques', e);
        }
      }
      const totalComissaoAPagar = Math.max(0, totalComissaoPrevista - totalComissaoPaga);
      totalSaquesAcompanhamento = totalSaques;
      totalComissaoAcompanhamento = totalComissaoPrevista;
      totalComissaoPagaAcompanhamento = totalComissaoPaga;
      totalComissaoAPagarAcompanhamento = totalComissaoAPagar;

      tbody.innerHTML = '';
      dados.sort((a,b) => a.data.localeCompare(b.data));
      dadosAcompanhamento = dados.slice();
      dados.forEach(d => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${d.data}</td><td>R$ ${d.bruto.toLocaleString('pt-BR')}</td><td>R$ ${d.liquido.toLocaleString('pt-BR')}</td><td>${d.vendas}</td>`;
            if ((metaBrutoDiario && d.bruto < metaBrutoDiario) || (metaLiquidoDiario && d.liquido < metaLiquidoDiario)) {
          tr.classList.add('abaixo-meta');
        }
        tbody.appendChild(tr);
      });

 // Calcula totais a partir de dadosAcompanhamento
      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const ticket = totais.vendas ? totais.liquido / totais.vendas : 0;
const dias = dadosAcompanhamento.length;
      const totalMetaBruto = metaBrutoDiario * dias;
      const totalMetaLiquido = metaLiquidoDiario * dias;
      const diffBruto = totais.bruto - totalMetaBruto;
      const diffLiquido = totais.liquido - totalMetaLiquido;
      const percBruto = totalMetaBruto ? (diffBruto / totalMetaBruto) * 100 : 0;
      const percLiquido = totalMetaLiquido ? (diffLiquido / totalMetaLiquido) * 100 : 0;
      const resumoBrutoMeta = metaBrutoDiario ? `<small>${diffBruto >= 0 ? 'Acima' : 'Abaixo'} da meta (${percBruto.toFixed(2)}%, R$ ${Math.abs(diffBruto).toLocaleString('pt-BR')})</small>` : '';
      const resumoLiquidoMeta = metaLiquidoDiario ? `<small>${diffLiquido >= 0 ? 'Acima' : 'Abaixo'} da meta (${percLiquido.toFixed(2)}%, R$ ${Math.abs(diffLiquido).toLocaleString('pt-BR')})</small>` : '';
      
      resumoEl.classList.add('resumo-grid');
resumoEl.innerHTML = `
   <div class="resumo-card"><h4>Total Bruto</h4><p>R$ ${totais.bruto.toLocaleString('pt-BR')}</p>${resumoBrutoMeta}</div>
        <div class="resumo-card"><h4>Total Líquido</h4><p>R$ ${totais.liquido.toLocaleString('pt-BR')}</p>${resumoLiquidoMeta}</div>
        <div class="resumo-card"><h4>Total Vendido</h4><p>${totais.vendas}</p><button class="btn btn-secondary btn-sm" style="margin-top:0.5rem" onclick="mostrarDetalhesVendas()">Ver mais</button></div>
        <div class="resumo-card"><h4>Total Saques</h4><p>R$ ${totalSaques.toLocaleString('pt-BR')}</p></div>
        <div class="resumo-card"><h4>Comissão do Mês</h4><p>R$ ${totalComissaoPrevista.toLocaleString('pt-BR')}</p><small>Pago: R$ ${totalComissaoPaga.toLocaleString('pt-BR')} | A pagar: R$ ${totalComissaoAPagar.toLocaleString('pt-BR')}</small></div>
        <div class="resumo-card"><h4>Ticket Médio</h4><p>R$ ${ticket.toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</p></div>`;
    }

function mostrarDetalhesVendas(data = resumoSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'Não há informações de vendas por SKU para o período selecionado.', 'info');
    return;
  }

  const entries = Object.entries(data)
    .map(([sku, info]) => [sku, Number(info.vendas) || 0])
    .sort((a, b) => b[1] - a[1]);

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  let rows = '';
  for (const [sku, qtd] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${qtd}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Quantidade Vendida</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${total}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Vendas por SKU',
    html,
    width: '80%',
    confirmButtonText: 'Fechar'
  });
}

function mostrarDetalhesSobra(data = sobraPorSku) {
  if (!data || !Object.keys(data).length) {
    Swal.fire('Sem dados', 'Não há informações de sobra esperada por SKU para o período selecionado.', 'info');
    return;
  }

  const fmtBRL = new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' });

  // entries = [['SKU1', 123.45], ...] — garantindo número válido
  const entries = Object.entries(data)
    .map(([sku, v]) => [sku, Number(v) || 0])
    .sort((a, b) => b[1] - a[1]); // ordem decrescente por valor

  const total = entries.reduce((acc, [, v]) => acc + v, 0);

  // Monta tabela
  let rows = '';
  for (const [sku, valor] of entries) {
    rows += `
      <tr>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;"><strong>${sku}</strong></td>
        <td style="padding:8px 10px;border-bottom:1px solid #eee;text-align:right;">${fmtBRL.format(valor)}</td>
      </tr>`;
  }

  const html = `
    <div style="text-align:left; max-height:60vh; overflow:auto;">
      <table style="width:100%; border-collapse:collapse; font-size:14px;">
        <thead>
          <tr>
            <th style="text-align:left; padding:8px 10px; border-bottom:1px solid #ddd;">SKU</th>
            <th style="text-align:right; padding:8px 10px; border-bottom:1px solid #ddd;">Sobra Esperada</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
        <tfoot>
          <tr>
            <td style="padding:10px; font-weight:600; border-top:2px solid #ddd;">Total</td>
            <td style="padding:10px; text-align:right; font-weight:600; border-top:2px solid #ddd;">${fmtBRL.format(total)}</td>
          </tr>
        </tfoot>
      </table>
    </div>`;

  Swal.fire({
    title: 'Sobra Esperada por SKU',
    html,
    width: 720,
    confirmButtonText: 'OK'
  });
}

     function exportarAcompanhamentoExcel() {
      if (!dadosAcompanhamento.length) return;

      const mediaSaques = totalSaquesAcompanhamento / (dadosAcompanhamento.length || 1);
      const sheetData = dadosAcompanhamento.map(d => ({
        Data: d.data,
        Bruto: d.bruto,
        Liquido: d.liquido,
        Vendas: d.vendas,
        SobraEsperada: d.sobra,
        SobraReal: d.sobra - mediaSaques
      }));

      const wsVendas = XLSX.utils.json_to_sheet(sheetData);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, wsVendas, 'Vendas');

      const totais = dadosAcompanhamento.reduce((acc, item) => {
        acc.bruto += item.bruto || 0;
        acc.liquido += item.liquido || 0;
        acc.vendas += item.vendas || 0;
        acc.sobra += item.sobra || 0;
        return acc;
      }, { bruto: 0, liquido: 0, vendas: 0, sobra: 0 });
      const sobraRealTotal = totais.sobra - totalSaquesAcompanhamento;

      const entries = Object.entries(sobraPorSku || {});
      let maiorEntrada = ['', 0], menorEntrada = ['', 0], prejuizo = ['', 0];
      if (entries.length) {
        maiorEntrada = entries.reduce((a,b)=>b[1]>a[1]?b:a, entries[0]);
        menorEntrada = entries.reduce((a,b)=>b[1]<a[1]?b:a, entries[0]);
        const negativos = entries.filter(([,v])=>v<0);
        if (negativos.length) prejuizo = negativos.reduce((a,b)=>b[1]<a[1]?b:a, negativos[0]);
      }

      const resumo = [
        { Campo: 'Sobra Esperada Total', Valor: totais.sobra },
        { Campo: 'Sobra Real Total', Valor: sobraRealTotal },
        { Campo: 'Produto Maior Entrada', SKU: maiorEntrada[0], Valor: maiorEntrada[1] },
        { Campo: 'Produto Menor Entrada', SKU: menorEntrada[0], Valor: menorEntrada[1] }
      ];
      if (prejuizo[0]) resumo.push({ Campo: 'Produto Prejuízo', SKU: prejuizo[0], Valor: prejuizo[1] });

      const resumoSkus = Object.entries(resumoSku || {})
        .map(([sku, info]) => ({
          SKU: sku,
          Vendas: info.vendas,
          SobraEsperada: info.sobra,
          Liquido: info.liquido
        }))
        .sort((a, b) => b.Vendas - a.Vendas);

      const wsResumo = XLSX.utils.json_to_sheet(resumo);
      XLSX.utils.sheet_add_aoa(wsResumo, [[]], { origin: -1 });
      XLSX.utils.sheet_add_json(wsResumo, resumoSkus, { origin: -1 });
      XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');

      XLSX.writeFile(wb, 'acompanhamento.xlsx');
    }

    function exportarResumoTopSkus() {
      if (!dadosAcompanhamento.length) {
        Swal.fire('Sem dados', 'Carregue o acompanhamento para exportar o resumo.', 'info');
        return;
      }

      const totalPecasVendidas = dadosAcompanhamento.reduce(
        (acc, item) => acc + (Number(item.vendas) || 0),
        0,
      );

      const topSkus = Object.entries(resumoSku || {})
        .map(([sku, info]) => ({
          sku,
          quantidade: Number(info?.vendas) || 0,
          valorLiquido: Number(info?.liquido) || 0,
        }))
        .filter(({ quantidade, valorLiquido }) => quantidade > 0 || valorLiquido > 0)
        .sort((a, b) => b.quantidade - a.quantidade)
        .slice(0, 15);

      if (!topSkus.length) {
        Swal.fire('Sem dados', 'Não há vendas por SKU para o período selecionado.', 'info');
        return;
      }

      const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value;
      const referenciaMes = (() => {
        if (filtroMes) return filtroMes;
        const hoje = new Date();
        return `${hoje.getFullYear()}-${String(hoje.getMonth() + 1).padStart(2, '0')}`;
      })();

      const linhas = [
        ['Resumo de Vendas - Top 15 SKUs'],
        ['Mês selecionado', referenciaMes],
        ['Total de Peças Vendidas', totalPecasVendidas],
        [],
        ['SKU', 'Quantidade Vendida', 'Valor Líquido (R$)'],
      ];

      topSkus.forEach(({ sku, quantidade, valorLiquido }) => {
        linhas.push([sku, quantidade, Math.round((valorLiquido + Number.EPSILON) * 100) / 100]);
      });

      const ws = XLSX.utils.aoa_to_sheet(linhas);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Top 15 SKUs');
      XLSX.writeFile(wb, `top_skus_${referenciaMes}.xlsx`);
    }

    function exportarAcompanhamentoPDF() {
      const element = document.getElementById('areaImpressao');
      if (!element) return;
      const opt = { margin: 1, filename: 'acompanhamento.pdf', image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 2 }, jsPDF: { unit: 'cm', format: 'a4', orientation: 'portrait' } };
      html2pdf().set(opt).from(element).save();
    }

    function printAcompanhamento() {
 const element = document.getElementById('areaImpressao');
      if (!element) return;
      const printWindow = window.open('', '', 'width=900,height=650');
      printWindow.document.write(`
        <html>
          <head>
            <title>Imprimir Acompanhamento</title>
            <link rel="stylesheet" href="css/styles.css?v=20240826">
          </head>
          <body>
            ${element.innerHTML}
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
      printWindow.close();
    }
  
    function salvarMetasAcompanhamento() {
      const bruto = parseFloat(document.getElementById('metaBrutoDiario').value) || 0;
      const liquido = parseFloat(document.getElementById('metaLiquidoDiario').value) || 0;
      localStorage.setItem('metaBrutoDiario', bruto);
      localStorage.setItem('metaLiquidoDiario', liquido);
      carregarAcompanhamento();
    }

function aplicarEstiloCritico() {
  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const statusEl = linha.querySelector(".status-only");
    if (!statusEl) return;

    const status = statusEl.textContent.trim().toLowerCase();

    if (status === "crítico") {
      linha.style.backgroundColor = "#ffebee"; // fundo vermelho claro
      linha.style.color = "#b71c1c";            // texto vermelho escuro
      linha.style.fontWeight = "bold";
    } else {
      // Remove estilo se não for crítico (útil em reaplicações de filtro)
      linha.style.backgroundColor = "";
      linha.style.color = "";
      linha.style.fontWeight = "";
    }
  });
}
 window.toggleInfoFaturamento = function() {
    const card = document.getElementById('infoFaturamento');
    if (card) {
      card.classList.toggle('hidden');
    }
  };

  window.fecharFaturamentoMassaModal = function() {
    const modal = document.getElementById('massaFaturamentoModal');
    if (modal) {
      modal.style.display = 'none';
    }
  };


function filtrarPorSKU() {
  const tipoFiltro = document.getElementById('tipoFiltro').value;
  const textoSKU = document.getElementById('filtroSKU').value.trim().toLowerCase();
  const filtroStatus = document.getElementById('filtroStatus').value.toLowerCase();

  const linhas = document.querySelectorAll("#resultado tbody tr");

  linhas.forEach(linha => {
    const sku = linha.children[1].textContent.toLowerCase();
    const status = linha.querySelector('.status-only')?.dataset.status.toLowerCase() || '';

    let corresponde = false;

    if (textoSKU === '') {
      corresponde = true;
    } else if (tipoFiltro === 'exata') {
      corresponde = sku === textoSKU;
    } else if (tipoFiltro === 'comeca') {
      corresponde = sku.startsWith(textoSKU);
    } else {
      corresponde = sku.includes(textoSKU);
    }

    const statusCorresponde = !filtroStatus || status === filtroStatus;

  linha.style.display = corresponde && statusCorresponde ? '' : 'none';
  });
}

async function verificarGestorFinanceiro() {
  try {
    const snap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .limit(1)
      .get();
    if (!snap.empty) {
      const btn = document.getElementById('btnAcompanhamentoGestor');
      if (btn) btn.classList.remove('hidden');
    }
  } catch (e) {
    console.error('Erro ao verificar gestor financeiro', e);
  }
}

async function carregarAcompanhamentoGestor() {
  const pedidosBody = document.querySelector('#tabelaPedidosCriticosGestor tbody');
  if (pedidosBody) pedidosBody.innerHTML = '';

  try {
    const usuariosSnap = await db.collection('usuarios')
      .where('responsavelFinanceiroEmail', '==', usuarioLogado.email)
      .get();
    const usuarios = [];
    usuariosSnap.forEach(doc => usuarios.push({ uid: doc.id, ...doc.data() }));

    const selectUsuario = document.getElementById('filtroUsuarioGestor');
    if (selectUsuario && selectUsuario.options.length <= 1) {
      usuarios.forEach(u => {
        const opt = document.createElement('option');
        opt.value = u.uid;
        opt.textContent = u.nome || u.email || u.uid;
        selectUsuario.appendChild(opt);
      });
    }

    const filtroUsuario = selectUsuario ? selectUsuario.value : '';
    const tipoData = document.getElementById('filtroDataTipo')?.value || 'mes';
    let inicio = null, fim = null;
    if (tipoData === 'dia') {
      const dia = document.getElementById('filtroDiaGestor')?.value;
      if (dia) { inicio = dia; fim = dia; }
    } else if (tipoData === 'periodo') {
      inicio = document.getElementById('filtroInicioGestor')?.value;
      fim = document.getElementById('filtroFimGestor')?.value;
    } else {
      const mes = document.getElementById('filtroMesGestor')?.value;
      if (mes) {
        inicio = mes + '-01';
        const [ano, m] = mes.split('-');
        const ultimoDia = new Date(ano, m, 0).getDate();
        fim = `${mes}-${String(ultimoDia).padStart(2,'0')}`;
      }
    }

    const pedidosErrados = [];

    for (const u of usuarios) {
      if (filtroUsuario && u.uid !== filtroUsuario) continue;

      const errSnap = await db.collection('uid').doc(u.uid).collection('pedidosErrados').get();
      errSnap.forEach(e => {
        const d = e.data();
        const dataPedido = d.dia || d.data || d.dataPedido;
        if (inicio && fim && dataPedido && (dataPedido < inicio || dataPedido > fim)) return;
        pedidosErrados.push({ usuario: u.nome || u.email || u.uid, ...d });
      });
    }

    if (pedidosBody) {
      if (!pedidosErrados.length) {
        pedidosBody.innerHTML = '<tr><td colspan="6" class="text-center text-gray-500">Sem pedidos registrados</td></tr>';
      } else {
        pedidosErrados.forEach(p => {
          const dataPedido = p.dia || p.dataPedido || p.data || '';
          const pedido = p.pedido || p.numeroPedido || p.id || '';
          const sku = p.sku || '';
          const qtd = p.quantidade || p.qtd || 0;
          const esp = Number(p.sobraEsperada || p.metaEsperada || 0);
          const real = Number(p.sobraReal || p.totalLiquido || 0);
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${dataPedido}</td><td>${pedido}</td><td>${sku}</td><td>${qtd}</td><td>R$ ${esp.toFixed(2)}</td><td>R$ ${real.toFixed(2)}</td>`;
          pedidosBody.appendChild(tr);
        });
      }
    }
  } catch (e) {
    console.error('Erro ao carregar acompanhamento do gestor', e);
    if (pedidosBody) pedidosBody.innerHTML = '<tr><td colspan="6" class="text-red-500">Erro ao carregar dados</td></tr>';
  }
}

function atualizarTipoFiltroGestor() {
  const tipo = document.getElementById('filtroDataTipo')?.value;
  const mesEl = document.getElementById('filtroMesGestor');
  const diaEl = document.getElementById('filtroDiaGestor');
  const periodoEl = document.getElementById('filtroPeriodoGestor');
  mesEl?.classList.add('hidden');
  diaEl?.classList.add('hidden');
  periodoEl?.classList.add('hidden');
  if (tipo === 'dia') diaEl?.classList.remove('hidden');
  else if (tipo === 'periodo') periodoEl?.classList.remove('hidden');
  else mesEl?.classList.remove('hidden');
}

async function atualizarResponsavelFinanceiro(btn) {
  const botao = btn || document.getElementById('btnAtualizarRespFin');
  if (botao) toggleLoading(botao, 'Atualizar Responsável');
  try {
    const usuarioDoc = await db.collection('usuarios').doc(usuarioLogado.uid).get();
    const dadosUsuario = usuarioDoc.data() || {};
    const respEmail = (dadosUsuario.responsavelFinanceiroEmail || '').trim();
    if (!respEmail) {
      alert('Nenhum responsável financeiro configurado.');
      return;
    }
    const respSnap = await db.collection('usuarios').where('email', '==', respEmail).limit(1).get();
    let respDoc;
    if (respSnap.empty) {
      const altSnap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
      if (altSnap.empty) {
        alert('Responsável financeiro não encontrado.');
        return;
      }
      respDoc = altSnap.docs[0];
    } else {
      respDoc = respSnap.docs[0];
    }
    const respData = respDoc.data() || {};
    const responsavelUid = respData.uid || respDoc.id;
    const baseResp = db.collection('uid').doc(responsavelUid).collection('uid').doc(usuarioLogado.uid);
    const pass = getPassphrase() || usuarioLogado.uid;
    const filtroMes = document.getElementById('filtroMesAcompanhamento')?.value || document.getElementById('filtroMesRegistro')?.value;
    const { decryptString, encryptString } = await import('./crypto.js');
    const snap = await db.collection('uid').doc(usuarioLogado.uid).collection('faturamento').get();
    for (const doc of snap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      let resumo = doc.data();
      if (resumo.encrypted) {
        try {
          resumo = JSON.parse(await decryptString(resumo.encrypted, pass));
        } catch (e) {
          console.error('Erro ao descriptografar faturamento', e);
          continue;
        }
      }
      const resumoResp = await baseResp.collection('faturamento').doc(dia).get();
      if (!resumoResp.exists) {
        const encResumo = await encryptString(JSON.stringify(resumo), respEmail);
        await baseResp.collection('faturamento').doc(dia).set({ encrypted: encResumo, uid: usuarioLogado.uid }, { merge: true });
      }
      const lojasSnap = await db.collection(`uid/${usuarioLogado.uid}/faturamento/${dia}/lojas`).get();
      for (const lojaDoc of lojasSnap.docs) {
        const loja = lojaDoc.id;
        const destinoDoc = await baseResp.collection('faturamento').doc(dia).collection('lojas').doc(loja).get();
        if (destinoDoc.exists) continue;
        let dadosLoja = lojaDoc.data();
        if (dadosLoja.encrypted) {
          try {
            dadosLoja = JSON.parse(await decryptString(dadosLoja.encrypted, pass));
          } catch (e) {
            console.error('Erro ao descriptografar faturamento', e);
            continue;
          }
      }
      const encLoja = await encryptString(JSON.stringify(dadosLoja), respEmail);
      await baseResp
        .collection('faturamento')
        .doc(dia)
        .collection('lojas')
        .doc(loja)
        .set({ encrypted: encLoja, uid: usuarioLogado.uid });
      }
    }

    // Copiar SKUs vendidos para o responsável financeiro
    const skusSnap = await db.collection('uid').doc(usuarioLogado.uid).collection('skusVendidos').get();
    for (const doc of skusSnap.docs) {
      const dia = doc.id;
      if (filtroMes) {
        const [anoFiltro, mesFiltro] = filtroMes.split('-');
        const [ano, mes] = dia.split('-');
        if (ano !== anoFiltro || mes !== mesFiltro) continue;
      }
      const listaSnap = await db.collection(`uid/${usuarioLogado.uid}/skusVendidos/${dia}/lista`).get();
      if (listaSnap.empty) continue;
      await baseResp.collection('skusVendidos').doc(dia).set({ data: dia, uid: usuarioLogado.uid }, { merge: true });
      for (const skuDoc of listaSnap.docs) {
        const dadosSku = skuDoc.data();
        const payload = {
          sku: dadosSku.sku || skuDoc.id,
          total: dadosSku.total || 0,
          valorLiquido: dadosSku.valorLiquido || 0,
          data: dia,
          loja: dadosSku.loja || null,
          uid: usuarioLogado.uid
        };
        const dadoSalvar = respEmail
          ? { encrypted: await encryptString(JSON.stringify(payload), respEmail), uid: usuarioLogado.uid }
          : payload;
        await baseResp
          .collection('skusVendidos')
          .doc(dia)
          .collection('lista')
          .doc(skuDoc.id)
          .set(dadoSalvar);
      }
    }

    alert('Dados enviados ao responsável financeiro.');
  } catch (e) {
    console.error('Erro ao atualizar responsável financeiro', e);
    alert('Erro ao atualizar responsável financeiro.');
  } finally {
    if (botao) toggleLoading(botao, 'Atualizar Responsável');
  }
}

window.carregarRegistrosFaturamento = carregarRegistrosFaturamento;
window.carregarControleVendas = carregarControleVendas;
window.carregarProdutosVendidos = carregarProdutosVendidos;
window.carregarSobras = carregarSobras;
window.carregarPrevisao = carregarPrevisao;
window.gerarPrevisao = gerarPrevisao;
window.renderizarPrevisao = renderizarPrevisao;
window.carregarAcompanhamento = carregarAcompanhamento;
window.carregarAcompanhamentoGestor = carregarAcompanhamentoGestor;
window.verificarGestorFinanceiro = verificarGestorFinanceiro;
window.exportarProdutosVendidosExcel = exportarProdutosVendidosExcel;
window.exportarProdutosVendidosPDF = exportarProdutosVendidosPDF;
window.exportarAcompanhamentoExcel = exportarAcompanhamentoExcel;
window.exportarResumoTopSkus = exportarResumoTopSkus;
window.exportarAcompanhamentoPDF = exportarAcompanhamentoPDF;
window.printAcompanhamento = printAcompanhamento;
window.baixarPrevisaoPdf = baixarPrevisaoPdf;
  window.salvarMetasAcompanhamento = salvarMetasAcompanhamento;
window.atualizarResponsavelFinanceiro = atualizarResponsavelFinanceiro;
window.exportarVendasMes = exportarVendasMes;
window.mostrarDetalhesVendas = mostrarDetalhesVendas;
window.mostrarDetalhesSobra = mostrarDetalhesSobra;
window.mostrarDetalhesFaturamento = mostrarDetalhesFaturamento;
window.excluirFaturamento = excluirFaturamento;
window.analisarSobrasIA = analisarSobrasIA;
window.exportarCSV = exportarCSV;
window.exportarJSON = exportarJSON;
window.verificarConexao = verificarConexao;
window.editarMeta = editarMeta;
window.excluirMeta = excluirMeta;
window.atualizarTipoFiltroGestor = atualizarTipoFiltroGestor;
  window.analisarTendenciasIA = analisarTendenciasIA;
  window.atualizarStatusLogistica = atualizarStatusLogistica;
window.atualizarRastreio = atualizarRastreio;
window.atualizarChecklist = atualizarChecklist;
window.aplicarFiltroLogistica = aplicarFiltroLogistica;
  window.processarPlanilha = processarPlanilha;
window.toggleExportMenu = toggleExportMenu;

</script>
<script src="shared.js"></script>
<!-- Outras bibliotecas (como XLSX) -->
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

</body>
</html>

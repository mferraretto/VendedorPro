<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combinador de Etiqueta ZPL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- A biblioteca pdf-lib é carregada aqui -->
    <script src="https://unpkg.com/pdf-lib@1.4.0"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">

<div class="card-container w-full max-w-2xl flex flex-col gap-6">
    <div class="card bg-white p-8 rounded-xl shadow-lg border border-gray-200">
        <h1 class="text-2xl font-semibold text-gray-900 text-center mb-2">Combinador de ZPL</h1>
        <p class="text-gray-600 text-center mb-6">
            Selecione um ficheiro .zpl ou .txt para extrair os dados do checklist e combiná-los na etiqueta de envio.
        </p>
        <div class="flex flex-col items-center gap-4">
            <input 
                type="file" 
                id="zplFile" 
                accept=".zpl, .txt"
                class="block w-full max-w-sm text-sm text-gray-500
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-full file:border-0
                       file:text-sm file:font-semibold
                       file:bg-blue-50 file:text-blue-700
                       hover:file:bg-blue-100 cursor-pointer"
            >
            <button 
                id="converterButton" 
                class="px-6 py-3 bg-blue-800 text-white font-bold text-lg rounded-full 
                       shadow-lg hover:bg-blue-700 transition-all duração-300 transform 
                       hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Extrair e Gerar
            </button>
        </div>
        <div id="loading" class="text-center mt-6 text-gray-500 italic hidden">
            A processar... Por favor, aguarde, pois isso pode demorar um pouco.
        </div>
        <div id="error-message" class="text-red-500 font-bold text-center mt-4"></div>
    </div>

    <div class="card bg-white p-6 rounded-xl shadow-lg border border-gray-200" id="results-card" style="display:none;">
        <h2 class="text-xl font-semibold text-gray-900 text-center mb-4">Pré-visualização da Etiqueta</h2>
        <div id="preview-image-container" class="flex justify-center mb-4 p-4 border border-gray-300 rounded-lg">
            <img id="preview-image" src="" alt="Pré-visualização da etiqueta" class="max-w-full h-auto">
        </div>
        <div id="pdf-links" class="flex flex-col items-center gap-2">
            <!-- O link para o PDF será inserido aqui -->
        </div>
    </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const fileInput = document.getElementById('zplFile');
    const converterButton = document.getElementById('converterButton');
    const loadingDiv = document.getElementById('loading');
    const errorDiv = document.getElementById('error-message');
    const resultsCard = document.getElementById('results-card');
    const pdfLinksDiv = document.getElementById('pdf-links');
    const previewImage = document.getElementById('preview-image');

    // Estado inicial
    converterButton.disabled = true;

    fileInput.addEventListener('change', () => {
      converterButton.disabled = !fileInput.files.length;
      errorDiv.textContent = '';
      pdfLinksDiv.innerHTML = '';
      resultsCard.style.display = 'none';
      previewImage.src = '';
    });

    converterButton.addEventListener('click', processZPLBatch);

    async function processZPLBatch() {
      const file = fileInput.files && fileInput.files.length > 0 ? fileInput.files.item(0) : null;
      errorDiv.textContent = '';
      pdfLinksDiv.innerHTML = '';
      resultsCard.style.display = 'none';
      previewImage.src = '';

      if (!file) {
        errorDiv.textContent = 'Por favor, selecione um ficheiro ZPL para processar.';
        return;
      }

      loadingDiv.classList.remove('hidden');
      converterButton.disabled = true;

      try {
        const zplCode = await readFileAsync(file);

        // Pega TODOS os blocos ^XA ... ^XZ (cada bloco é uma "página" ZPL)
        const segments = zplCode.match(/\^XA[\s\S]*?\^XZ/g) || [];

        if (segments.length < 2) {
          throw new Error('Não foram encontrados blocos ZPL suficientes para etiqueta + checklist.');
        }

        // Agrupar de 2 em 2: [etiqueta, checklist], [etiqueta, checklist], ...
        const pairs = [];
        for (let i = 0; i < segments.length; i += 2) {
          const labelBlock = segments[i];
          const checklistBlock = segments[i + 1];
          if (!checklistBlock) {
            // bloco ímpar no fim: ignora ou trate como sem checklist
            console.warn('Bloco de checklist ausente para a etiqueta no índice', i);
            continue;
          }
          pairs.push({ labelBlock, checklistBlock });
        }

        if (pairs.length === 0) {
          throw new Error('Não foi possível formar pares etiqueta+checklist.');
        }

        // Configurações padrão
        const dpmm = 8;                 // 203 dpi
        const widthIn = 4.0;            // largura padrão em polegadas
        const baseHeightIn = 5.2;       // altura base antes de adicionar o conteúdo OCR

        // Vamos acumular todas as páginas (PNG já filtrados) e suas alturas em polegadas
        const processedPages = [];

        // Processa cada par
        for (let idx = 0; idx < pairs.length; idx++) {
          const { labelBlock, checklistBlock } = pairs[idx];

          // 1) Renderizar checklist -> PNG base64 (para OCR)
          const checklistPngBlob = await generateImageFromZpl(checklistBlock, dpmm, widthIn, baseHeightIn);
          const checklistBase64 = await blobToBase64(checklistPngBlob);

          // 2) OCR via Gemini
          const extractedData = await extractDataFromImage(checklistBase64);
          if (!extractedData || extractedData.length === 0) {
            console.warn(`Par ${idx + 1}: OCR não retornou dados; seguindo sem linhas adicionais.`);
          }

          // 3) Gerar ZPL combinado (etiqueta original + linhas OCR)
          const combinedZPL = generateCombinedZPL(labelBlock, extractedData || []);

          // 4) Altura final da página considerando linhas OCR
          const finalHeightIn = calculateNewTotalHeight(baseHeightIn, (extractedData || []).length, dpmm);

          // 5) Renderizar ZPL combinado -> PNG
          const combinedPngBlob = await generateImageFromZpl(combinedZPL, dpmm, widthIn, finalHeightIn);

          // 6) Aplicar filtro “preto” (contraste focado no escuro)
          const tempImg = await createHTMLImageFromBlob(combinedPngBlob);
          const processedPngBlob = await applyBlackContrast(tempImg);

          // Guarda para montagem do PDF
          processedPages.push({ pngBlob: processedPngBlob, widthIn, heightIn: finalHeightIn });

          // Prévia da primeira página
          if (idx === 0) {
            const url = URL.createObjectURL(processedPngBlob);
            previewImage.src = url;
            resultsCard.style.display = 'block';
          }
        }

        // 7) Criar PDF multi-página com numeração "i de N"
        const pdfBytes = await createPdfFromPngArray(processedPages);
        const pdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
        const pdfUrl = URL.createObjectURL(pdfBlob);

        // 8) Link para download
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.textContent = `Descarregar Etiquetas (${processedPages.length} páginas)`;
        link.download = 'etiquetas_combinadas.pdf';
        link.className = 'px-4 py-2 bg-blue-500 text-white font-bold rounded-full hover:bg-blue-600 transition-colors';
        pdfLinksDiv.appendChild(link);

        loadingDiv.classList.add('hidden');
        converterButton.disabled = false;
      } catch (error) {
        errorDiv.textContent = 'Ocorreu um erro durante o processamento. Verifique o console para mais detalhes.';
        console.error('Erro na conversão:', error);
        loadingDiv.classList.add('hidden');
        converterButton.disabled = false;
      }
    }

    // ====== FUNÇÕES DE APOIO ======

    function calculateNewTotalHeight(originalHeightIn, numberOfItems, dpmm) {
      const fontH = 22;
      const lineStep = 30;
      const yPadding = 250;
      const addedContentHeightDots = numberOfItems * (lineStep + fontH) + yPadding;
      const dotsPerInch = dpmm * 25.4;
      const addedContentHeightInches = addedContentHeightDots / dotsPerInch;
      return originalHeightIn + addedContentHeightInches;
    }

    async function generateImageFromZpl(zplCode, dpmm, width, height) {
      const apiUrl = `https://api.labelary.com/v1/printers/${dpmm}dpmm/labels/${width}x${height}/0/`;
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Accept': 'image/png',
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        body: zplCode
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Erro na API Labelary (imagem): ${response.status} ${response.statusText} - ${errorText}`);
      }
      return response.blob();
    }

    async function extractDataFromImage(base64Image) {
      const prompt = `
        Dada a imagem de um checklist ZPL, extraia o SKU e a quantidade.
        Retorne os resultados num array de objetos JSON, com as chaves "sku" e "quantidade".
        Exemplo: [ { "sku": "TR15", "quantidade": 1 } ]
        Por favor, apenas retorne o JSON e nada mais.
      `;

      const payload = {
        contents: [{
          role: "user",
          parts: [
            { text: prompt },
            { inlineData: { mimeType: "image/png", data: base64Image } }
          ]
        }],
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: {
            type: "ARRAY",
            items: {
              type: "OBJECT",
              properties: {
                "sku": { "type": "STRING" },
                "quantidade": { "type": "NUMBER" }
              }
            }
          }
        }
      };

      const apiKey = "AIzaSyDJWpigMGz4KV8XNcXd9r9VgbA24fy2Fec"; // sua chave
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

      let result;
      let attempts = 0;
      const maxAttempts = 5;
      let delay = 1000;

      while (attempts < maxAttempts) {
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!response.ok) {
            if (response.status === 429) {
              await new Promise(r => setTimeout(r, delay));
              delay *= 2;
              attempts++;
              continue;
            }
            const errorText = await response.text();
            throw new Error(`Erro na API Gemini: ${response.status} - ${errorText}`);
          }
          result = await response.json();
          break;
        } catch (err) {
          console.error('Falha na chamada Gemini, tentando novamente...', err);
          attempts++;
          if (attempts === maxAttempts) throw err;
          await new Promise(r => setTimeout(r, delay));
          delay *= 2;
        }
      }

      if (
        result?.candidates?.length > 0 &&
        result.candidates[0]?.content?.parts?.length > 0
      ) {
        const json = result.candidates[0].content.parts[0].text;
        try {
          return JSON.parse(json);
        } catch {
          console.warn('JSON inválido da Gemini, retornando array vazio.');
          return [];
        }
      } else {
        throw new Error("Resposta da API Gemini inválida.");
      }
    }

    function generateCombinedZPL(labelBlock, data) {
      // Remove ^XA/^XZ do bloco original
      let originalContent = labelBlock.replace(/\^XA|\^XZ/g, '');
      // Padronizar fonte conforme solicitado
      originalContent = originalContent.replace(/\^A0N,20,20/g, '^ABN,22,22');

      const dpmm = 8;
      const originalHeightIn = 6.0;
      const newContentStartX = 50;
      const newContentStartY = 1200; // ponto de partida do texto novo
      const fontH = 22;
      const fontW = 22;
      const lineStep = 30;

      let newContentZPL = '';
      (data || []).forEach((item, index) => {
        const y = newContentStartY + (index * (lineStep + fontH));
        const skuText = `^FO${newContentStartX},${y}^ABN,${fontH},${fontW}^FD SKU: ${item.sku} ^FS`;
        const qtdText = `^FO${newContentStartX},${y + fontH + 5}^ABN,${fontH},${fontW}^FD Qtd: ${item.quantidade} ^FS`;
        newContentZPL += `${skuText}${qtdText}`;
      });

      const totalPageHeightInches = calculateNewTotalHeight(originalHeightIn, (data || []).length, dpmm);
      const totalPageHeightDots = Math.round(totalPageHeightInches * dpmm * 25.4); // dpmm * mm por polegada

      return `^XA^LL${totalPageHeightDots}^LH0,0${originalContent}${newContentZPL}^XZ`;
    }

    function readFileAsync(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(',')[1]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function createHTMLImageFromBlob(blob) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = URL.createObjectURL(blob);
      });
    }

    async function applyBlackContrast(imageElement, { contrast = 40, gamma = 0.9, threshold = 200 } = {}) {
      const canvas = document.createElement('canvas');
      canvas.width = imageElement.naturalWidth;
      canvas.height = imageElement.naturalHeight;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(imageElement, 0, 0);

      const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = img.data;

      const factor = (359 * (contrast + 255)) / (255 * (259 - contrast));

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];
        let y = 0.2126 * r + 0.7152 * g + 0.0722 * b; // luminância

        if (y < threshold) {
          let v = factor * (y - 128) + 128;
          v = 255 * Math.pow(v / 255, gamma);
          if (v > y) v = y;
          if (v < 0) v = 0;
          if (v > 255) v = 255;
          data[i] = data[i + 1] = data[i + 2] = v;
        } else {
          const v2 = y > 255 ? 255 : y;
          data[i] = data[i + 1] = data[i + 2] = v2;
        }
      }

      ctx.putImageData(img, 0, 0);
      return new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1));
    }

    async function createPdfFromPngArray(pages) {
      const { PDFDocument, StandardFonts } = PDFLib;
      const pdfDoc = await PDFDocument.create();
      const totalPages = pages.length;
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const fontSize = 12;

      for (let i = 0; i < pages.length; i++) {
        const { pngBlob, widthIn, heightIn } = pages[i];
        const page = pdfDoc.addPage([widthIn * 72, heightIn * 72]);

        const pngBytes = await pngBlob.arrayBuffer();
        const pngImage = await pdfDoc.embedPng(pngBytes);

        page.drawImage(pngImage, {
          x: 0,
          y: 0,
          width: widthIn * 72,
          height: heightIn * 72
        });

        // Numeração "i de N"
        const pageNumberText = `${i + 1} de ${totalPages}`;
        const textWidth = font.widthOfTextAtSize(pageNumberText, fontSize);
        const x = (page.getWidth() - textWidth) / 2;
        const y = 10;
        page.drawText(pageNumberText, { x, y, size: fontSize, font });
      }

      return await pdfDoc.save();
    }
  });
</script>

</body>
</html>

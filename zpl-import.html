<!DOCTYPE html> 
<html lang="pt-BR"> 
<head> 
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> 
    <title>Combinador de Etiqueta ZPL</title> 
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css?v=20240826">
    <link rel="stylesheet" href="css/components.css">
    <!-- A biblioteca pdf-lib é carregada aqui -->
    <script src="https://unpkg.com/pdf-lib@1.4.0"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
    <script type="module" src="firebase-config.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@600;800&display=swap'); 
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #f0f4f8; 
        } 
    </style> 
</head> 
<body class="bg-gray-50">
  <div id="sidebar-container"></div>
  <div id="navbar-container"></div>
  <div class="main-content flex items-center justify-center min-h-screen p-4">

<div class="card-container w-full max-w-2xl flex flex-col gap-6">
    <div class="card bg-white p-8 rounded-xl shadow-lg border border-gray-200"> 
        <h1 class="text-2xl font-semibold text-gray-900 text-center mb-2">Combinador de ZPL</h1> 
        <p class="text-gray-600 text-center mb-6"> 
            Selecione um ficheiro .zpl ou .txt para extrair os dados do checklist e combiná-los na etiqueta de envio. 
        </p> 
        <div class="flex flex-col items-center gap-4">
            <input
                type="file"
                id="zplFile"
                accept=".zpl, .txt"
                class="block w-full max-w-sm text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-blue-50 file:text-blue-700
                        hover:file:bg-blue-100 cursor-pointer"
            >
            <input
                type="text"
                id="gestoresEmails"
                placeholder="E-mails do gestor de expedição (separados por vírgula)"
                class="block w-full max-w-sm text-sm text-gray-500 border border-gray-300 rounded p-2"
            >
            <button
                id="converterButton"
                class="px-6 py-3 bg-blue-800 text-white font-bold text-lg rounded-full
                        shadow-lg hover:bg-blue-700 transition-all duration-300 transform
                        hover:scale-105 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Extrair e Gerar 
            </button> 
        </div> 

        <!-- Progress bar and status -->
        <div id="progress-container" class="mt-6 hidden">
            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
            <p id="progress-status" class="text-center text-sm text-gray-600 mt-2"></p>
        </div>
        
        <div id="error-message" class="text-red-500 font-bold text-center mt-4"></div> 
    </div> 

    <div class="card bg-white p-6 rounded-xl shadow-lg border border-gray-200" id="results-card" style="display:none;"> 
        <h2 class="text-xl font-semibold text-gray-900 text-center mb-4">Pré-visualização da Etiqueta</h2> 
        <div id="preview-image-container" class="flex justify-center mb-4 p-4 border border-gray-300 rounded-lg"> 
            <img id="preview-image" src="" alt="Pré-visualização da etiqueta" class="max-w-full h-auto"> 
        </div> 
        <div id="pdf-links" class="flex flex-col items-center gap-2"> 
            <!-- O link para o PDF será inserido aqui --> 
        </div> 
    </div> 
</div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
        const db = firebase.firestore();
        const storage = firebase.storage();
        let currentUser = null;
 let responsavelExpedicaoUid = null;
         let responsavelExpedicaoEmail = null;
        firebase.auth().onAuthStateChanged(async u => {
            currentUser = u;
            if (!u) return;
            try {
                const doc = await db.collection('uid').doc(u.uid).get();
                const data = doc.data() || {};
                const emails = data.gestoresExpedicaoEmails || data.responsavelExpedicaoEmail || '';
                document.getElementById('gestoresEmails').value = Array.isArray(emails) ? emails.join(', ') : emails;
                const respEmail = Array.isArray(data.gestoresExpedicaoEmails)
                    ? data.gestoresExpedicaoEmails[0]
                    : data.responsavelExpedicaoEmail;
                if (respEmail) {
              responsavelExpedicaoEmail = respEmail;
                    const snap = await db.collection('uid').where('email', '==', respEmail).limit(1).get();
                    if (!snap.empty) responsavelExpedicaoUid = snap.docs[0].id;
                }
            } catch (e) {
                console.error('Erro ao carregar gestor de expedição:', e);
            }
        });
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function savePdf(blob, name) {
            if (!currentUser) return;
            const gestoresRaw = document.getElementById('gestoresEmails').value || '';
            const gestoresEmails = gestoresRaw.split(',').map(e => e.trim()).filter(e => e);
            const docRef = await db.collection('pdfDocs').add({
                ownerUid: currentUser.uid,
                ownerEmail: currentUser.email,
                gestoresExpedicaoEmails: gestoresEmails,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                name: name
            });
            const fileRef = storage.ref().child(`pdfs/${currentUser.uid}/${docRef.id}.pdf`);
            await fileRef.put(blob);
            const url = await fileRef.getDownloadURL();
            await docRef.update({ url: url, storagePath: fileRef.fullPath });
            const record = {
                name: name,
                url: url,
                path: fileRef.fullPath,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('users').doc(currentUser.uid).collection('etiquetaenvio').add({ ...record });
             if (responsavelExpedicaoUid) {
                const respDocRef = await db.collection('pdfDocs').add({
                    ownerUid: responsavelExpedicaoUid,
                    ownerEmail: responsavelExpedicaoEmail || '',
                    gestoresExpedicaoEmails: gestoresEmails,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    name: name
                });
                const respFileRef = storage.ref().child(`pdfs/${responsavelExpedicaoUid}/${respDocRef.id}.pdf`);
                await respFileRef.put(blob);
                const respUrl = await respFileRef.getDownloadURL();
                await respDocRef.update({ url: respUrl, storagePath: respFileRef.fullPath });
                const respRecord = {
                    name: name,
                    url: respUrl,
                    path: respFileRef.fullPath,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('users').doc(responsavelExpedicaoUid).collection('etiquetaenvio').add({ ...respRecord });
            }
        }

        async function savePrintedSkuQuantities(items) {
            if (!currentUser || !items || items.length === 0) return;
            const batch = db.batch();
            const userDoc = db.collection('uid').doc(currentUser.uid);
            const respDoc = responsavelExpedicaoUid ? db.collection('uid').doc(responsavelExpedicaoUid) : null;
            items.forEach(item => {
                const data = {
                    sku: item.sku,
                    quantidade: item.quantidade,
                    loja: item.loja || '',
                    userUid: currentUser.uid,
                    userEmail: currentUser.email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                batch.set(userDoc.collection('skuimpressos').doc(), data);
                if (respDoc) {
                    batch.set(respDoc.collection('skuimpressos').doc(), data);
                }
            });
            await batch.commit();
        }

        const fileInput = document.getElementById('zplFile');
        const converterButton = document.getElementById('converterButton');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const errorDiv = document.getElementById('error-message');
        const resultsCard = document.getElementById('results-card');
        const pdfLinksDiv = document.getElementById('pdf-links');
        const previewImage = document.getElementById('preview-image');

        const GEMINI_DELAY_MS = 5000;
        let lastGeminiCall = 0;
        async function fetchWithGeminiDelay(url, options) {
            const now = Date.now();
            const elapsed = now - lastGeminiCall;
            if (elapsed < GEMINI_DELAY_MS) {
                await new Promise(r => setTimeout(r, GEMINI_DELAY_MS - elapsed));
            }
            lastGeminiCall = Date.now();
            return fetch(url, options);
        }

        // Initial state of the user interface
        converterButton.disabled = true; 

        fileInput.addEventListener('change', () => { 
            converterButton.disabled = !fileInput.files.length; 
            errorDiv.textContent = ''; 
            pdfLinksDiv.innerHTML = ''; 
            resultsCard.style.display = 'none'; 
            previewImage.src = ''; 
        }); 

        converterButton.addEventListener('click', processZPL); 

        async function processZPL() { 
            const file = fileInput.files && fileInput.files.length > 0 ? fileInput.files.item(0) : null; 
            errorDiv.textContent = ''; 
            pdfLinksDiv.innerHTML = ''; 
            resultsCard.style.display = 'none'; 
            previewImage.src = ''; 

            if (!file) { 
                errorDiv.textContent = 'Por favor, selecione um ficheiro ZPL para processar.'; 
                return; 
            } 

            // Show progress bar and disable button
            progressContainer.classList.remove('hidden');
            progressBar.style.width = '0%';
            progressStatus.textContent = 'A preparar...';
            converterButton.disabled = true; 

            try { 
                const zplCode = await readFileAsync(file); 
                // Regex to find ^XA...^XZ blocks, ignoring ^DGR to capture both blocks. 
                const blocks = zplCode.match(/(~DGR[\s\S]*?\^XA[\s\S]*?\^XZ)/g); 

                if (!blocks || blocks.length < 2 || blocks.length % 2 !== 0) { 
                    throw new Error('Não foram encontrados blocos ZPL suficientes para a etiqueta e o checklist, ou o número de blocos é ímpar.'); 
                } 
                
                const dpmm = 8;
                const originalWidthIn = 4.0;
                const originalHeightIn = 5.2;
                const { PDFDocument } = PDFLib;
                const pdfDoc = await PDFDocument.create();
                const totalLabels = blocks.length / 2;
                const allExtractedItems = [];
                let labelCounter = 1;

                // Loop to process each pair of ZPL blocks
                for (let i = 0; i < blocks.length; i += 2) {
                    const currentLabelIndex = (i / 2) + 1;
                    progressStatus.textContent = `A processar etiqueta ${currentLabelIndex} de ${totalLabels}...`;
                    progressBar.style.width = `${(currentLabelIndex / totalLabels) * 100}%`;

                    const labelBlock = blocks[i];
                    const checklistBlock = blocks[i + 1];

                    // Extração da loja a partir da etiqueta
                    const loja = await getStoreFromLabel(labelBlock, dpmm, originalWidthIn, originalHeightIn);

                    // 1. Render checklist as an image for analysis
                   const checklistImageBlob = await generateImageFromZpl(checklistBlock, dpmm, originalWidthIn, originalHeightIn);
                    const checklistBase64 = await blobToBase64(checklistImageBlob);

                    // 2. Use Gemini API to extract SKU and quantity
                    const extractedData = await extractDataFromImage(checklistBase64);
                    if (loja) {
                        extractedData.forEach(item => item.loja = loja);
                    }
                    // keep track of all items for posterior saving
                    allExtractedItems.push(...extractedData);

                    // 3. Generate ZPL for the new combined label
                    const combinedZPL = generateCombinedZPL(labelBlock, extractedData, labelCounter);
                    
                    // 4. Calculate new total page height
                    const newTotalHeightInches = calculateNewTotalHeight(originalHeightIn, extractedData.length, dpmm); 
                    
                    // 5. Get PNG of the combined label from Labelary API
                    const combinedPngBlob = await generateImageFromZpl(combinedZPL, dpmm, originalWidthIn, newTotalHeightInches); 
                    const processedPngBlob = await applyBlackContrastFromBlob(combinedPngBlob); 

                    // 6. Create PDF from the processed PNG
                    const pngBytes = await processedPngBlob.arrayBuffer(); 
                    const pngImage = await pdfDoc.embedPng(pngBytes); 
                    const page = pdfDoc.addPage([originalWidthIn * 72, newTotalHeightInches * 72]); 
                    page.drawImage(pngImage, { x: 0, y: 0, width: originalWidthIn * 72, height: newTotalHeightInches * 72 });
                    labelCounter++;
                }

                // 7. Save the final PDF
                const pdfBytes = await pdfDoc.save();
                const pdfBlob = new Blob([pdfBytes], { type: 'application/pdf' });
                const pdfUrl = URL.createObjectURL(pdfBlob);

                const fileName = `etiquetas-combinadas-${Date.now()}.pdf`;

                // Add the download link
                const link = document.createElement('a');
                link.href = pdfUrl;
                link.download = fileName;
                link.textContent = 'Transferir PDF Combinado';
                link.classList.add('px-6', 'py-3', 'bg-green-600', 'text-white', 'font-bold', 'rounded-full', 'shadow-lg', 'hover:bg-green-500', 'transition-all', 'duration-300');
                pdfLinksDiv.appendChild(link);

                await savePdf(pdfBlob, fileName);
                await savePrintedSkuQuantities(allExtractedItems);
                
                // 8. Display the preview of the first label
                const firstChecklistData = await extractDataFromImage(
                    await blobToBase64(await generateImageFromZpl(blocks[1], dpmm, originalWidthIn, originalHeightIn))
                );
                const firstLabelImageBlob = await generateImageFromZpl(
                    generateCombinedZPL(blocks[0], firstChecklistData, 1),
                    dpmm,
                    originalWidthIn,
                    calculateNewTotalHeight(originalHeightIn, firstChecklistData.length, dpmm)
                );
                const firstLabelImageUrl = URL.createObjectURL(firstLabelImageBlob);
                previewImage.src = firstLabelImageUrl;
                previewImage.onload = () => { if (firstLabelImageUrl) URL.revokeObjectURL(firstLabelImageUrl); };
                resultsCard.style.display = 'block';

            } catch (error) { 
                errorDiv.textContent = `Ocorreu um erro durante o processamento: ${error.message}`; 
                console.error('Erro na conversão:', error); 
            } finally { 
                // Hide progress bar and re-enable button
                progressContainer.classList.add('hidden');
                converterButton.disabled = false; 
                progressBar.style.width = '0%';
            } 
        } 
        
        function calculateNewTotalHeight(originalHeightIn, numberOfItems, dpmm) { 
            const fontH = 22; 
            const lineStep = 30; 
            const yPadding = 250; 
            const addedContentHeightDots = numberOfItems * (lineStep + fontH); 
            
            const dotsPerInch = dpmm * 25.4; 
            const addedContentHeightInches = (addedContentHeightDots + yPadding) / dotsPerInch; 
            
            return originalHeightIn + addedContentHeightInches; 
        } 

async function generateImageFromZpl(zplCode, dpmm, width, height) {
            const apiUrl = `https://api.labelary.com/v1/printers/${dpmm}dpmm/labels/${width}x${height}/0/`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Accept': 'image/png',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: zplCode
            });
            if (!response.ok) { 
                const errorText = await response.text(); 
                throw new Error(`Erro na API Labelary (imagem): ${response.status} ${response.statusText} - ${errorText}`); 
            } 

              return response.blob();
        }

        function extractStoreFromZpl(zplCode) {
            const remRegex = /Remetente\^FS[\s\S]*?\^FD([^\^]+)\^FS/i;
            const match = zplCode.match(remRegex);
            if (match) {
                return match[1].trim();
            }
            const sameLine = /Remetente:?\s*([^\^]+)\^FS/i;
            const matchSame = zplCode.match(sameLine);
            return matchSame ? matchSame[1].trim() : null;
        }

        async function getStoreFromLabel(zplCode, dpmm, width, height) {
            try {
                const lojaFromZpl = extractStoreFromZpl(zplCode);
                if (lojaFromZpl) return lojaFromZpl;
                const labelBlob = await generateImageFromZpl(zplCode, dpmm, width, height);
                const labelBase64 = await blobToBase64(labelBlob);
                return await extractStoreFromImage(labelBase64);
            } catch (e) {
                console.error('Erro ao obter loja da etiqueta:', e);
                return null;
            }
        }

        async function extractStoreFromImage(base64Image) {
            const prompt = `A etiqueta de envio possui o texto \"Remetente\" seguido do nome da loja. Identifique esse nome e retorne apenas um objeto JSON com a chave \"loja\".`;
            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: "image/png",
                                    data: base64Image
                                }
                            }
                        ]
                    }
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "loja": { "type": "STRING" }
                        }
                    }
                }
            };
            const apiKey = "AIzaSyDJWpigMGz4KV8XNcXd9r9VgbA24fy2Fec";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`;
            let result;
            let attempts = 0;
            const maxAttempts = 5;
            let delay = 1000;
            while (attempts < maxAttempts) {
                try {
                    const response = await fetchWithGeminiDelay(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        console.error(`Attempt ${attempts + 1} failed with status: ${response.status} - ${await response.text()}`);
                        if (response.status === 429) {
                            await new Promise(r => setTimeout(r, delay));
                            delay *= 2;
                            attempts++;
                            continue;
                        }
                        throw new Error(`Erro na API Gemini: ${response.status} - ${await response.text()}`);
                    }
                    result = await response.json();
                    break;
                } catch (error) {
                    console.error('API loja call failed, retrying...', error);
                    attempts++;
                    if (attempts === maxAttempts) {
                        throw error;
                    }
                    await new Promise(r => setTimeout(r, delay));
                    delay *= 2;
                }
            }

            if (!result || !result.candidates || result.candidates.length === 0 ||
                !result.candidates.at(0).content || !result.candidates.at(0).content.parts ||
                result.candidates.at(0).content.parts.length === 0) {
                throw new Error("Resposta da API Gemini inválida para loja.");
            }

            const json = result.candidates.at(0).content.parts.at(0).text;
            console.log('Loja extraída da API:', json);
            try {
                return JSON.parse(json).loja || null;
            } catch {
                return null;
            }
        }

        async function extractDataFromImage(base64Image) {
            const prompt = `Dada a imagem de um checklist ZPL, extraia o SKU, a quantidade e a loja. Retorne os resultados num array de objetos JSON, com as chaves "sku", "quantidade" e "loja". Por favor, apenas retorne o JSON e nada mais.`;
            const payload = { 
                contents: [ 
                    { 
                        role: "user", 
                        parts: [ 
                            { text: prompt }, 
                            { 
                                inlineData: { 
                                    mimeType: "image/png", 
                                    data: base64Image 
                                } 
                            } 
                        ] 
                    } 
                ], 
                generationConfig: { 
                    responseMimeType: "application/json", 
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "sku": { "type": "STRING" },
                                "quantidade": { "type": "NUMBER" },
                                "loja": { "type": "STRING" }
                            }
                        }
                    }
                }
            };
            
            const apiKey = "AIzaSyDJWpigMGz4KV8XNcXd9r9VgbA24fy2Fec";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`; 
            
            let result; 
            let attempts = 0; 
            const maxAttempts = 5; 
            let delay = 1000; 

            while (attempts < maxAttempts) { 
                try { 
                    const response = await fetchWithGeminiDelay(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) { 
                        console.error(`Attempt ${attempts + 1} failed with status: ${response.status} - ${await response.text()}`); 
                        if (response.status === 429) { // Too Many Requests 
                            await new Promise(resolve => setTimeout(resolve, delay)); 
                            delay *= 2; 
                            attempts++; 
                            continue; 
                        } 
                        throw new Error(`Erro na API Gemini: ${response.status} - ${await response.text()}`); 
                    } 
                    
                    result = await response.json(); 
                    break; 
                } catch (error) { 
                    console.error('API call failed, retrying...', error); 
                    attempts++; 
                    if (attempts === maxAttempts) { 
                        throw error; 
                    } 
                    await new Promise(resolve => setTimeout(resolve, delay)); 
                    delay *= 2; 
                } 
            } 

            if (!result || !result.candidates || result.candidates.length === 0 || 
                !result.candidates.at(0).content || !result.candidates.at(0).content.parts || 
                result.candidates.at(0).content.parts.length === 0) { 
                throw new Error("Resposta da API Gemini inválida."); 
            } 
            
            const json = result.candidates.at(0).content.parts.at(0).text; 
            console.log('Dados extraídos da API:', json); 
            return JSON.parse(json); 
        } 

        function generateCombinedZPL(labelBlock, data, labelNumber) {
            let originalContent = labelBlock.replace(/\^XA|\^XZ/g, ''); 
            originalContent = originalContent.replace(/\^A0N,20,20/g, '^ABN,22,22'); 
            const newContentStartX = 50; 
            const newContentStartY = 1200; 
            const fontH = 22; 
            const fontW = 22; 
            const lineStep = 30; 

            let newContentZPL = ''; 
            if (data && data.length > 0) { 
                data.forEach((item, index) => { 
                    const y = newContentStartY + (index * (lineStep + fontH)); 
                    const skuText = `^FO${newContentStartX},${y}^ABN,${fontH},${fontW}^FD SKU: ${item.sku} ^FS`; 
                    const qtdText = `^FO${newContentStartX},${y + fontH + 5}^ABN,${fontH},${fontW}^FD Qtd: ${item.quantidade} ^FS`; 
                    newContentZPL += `${skuText}${qtdText}`; 
                }); 
            } 
            
            const dpmm = 8; 
            const originalHeightIn = 5.2; 
            const totalPageHeightInches = calculateNewTotalHeight(originalHeightIn, data.length, dpmm);
            const totalPageHeightDots = Math.round(totalPageHeightInches * dpmm * 8);
            const numberY = totalPageHeightDots - 420;
            const numberZpl = `^FO50,${numberY}^ABN,22,22^FD${labelNumber}^FS`;

            return `^XA^LL${totalPageHeightDots}^LH0,0${originalContent}${newContentZPL}${numberZpl}^XZ`;
        }

        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    resolve(reader.result);
                };
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        async function applyBlackContrastFromBlob(imageBlob, { contrast = 40, gamma = 0.9, threshold = 200 } = {}) { 
            return new Promise((resolve, reject) => { 
                const imgElement = new Image(); 
                imgElement.onload = () => { 
                    const canvas = document.createElement('canvas'); 
                    canvas.width = imgElement.naturalWidth; 
                    canvas.height = imgElement.naturalHeight; 
                    const ctx = canvas.getContext('2d', { willReadFrequently: true }); 
                    ctx.drawImage(imgElement, 0, 0); 

                    const img = ctx.getImageData(0, 0, canvas.width, canvas.height); 
                    const data = img.data; 

                    const factor = (359 * (contrast + 255)) / (255 * (259 - contrast)); 

                    for (let i = 0; i < data.length; i += 4) { 
                        const r = data[i], g = data[i + 1], b = data[i + 2]; 
                        let y = 0.2126 * r + 0.7152 * g + 0.0722 * b; 

                        if (y < threshold) { 
                            let v = factor * (y - 128) + 128; 
                            v = 255 * Math.pow(v / 255, gamma); 
                            if (v > y) v = y; 
                            if (v < 0) v = 0; 
                            if (v > 255) v = 255; 

                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } else { 
                            const v = y > 255 ? 255 : y; 
                            data[i] = data[i + 1] = data[i + 2] = v; 
                        } 
                    } 
                    ctx.putImageData(img, 0, 0); 
                    canvas.toBlob(resolve, 'image/png', 1); 
                    if (imgElement.src) URL.revokeObjectURL(imgElement.src); 
                }; 
                imgElement.onerror = reject; 
                imgElement.src = URL.createObjectURL(imageBlob); 
            }); 
        } 
    }); 
</script>
<script src="shared.js"></script>

</body>
</html>
